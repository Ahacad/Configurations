SCRIPT  /tmp/nvimNZzqJS/coc.nvim-48565/coc-48565.vim
Sourced 1 time
Total time:   0.000702
 Self time:   0.000702

count  total (s)   self (s)
                            
    1              0.000005 augroup coc_dynamic_autocmd
    1              0.000629   autocmd!
    1              0.000022   autocmd BufReadCmd,FileReadCmd,SourceCmd output:/* call coc#rpc#request('CocAutocmd', ['BufReadCmd','output', expand('<amatch>')])
    1              0.000010   autocmd BufReadCmd,FileReadCmd,SourceCmd coc:/* call coc#rpc#request('CocAutocmd', ['BufReadCmd','coc', expand('<amatch>')])
    1              0.000007   autocmd BufEnter *.vim call coc#rpc#notify('doAutocmd', [1])
    1              0.000007   autocmd OptionSet runtimepath call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
    1              0.000007   autocmd OptionSet completeopt call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])
    1              0.000001 augroup end
SCRIPT  /usr/share/nvim/runtime/ftplugin/vim.vim
Sourced 1 time
Total time:   0.001333
 Self time:   0.001333

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Apr 11
                            
                            " Only do this when not done yet for this buffer
    1              0.000024 if exists("b:did_ftplugin")
                              finish
    1              0.000003 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000011 let b:did_ftplugin = 1
                            
    1              0.000025 let s:cpo_save = &cpo
    1              0.000033 set cpo&vim
                            
    1              0.000012 if !exists('*VimFtpluginUndo')
    1              0.000007   func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    1              0.000002 endif
                            
    1              0.000007 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000028 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000080 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    1              0.000016 setlocal keywordprg=:help
                            
                            " if "\n" .. getline(1, 10)->join("\n") =~# '\n\s*vim9\%[script]\>'
    1              0.000067 if "\n" .. join(getline(1, 10), "\n") =~# '\n\s*vim9\%[script]\>'
                              " Set 'comments' to format dashed lists in comments
                              setlocal com=sO:#\ -,mO:#\ \ ,eO:##,:#
                              " Comments starts with # in Vim9 script
                              setlocal commentstring=#%s
    1              0.000003 else
    1              0.000024   setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                              " Comments starts with a double quote in legacy script
    1              0.000007   setlocal commentstring=\"%s
    1              0.000002 endif
                            
                            
                            " Format comments to be up to 78 characters long
    1              0.000009 if &tw == 0
    1              0.000017   setlocal tw=78
    1              0.000002 endif
                            
                            " Prefer Vim help instead of manpages.
    1              0.000006 setlocal keywordprg=:help
                            
    1              0.000014 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    1              0.000007   let b:did_add_maps = 1
                            
                              " Move around functions.
    1              0.000132   nnoremap <silent><buffer> [[ m':call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000063   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000050   nnoremap <silent><buffer> ]] m':call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000051   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000045   nnoremap <silent><buffer> [] m':call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000050   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000046   nnoremap <silent><buffer> ][ m':call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
    1              0.000048   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
                            
                              " Move around comments
    1              0.000044   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000048   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000043   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000048   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000003 endif
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000010 if exists("loaded_matchit")
    1              0.000008   let b:match_ignorecase = 0
                              " "func" can also be used as a type:
                              "   var Ref: func
                              " or to list functions:
                              "   func name
                              " require a parenthesis following, then there can be an "endfunc".
    1              0.000047   let b:match_words =
                            	\ '\<\%(fu\%[nction]\|def\)!\=\s\+\S\+(:\%(\%(^\||\)\s*\)\@<=\<retu\%[rn]\>:\%(\%(^\||\)\s*\)\@<=\<\%(endf\%[unction]\|enddef\)\>,' .
                            	\ '\<\(wh\%[ile]\|for\)\>:\%(\%(^\||\)\s*\)\@<=\<brea\%[k]\>:\%(\%(^\||\)\s*\)\@<=\<con\%[tinue]\>:\%(\%(^\||\)\s*\)\@<=\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\%(\%(^\||\)\s*\)\@<=\<el\%[seif]\>:\%(\%(^\||\)\s*\)\@<=\<en\%[dif]\>,' .
                            	\ '{:},' .
                            	\ '\<try\>:\%(\%(^\||\)\s*\)\@<=\<cat\%[ch]\>:\%(\%(^\||\)\s*\)\@<=\<fina\%[lly]\>:\%(\%(^\||\)\s*\)\@<=\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
    1              0.000010   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    1              0.000002 endif
                            
    1              0.000023 let &cpo = s:cpo_save
    1              0.000008 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/share/nvim/runtime/syntax/vim.vim
Sourced 1 time
Total time:   0.022355
 Self time:   0.018497

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000021 if exists("b:current_syntax")
                              finish
    1              0.000003 endif
    1              0.000034 let s:keepcpo= &cpo
    1              0.000034 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000072 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000024 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000070 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000049 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000041 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000119 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000029 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000019 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000475 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000026 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    1              0.000021 syn match   vimTermOption contained	"t_%1"
    1              0.000014 syn match   vimTermOption contained	"t_#2"
    1              0.000011 syn match   vimTermOption contained	"t_#4"
    1              0.000020 syn match   vimTermOption contained	"t_@7"
    1              0.000011 syn match   vimTermOption contained	"t_*7"
    1              0.000011 syn match   vimTermOption contained	"t_&8"
    1              0.000010 syn match   vimTermOption contained	"t_%i"
    1              0.000009 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000047 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    1              0.000006 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000128 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    1              0.000178 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question QuickFixLine Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    1              0.000040 syn match vimHLGroup contained	"Conceal"
    1              0.000049 syn keyword vimOnlyHLGroup contained	LineNrAbove LineNrBelow StatusLineTerm Terminal VisualNOS
    1              0.000052 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC
                            "}}}2
    1              0.000005 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands {{{2
    1              0.000031 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[afhlmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'h'
                              com! -nargs=* VimFoldh <args> fold
                             else
                              com! -nargs=* VimFoldh <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    1              0.000003 else
    1              0.000067  com! -nargs=*	VimFolda	<args>
    1              0.000028  com! -nargs=*	VimFoldf	<args>
    1              0.000023  com! -nargs=*	VimFoldh	<args>
    1              0.000022  com! -nargs=*	VimFoldl	<args>
    1              0.000023  com! -nargs=*	VimFoldm	<args>
    1              0.000023  com! -nargs=*	VimFoldp	<args>
    1              0.000023  com! -nargs=*	VimFoldP	<args>
    1              0.000021  com! -nargs=*	VimFoldr	<args>
    1              0.000022  com! -nargs=*	VimFoldt	<args>
    1              0.000004 endif
                            
                            " commands not picked up by the generator (due to non-standard format) {{{2
    1              0.000013 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    1              0.000019 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    1              0.000003 endif
    1              0.000013 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    1              0.000002 endif
    1              0.000009 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    1              0.000002 endif
                            
                            " Variable options {{{2
    1              0.000009 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    1              0.000004 else
    1              0.000014  let s:vimsyn_maxlines= 60
    1              0.000003 endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000183 syn match vimNumber	'\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=' skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000047 syn match vimNumber	'-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\='  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000034 syn match vimNumber	'\<0[xX]\x\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000035 syn match vimNumber	'\%(^\|\A\)\zs#\x\{6}'             	       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000036 syn match vimNumber	'\<0[zZ][a-zA-Z0-9.]\+'                    skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000030 syn match vimNumber	'0[0-7]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment           
    1              0.000024 syn match vimNumber	'0[bB][01]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment           
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    1              0.000271 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimEcho,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000029 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000049 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000023 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000015 syn match vimVar	      	"\s\zs&\a\+\>"
    1              0.000044 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000014 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    1              0.000083 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$""
    1              0.000031 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$""
    1              0.000036 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$""
    1              0.000022 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=starti\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    1              0.000055 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000009 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000027 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000012  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000004 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000069 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000014 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000009  syn match   vimFTError  contained	"\I\i*"
    1              0.000002 endif
    1              0.000008 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000010 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000332 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimNotFunc,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vim9Comment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vim9Comment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    1              0.000013 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
    1              0.000004 else
    1              0.000050  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000003 endif
    1              0.000019 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000014 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000029  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000002 endif
    1              0.000010 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000055 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue,vim9Comment
    1              0.000038 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000023 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    1              0.000017 syn match	vimOper	"||\|&&\|[-+.!]"				skipwhite nextgroup=vimString,vimSpecFile
    1              0.000059 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=vimoperStar,@vimOperGroup
    1              0.000041 syn region	vimOperParen	matchgroup=vimSep		start="#\={" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000015 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000024  syn match	vimOperError	")"
    1              0.000002 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000062 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000297 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimEnvvar,vimExecute,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLetHereDoc,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSearch,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    1              0.000067 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000016 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000003 else
    1              0.000029  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000002 endif
    1              0.000012 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000022 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000012 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000026 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000025 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000040 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000020 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000017 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000014 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000012 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000015 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000012 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000209 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimCtrlChar,vimEscapeBrace,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000016 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000115 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList,vimComFilter
    1              0.000016 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000065 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000089 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000037 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000028 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000021 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000017 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000017 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000016 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000021 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000010  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000003 endif
    1              0.000003 syn case ignore
    1              0.000033 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000041 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    1              0.000036 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000029 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000003 syn case match
    1              0.000011 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000043 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000018 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000018 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            " Vim9 comments - TODO: might be highlighted while they don't work
    1              0.000019 syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000015 syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000013 syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString
                            " Vim9 comment inside expression
    1              0.000014 syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString
    1              0.000013 syn match	vim9Comment	+^\s*#[^{].*$+	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn match	vim9Comment	+^\s*#$+	contains=@vimCommentGroup,vimCommentString
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000009 syn match	vimEnvvar	"\$\I\i*"
    1              0.000009 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000032 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000030 syn match	vimPatSepErr	contained	"\\)"
    1              0.000025 syn match	vimPatSep	contained	"\\|"
    1              0.000065 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    1              0.000061 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000023 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000020 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000057 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    1              0.000018 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000024 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000020 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
                            "syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup  " see tst45.vim
    1              0.000033 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000015 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000034 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000027 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000025 syn cluster	vimSubstList	add=vimCollection
    1              0.000056 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
                            "syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000027 syn match	vimSubst	"\%(^\|[^\\\"']\)\<s\%[ubstitute]\>[:#[:alpha:]\"']\@!"	nextgroup=vimSubstPat contained
    1              0.000017 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000017 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000030 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000030 syn match	vimSubst2       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000077 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000059 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000042 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000026 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000046 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000010 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000007 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000033 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000011 syn match	vimSubstFlags   contained	"[&cegiIlnpr#]\+"
                            
                            " 'String': {{{2
    1              0.000013 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000044 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000021 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000020 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000026 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000022 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000016 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst2
    1              0.000028 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    1              0.000040 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    1              0.000030 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000013 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000010 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000009 syn match	vimRegister	'@"'
    1              0.000032 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000015 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000013 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000023 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000018 syn match	vimFilter    contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000018 syn match	vimComFilter contained	"|!!\=[^"]\{-}\(|\|\ze\"\|$\)"      contains=vimOper,vimSpecFile
                            
                            " Complex Repeats: (:h complex-repeat) {{{2
    1              0.000013 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000028 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000104 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" oneline keepend contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vim9Comment,vimSetString,vimSetMod
    1              0.000064  syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]"me=e-1 end="$"	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar
    1              0.000026 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    1              0.000008 syn match	vimSetSep	contained	"[,:]"
    1              0.000017 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let: {{{2
                            " ===
    1              0.000024 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar,vimLetHereDoc
    1              0.000157 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\s\+\%(trim\>\)\=\s*\z(\L\S*\)'	matchgroup=vimLetHereDocStop end='^\s*\z1\s*$'	contains=vimComment,vim9Comment
                            
                            " Abbreviations: {{{2
                            " =============
    1              0.000097 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd: {{{2
                            " =======
    1              0.000075 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000025 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000023 syn match	vimAutoCmdSfxList	contained	"\S*"	skipwhite nextgroup=vimAutoCmdMod
    1              0.000021 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
    1              0.000011 syn match	vimAutoCmdMod	"\(++\)\=\(once\|nested\)"
                            
                            " Echo and Execute: -- prefer strings! {{{2
                            " ================
    1              0.000047 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000071 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000054 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000005 syn case ignore
    1              0.000006 syn keyword	vimEchoHLNone	none
    1              0.000003 syn case match
                            
                            " Maps: {{{2
                            " ====
    1              0.000020 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000087 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000035 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000013 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000045 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000032 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000044 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000027 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000078 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000043 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000022 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000003 syn case ignore
    1              0.000017 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000002 syn case match
                            
                            " Menus: {{{2
                            " =====
    1              0.000075 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000065 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000059 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000014 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000028 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000023 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000029 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000027 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vim9Comment,vimIsCommand
    1              0.000010 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation: (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000004 syn case ignore
    1              0.000121 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cmd\|cr\|lf\|linefeed\|return\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|mouse\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000035 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000026 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    1              0.000020 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    1              0.000033 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000023 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000010 syn match	vimBracket contained	"[\\<>]"
    1              0.000002 syn case match
                            
                            " User Function Highlighting: {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000071 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    1              0.000060 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
                            
                            " User Command Highlighting: {{{2
                            "syn match vimUsrCmd	'^\s*\zs\u\w*.*$'
    1              0.000040 syn match vimUsrCmd	'^\s*\zs\u\%(\w*\)\@>\%([(#[]\|\s\+\%([-+*/%]\=\|\.\.\)=\)\@!'
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000029 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000036  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
    1              0.000032  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000029  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000036  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000005 endif
                            
    1              0.000040 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Norm: {{{2
                            " ====
    1              0.000032 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000011 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax: {{{2
                            "=======
    1              0.000048 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000080 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000011 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000024 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000029  syn match	vimSynError	contained	"\i\+"
    1              0.000012  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000003 endif
    1              0.000035 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000028 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000027 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000048 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000043 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000030 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000278 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000016 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000010  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000002 endif
    1              0.000006 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000008 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000029 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000091 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000013 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000010 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000018 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000023 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000027 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000009 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000007 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000014 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000029 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000023 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000036 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000028 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000012 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000071 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation,vim9Comment
    1              0.000077 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000032 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000034 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000014 if has("conceal")
    1              0.000034  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000009  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000003 endif
    1              0.000032 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000012 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000061 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000057 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000023 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000030 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000039 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000016 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000046 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000060 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000025 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000022 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000010 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000010 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000020 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000008 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000011 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000015 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000121 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000018 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000010  syn match	vimSyncError	contained	"\i\+"
    1              0.000003 endif
    1              0.000009 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000025 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000007 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000019 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000007 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000017 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000026 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000031 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000028 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000005 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand: here by reasons of precedence {{{2
                            " ====================
    1              0.000026 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting: {{{2
                            " ============
    1              0.000069 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment,vim9Comment
    1              0.000015 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000027  syn match	vimHiCtermError	contained	"\D\i*"
    1              0.000003 endif
    1              0.000038 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000012 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000025 syn match	vimHiGroup	contained	"\i\+"
    1              0.000004 syn case ignore
    1              0.000038 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    1              0.000087 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000004 syn case match
    1              0.000030 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000014 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000005 syn case ignore
    1              0.000291 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey grey40 grey50 grey90 lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred lightyellow magenta red seagreen white yellow
    1              0.000015 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000002 syn case match
    1              0.000032 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000031 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000027 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000182 syn cluster	vimHiCluster contains=vimGroup,vimHiBlend,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiCtermul,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000030 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000015 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000010  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000003 endif
    1              0.000012 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000039 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000012 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000037 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000027 syn match	vimHiCtermul	contained	"\cctermul="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000010 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000009 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000019 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000014 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000010 syn match	vimHiBlend	contained	"\cblend="he=e-1		nextgroup=vimHiNmbr
    1              0.000007 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000009 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    1              0.000048 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=@vimHiCluster
    1              0.000016 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters: {{{2
                            " ==================
    1              0.000013 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000047 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000040 syn match	vim9LineComment	+^[ \t:]\+#.*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000062 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000013 syn match	vimContinue	"^\s*\\"
    1              0.000042 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000010 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000037 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000013 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000057 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000047 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Embedded Scripts:  {{{2
                            " ================
                            "   perl,ruby     : Benoit Cerrina
                            "   python,tcl    : Johannes Zellner
                            "   mzscheme, lua : Charles Campbell
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000011 if !exists("g:vimsyn_embed")
    1              0.000017  let g:vimsyn_embed = 'l'
    1              0.000003 endif
                            
                            " [-- lua --] {{{3
    1              0.000055 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000030 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000031 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
    1              0.000008  unlet! b:current_syntax
    1              0.000040  syn cluster vimFuncBodyList	add=vimLuaRegion
    1   0.004013   0.000154  exe "syn include @vimLuaScript ".s:luapath
    1              0.000092  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
    1              0.000037  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+	contains=@vimLuaScript
    1              0.000016  syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
                             syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000006 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000043 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000029 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000015 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
    1              0.000002 else
    1              0.000049  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000016  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000005 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000031 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000021 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000012 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
                             syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
    1              0.000002 else
    1              0.000017  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000174  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    1              0.000003 endif
    1              0.000005 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000030 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000021 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    1              0.000002 endif
    1              0.000012 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*$+ end=+\.$+				contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+				contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
    1              0.000002 else
    1              0.000022  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000016  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000004 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000032 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
    1              0.000002 else
    1              0.000006  let s:trytcl= 1
    1              0.000002 endif
    1              0.000003 if s:trytcl
    1              0.000025  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000020  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    1              0.000002  endif
    1              0.000010  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    1              0.000002  else
    1              0.000019   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000013   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000002  endif
    1              0.000003  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000003 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000026 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000020 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000010 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    1              0.000002 else
    1              0.000019  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000013  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000002 endif
    1              0.000004 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000008 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    1              0.000002 endif
    1              0.000019 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000010 syn sync linecont	"^\s\+\\"
    1              0.000048 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000010 if !exists("skip_vim_syntax_inits")
    1              0.000006  if !exists("g:vimsyn_noerror")
    1              0.000032   hi def link vimBehaveError	vimError
    1              0.000008   hi def link vimCollClassErr	vimError
    1              0.000007   hi def link vimErrSetting	vimError
    1              0.000019   hi def link vimEmbedError	Normal
    1              0.000008   hi def link vimFTError	vimError
    1              0.000007   hi def link vimFunctionError	vimError
    1              0.000006   hi def link vimFunc         	vimError
    1              0.000004   hi def link vimHiAttribList	vimError
    1              0.000004   hi def link vimHiCtermError	vimError
    1              0.000003   hi def link vimHiKeyError	vimError
    1              0.000019   hi def link vimKeyCodeError	vimError
    1              0.000006   hi def link vimMapModErr	vimError
    1              0.000005   hi def link vimSubstFlagErr	vimError
    1              0.000004   hi def link vimSynCaseError	vimError
    1              0.000021   hi def link vimBufnrWarn	vimWarn
    1              0.000002  endif
                            
    1              0.000011  hi def link vimAbb	vimCommand
    1              0.000010  hi def link vimAddress	vimMark
    1              0.000006  hi def link vimAugroupError	vimError
    1              0.000010  hi def link vimAugroupKey	vimCommand
    1              0.000023  hi def link vimAuHighlight	vimHighlight
    1              0.000024  hi def link vimAutoCmdOpt	vimOption
    1              0.000011  hi def link vimAutoCmd	vimCommand
    1              0.000018  hi def link vimAutoEvent	Type
    1              0.000017  hi def link vimAutoCmdMod	Special
    1              0.000024  hi def link vimAutoSet	vimCommand
    1              0.000010  hi def link vimBehaveModel	vimBehave
    1              0.000010  hi def link vimBehave	vimCommand
    1              0.000018  hi def link vimBracket	Delimiter
    1              0.000020  hi def link vimCmplxRepeat	SpecialChar
    1              0.000019  hi def link vimCommand	Statement
    1              0.000019  hi def link vimComment	Comment
    1              0.000019  hi def link vim9Comment	Comment
    1              0.000009  hi def link vimCommentString	vimString
    1              0.000015  hi def link vimCommentTitle	PreProc
    1              0.000024  hi def link vimCondHL	vimCommand
    1              0.000018  hi def link vimContinue	Special
    1              0.000020  hi def link vimCtrlChar	SpecialChar
    1              0.000010  hi def link vimEchoHLNone	vimGroup
    1              0.000010  hi def link vimEchoHL	vimCommand
    1              0.000017  hi def link vimElseIfErr	Error
    1              0.000019  hi def link vimElseif	vimCondHL
    1              0.000019  hi def link vimEnvvar	PreProc
    1              0.000017  hi def link vimError	Error
    1              0.000011  hi def link vimFBVar	vimVar
    1              0.000005  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000005  hi def link vimHiCtermul	vimHiTerm
    1              0.000033  hi def link vimFold	Folded
    1              0.000012  hi def link vimFTCmd	vimCommand
    1              0.000008  hi def link vimFTOption	vimSynType
    1              0.000009  hi def link vimFuncKey	vimCommand
    1              0.000017  hi def link vimFuncName	Function
    1              0.000018  hi def link vimFuncSID	Special
    1              0.000020  hi def link vimFuncVar	Identifier
    1              0.000021  hi def link vimGroupAdd	vimSynOption
    1              0.000010  hi def link vimGroupName	vimGroup
    1              0.000005  hi def link vimGroupRem	vimSynOption
    1              0.000016  hi def link vimGroupSpecial	Special
    1              0.000021  hi def link vimGroup	Type
    1              0.000016  hi def link vimHiAttrib	PreProc
    1              0.000005  hi def link vimHiBlend	vimHiTerm
    1              0.000007  hi def link vimHiClear	vimHighlight
    1              0.000005  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000004  hi def link vimHiCTerm	vimHiTerm
    1              0.000009  hi def link vimHighlight	vimCommand
    1              0.000005  hi def link vimHiGroup	vimGroupName
    1              0.000004  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000004  hi def link vimHiGuiFont	vimHiTerm
    1              0.000008  hi def link vimHiGuiRgb	vimNumber
    1              0.000004  hi def link vimHiGui	vimHiTerm
    1              0.000027  hi def link vimHiNmbr	Number
    1              0.000005  hi def link vimHiStartStop	vimHiTerm
    1              0.000017  hi def link vimHiTerm	Type
    1              0.000012  hi def link vimHLGroup	vimGroup
    1              0.000031  hi def link vimHLMod	PreProc
    1              0.000011  hi def link vimInsert	vimString
    1              0.000018  hi def link vimIskSep	Delimiter
    1              0.000024  hi def link vimKeyCode	vimSpecFile
    1              0.000031  hi def link vimKeyword	Statement
    1              0.000012  hi def link vimLet	vimCommand
    1              0.000009  hi def link vimLetHereDoc	vimString
    1              0.000017  hi def link vimLetHereDocStart	Special
    1              0.000017  hi def link vimLetHereDocStop	Special
    1              0.000011  hi def link vimLineComment	vimComment
    1              0.000008  hi def link vim9LineComment	vimComment
    1              0.000009  hi def link vimMapBang	vimCommand
    1              0.000008  hi def link vimMapModKey	vimFuncSID
    1              0.000007  hi def link vimMapMod	vimBracket
    1              0.000010  hi def link vimMap	vimCommand
    1              0.000019  hi def link vimMark	Number
    1              0.000010  hi def link vimMarkNumber	vimNumber
    1              0.000007  hi def link vimMenuMod	vimMapMod
    1              0.000006  hi def link vimMenuNameMore	vimMenuName
    1              0.000016  hi def link vimMenuName	PreProc
    1              0.000009  hi def link vimMtchComment	vimComment
    1              0.000009  hi def link vimNorm	vimCommand
    1              0.000017  hi def link vimNotation	Special
    1              0.000011  hi def link vimNotFunc	vimCommand
    1              0.000009  hi def link vimNotPatSep	vimString
    1              0.000019  hi def link vimNumber	Number
    1              0.000019  hi def link vimOperError	Error
    1              0.000021  hi def link vimOper	Operator
    1              0.000010  hi def link vimOperStar	vimOper
    1              0.000017  hi def link vimOption	PreProc
    1              0.000020  hi def link vimParenSep	Delimiter
    1              0.000007  hi def link vimPatSepErr	vimError
    1              0.000007  hi def link vimPatSepR	vimPatSep
    1              0.000018  hi def link vimPatSep	SpecialChar
    1              0.000009  hi def link vimPatSepZone	vimString
    1              0.000038  hi def link vimPatSepZ	vimPatSep
    1              0.000022  hi def link vimPattern	Type
    1              0.000010  hi def link vimPlainMark	vimMark
    1              0.000008  hi def link vimPlainRegister	vimRegister
    1              0.000019  hi def link vimRegister	SpecialChar
    1              0.000016  hi def link vimScriptDelim	Comment
    1              0.000016  hi def link vimSearchDelim	Statement
    1              0.000010  hi def link vimSearch	vimString
    1              0.000019  hi def link vimSep	Delimiter
    1              0.000009  hi def link vimSetMod	vimOption
    1              0.000016  hi def link vimSetSep	Statement
    1              0.000010  hi def link vimSetString	vimString
    1              0.000019  hi def link vimSpecFile	Identifier
    1              0.000010  hi def link vimSpecFileMod	vimSpecFile
    1              0.000033  hi def link vimSpecial	Type
    1              0.000031  hi def link vimStatement	Statement
    1              0.000010  hi def link vimStringCont	vimString
    1              0.000019  hi def link vimString	String
    1              0.000009  hi def link vimStringEnd	vimString
    1              0.000009  hi def link vimSubst1	vimSubst
    1              0.000019  hi def link vimSubstDelim	Delimiter
    1              0.000017  hi def link vimSubstFlags	Special
    1              0.000019  hi def link vimSubstSubstr	SpecialChar
    1              0.000009  hi def link vimSubstTwoBS	vimString
    1              0.000011  hi def link vimSubst	vimCommand
    1              0.000017  hi def link vimSynCaseError	Error
    1              0.000018  hi def link vimSynCase	Type
    1              0.000018  hi def link vimSyncC	Type
    1              0.000027  hi def link vimSyncError	Error
    1              0.000007  hi def link vimSyncGroupName	vimGroupName
    1              0.000005  hi def link vimSyncGroup	vimGroupName
    1              0.000017  hi def link vimSyncKey	Type
    1              0.000018  hi def link vimSyncNone	Type
    1              0.000006  hi def link vimSynContains	vimSynOption
    1              0.000017  hi def link vimSynError	Error
    1              0.000009  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000004  hi def link vimSynKeyOpt	vimSynOption
    1              0.000004  hi def link vimSynMtchGrp	vimSynOption
    1              0.000004  hi def link vimSynMtchOpt	vimSynOption
    1              0.000005  hi def link vimSynNextgroup	vimSynOption
    1              0.000005  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000015  hi def link vimSynOption	Special
    1              0.000009  hi def link vimSynPatRange	vimString
    1              0.000004  hi def link vimSynRegOpt	vimSynOption
    1              0.000007  hi def link vimSynRegPat	vimString
    1              0.000017  hi def link vimSynReg	Type
    1              0.000012  hi def link vimSyntax	vimCommand
    1              0.000005  hi def link vimSynType	vimSpecial
    1              0.000018  hi def link vimTodo	Todo
    1              0.000010  hi def link vimUnmap	vimMap
    1              0.000017  hi def link vimUserAttrbCmpltFunc	Special
    1              0.000007  hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000008  hi def link vimUserAttrbKey	vimOption
    1              0.000006  hi def link vimUserAttrb	vimSpecial
    1              0.000018  hi def link vimUserAttrbError	Error
    1              0.000019  hi def link vimUserCmdError	Error
    1              0.000011  hi def link vimUserCommand	vimCommand
    1              0.000019  hi def link vimUserFunc	Normal
    1              0.000021  hi def link vimVar	Identifier
    1              0.000019  hi def link vimWarn	WarningMsg
                            
    1              0.000008  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000011  hi def link nvimHLGroup	vimHLGroup
    1              0.000008  hi def link nvimMap	vimMap
    1              0.000008  hi def link nvimUnmap	vimUnmap
    1              0.000002 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000009 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000015 delc VimFolda
    1              0.000009 delc VimFoldf
    1              0.000008 delc VimFoldl
    1              0.000008 delc VimFoldm
    1              0.000007 delc VimFoldp
    1              0.000006 delc VimFoldP
    1              0.000008 delc VimFoldr
    1              0.000007 delc VimFoldt
    1              0.000026 let &cpo = s:keepcpo
    1              0.000005 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.003803
 Self time:   0.003803

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Lua 4.0, Lua 5.0, Lua 5.1 and Lua 5.2
                            " Maintainer:	Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author:	Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:	2012 Aug 12
                            " Options:	lua_version = 4 or 5
                            "		lua_subversion = 0 (4.0, 5.0) or 1 (5.1) or 2 (5.2)
                            "		default 5.2
                            
                            " quit when a syntax file was already loaded
    1              0.000013 if exists("b:current_syntax")
                              finish
    1              0.000002 endif
                            
    1              0.000022 let s:cpo_save = &cpo
    1              0.000029 set cpo&vim
                            
    1              0.000007 if !exists("lua_version")
                              " Default is lua 5.2
    1              0.000010   let lua_version = 5
    1              0.000007   let lua_subversion = 2
                            elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. So, set it to 0
                              let lua_subversion = 0
    1              0.000002 endif
                            
    1              0.000003 syn case match
                            
                            " syncing method
    1              0.000008 syn sync minlines=100
                            
                            " Comments
    1              0.000045 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000066 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000010 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaComment start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000011 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000050   syn region luaComment        matchgroup=luaComment start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000002 endif
                            
                            " First line may start with #!
    1              0.000010 syn match luaComment "\%^#!.*"
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
    1              0.000206 syn region luaParen      transparent                     start='(' end=')' contains=ALLBUT,luaParenError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
    1              0.000088 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=ALLBUT,luaBraceError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
                            
    1              0.000009 syn match  luaParenError ")"
    1              0.000007 syn match  luaBraceError "}"
    1              0.000044 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " function ... end
    1              0.000180 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " if ... then
    1              0.000054 syn region luaIfThen transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4           contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaIn nextgroup=luaThenEnd skipwhite skipempty
                            
                            " then ... end
    1              0.000028 syn region luaThenEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaThenEnd,luaIn
                            
                            " elseif ... then
    1              0.000028 syn region luaElseifThen contained transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " else
    1              0.000007 syn keyword luaElse contained else
                            
                            " do ... end
    1              0.000029 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>"          contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " repeat ... until
    1              0.000051 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>"   contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " while ... do
    1              0.000037 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaIn nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000031 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2   contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000006 syn keyword luaIn contained in
                            
                            " other keywords
    1              0.000009 syn keyword luaStatement return local break
    1              0.000011 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000007   syn keyword luaStatement goto
    1              0.000036   syn match luaLabel "::\I\i*::"
    1              0.000003 endif
    1              0.000036 syn keyword luaOperator and or not
    1              0.000027 syn keyword luaConstant nil
    1              0.000015 if lua_version > 4
    1              0.000009   syn keyword luaConstant true false
    1              0.000002 endif
                            
                            " Strings
    1              0.000004 if lua_version < 5
                              syn match  luaSpecial contained "\\[\\abfnrtv\'\"]\|\\[[:digit:]]\{,3}"
    1              0.000005 elseif lua_version == 5
    1              0.000004   if lua_subversion == 0
                                syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
                                syn region luaString2 matchgroup=luaString start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000003   else
    1              0.000005     if lua_subversion == 1
                                  syn match  luaSpecial contained #\\[\\abfnrtv'"]\|\\[[:digit:]]\{,3}#
    1              0.000003     else " Lua 5.2
    1              0.000023       syn match  luaSpecial contained #\\[\\abfnrtvz'"]\|\\x[[:xdigit:]]\{2}\|\\[[:digit:]]\{,3}#
    1              0.000002     endif
    1              0.000047     syn region luaString2 matchgroup=luaString start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000002   endif
    1              0.000002 endif
    1              0.000031 syn region luaString  start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000028 syn region luaString  start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000035 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000019 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, starting with a dot, optional exponent
    1              0.000012 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000012 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000005 if lua_version >= 5
    1              0.000004   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000004   elseif lua_subversion >= 2
    1              0.000017     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000002   endif
    1              0.000002 endif
                            
    1              0.000040 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000014 syn keyword luaFunc print rawget rawset tonumber tostring type _VERSION
                            
    1              0.000004 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000004 elseif lua_version == 5
    1              0.000009   syn keyword luaFunc getmetatable setmetatable
    1              0.000007   syn keyword luaFunc ipairs pairs
    1              0.000006   syn keyword luaFunc pcall xpcall
    1              0.000008   syn keyword luaFunc _G loadfile rawequal require
    1              0.000004   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000002   else
    1              0.000006     syn keyword luaFunc load select
    1              0.000017     syn match   luaFunc /\<package\.cpath\>/
    1              0.000011     syn match   luaFunc /\<package\.loaded\>/
    1              0.000010     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000009     syn match   luaFunc /\<package\.path\>/
    1              0.000004     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.preload\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000004     elseif lua_subversion == 2
    1              0.000006       syn keyword luaFunc _ENV rawlen
    1              0.000009       syn match   luaFunc /\<package\.config\>/
    1              0.000009       syn match   luaFunc /\<package\.preload\>/
    1              0.000010       syn match   luaFunc /\<package\.searchers\>/
    1              0.000010       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000010       syn match   luaFunc /\<bit32\.arshift\>/
    1              0.000009       syn match   luaFunc /\<bit32\.band\>/
    1              0.000008       syn match   luaFunc /\<bit32\.bnot\>/
    1              0.000008       syn match   luaFunc /\<bit32\.bor\>/
    1              0.000009       syn match   luaFunc /\<bit32\.btest\>/
    1              0.000008       syn match   luaFunc /\<bit32\.bxor\>/
    1              0.000016       syn match   luaFunc /\<bit32\.extract\>/
    1              0.000008       syn match   luaFunc /\<bit32\.lrotate\>/
    1              0.000008       syn match   luaFunc /\<bit32\.lshift\>/
    1              0.000008       syn match   luaFunc /\<bit32\.replace\>/
    1              0.000008       syn match   luaFunc /\<bit32\.rrotate\>/
    1              0.000008       syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000002     endif
    1              0.000011     syn match luaFunc /\<coroutine\.running\>/
    1              0.000002   endif
    1              0.000010   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000014   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000009   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000010   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000009   syn match   luaFunc /\<coroutine\.yield\>/
    1              0.000009   syn match   luaFunc /\<string\.byte\>/
    1              0.000008   syn match   luaFunc /\<string\.char\>/
    1              0.000008   syn match   luaFunc /\<string\.dump\>/
    1              0.000009   syn match   luaFunc /\<string\.find\>/
    1              0.000009   syn match   luaFunc /\<string\.format\>/
    1              0.000008   syn match   luaFunc /\<string\.gsub\>/
    1              0.000008   syn match   luaFunc /\<string\.len\>/
    1              0.000008   syn match   luaFunc /\<string\.lower\>/
    1              0.000029   syn match   luaFunc /\<string\.rep\>/
    1              0.000009   syn match   luaFunc /\<string\.sub\>/
    1              0.000009   syn match   luaFunc /\<string\.upper\>/
    1              0.000004   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000002   else
    1              0.000009     syn match luaFunc /\<string\.gmatch\>/
    1              0.000009     syn match luaFunc /\<string\.match\>/
    1              0.000009     syn match luaFunc /\<string\.reverse\>/
    1              0.000002   endif
    1              0.000003   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000004   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000003   elseif lua_subversion == 2
    1              0.000008     syn match luaFunc /\<table\.pack\>/
    1              0.000009     syn match luaFunc /\<table\.unpack\>/
    1              0.000002   endif
    1              0.000009   syn match   luaFunc /\<table\.concat\>/
    1              0.000008   syn match   luaFunc /\<table\.sort\>/
    1              0.000008   syn match   luaFunc /\<table\.insert\>/
    1              0.000008   syn match   luaFunc /\<table\.remove\>/
    1              0.000008   syn match   luaFunc /\<math\.abs\>/
    1              0.000008   syn match   luaFunc /\<math\.acos\>/
    1              0.000008   syn match   luaFunc /\<math\.asin\>/
    1              0.000008   syn match   luaFunc /\<math\.atan\>/
    1              0.000008   syn match   luaFunc /\<math\.atan2\>/
    1              0.000008   syn match   luaFunc /\<math\.ceil\>/
    1              0.000008   syn match   luaFunc /\<math\.sin\>/
    1              0.000008   syn match   luaFunc /\<math\.cos\>/
    1              0.000008   syn match   luaFunc /\<math\.tan\>/
    1              0.000008   syn match   luaFunc /\<math\.deg\>/
    1              0.000008   syn match   luaFunc /\<math\.exp\>/
    1              0.000008   syn match   luaFunc /\<math\.floor\>/
    1              0.000008   syn match   luaFunc /\<math\.log\>/
    1              0.000007   syn match   luaFunc /\<math\.max\>/
    1              0.000008   syn match   luaFunc /\<math\.min\>/
    1              0.000003   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000002   else
    1              0.000003     if lua_subversion == 1
                                  syn match luaFunc /\<math\.log10\>/
    1              0.000002     endif
    1              0.000008     syn match luaFunc /\<math\.huge\>/
    1              0.000008     syn match luaFunc /\<math\.fmod\>/
    1              0.000009     syn match luaFunc /\<math\.modf\>/
    1              0.000008     syn match luaFunc /\<math\.cosh\>/
    1              0.000008     syn match luaFunc /\<math\.sinh\>/
    1              0.000008     syn match luaFunc /\<math\.tanh\>/
    1              0.000002   endif
    1              0.000008   syn match   luaFunc /\<math\.pow\>/
    1              0.000008   syn match   luaFunc /\<math\.rad\>/
    1              0.000008   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000016   syn match   luaFunc /\<math\.frexp\>/
    1              0.000008   syn match   luaFunc /\<math\.ldexp\>/
    1              0.000008   syn match   luaFunc /\<math\.random\>/
    1              0.000009   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000008   syn match   luaFunc /\<math\.pi\>/
    1              0.000008   syn match   luaFunc /\<io\.close\>/
    1              0.000009   syn match   luaFunc /\<io\.flush\>/
    1              0.000008   syn match   luaFunc /\<io\.input\>/
    1              0.000008   syn match   luaFunc /\<io\.lines\>/
    1              0.000008   syn match   luaFunc /\<io\.open\>/
    1              0.000008   syn match   luaFunc /\<io\.output\>/
    1              0.000008   syn match   luaFunc /\<io\.popen\>/
    1              0.000008   syn match   luaFunc /\<io\.read\>/
    1              0.000008   syn match   luaFunc /\<io\.stderr\>/
    1              0.000007   syn match   luaFunc /\<io\.stdin\>/
    1              0.000007   syn match   luaFunc /\<io\.stdout\>/
    1              0.000008   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000007   syn match   luaFunc /\<io\.type\>/
    1              0.000007   syn match   luaFunc /\<io\.write\>/
    1              0.000007   syn match   luaFunc /\<os\.clock\>/
    1              0.000013   syn match   luaFunc /\<os\.date\>/
    1              0.000013   syn match   luaFunc /\<os\.difftime\>/
    1              0.000008   syn match   luaFunc /\<os\.execute\>/
    1              0.000007   syn match   luaFunc /\<os\.exit\>/
    1              0.000007   syn match   luaFunc /\<os\.getenv\>/
    1              0.000007   syn match   luaFunc /\<os\.remove\>/
    1              0.000007   syn match   luaFunc /\<os\.rename\>/
    1              0.000008   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000008   syn match   luaFunc /\<os\.time\>/
    1              0.000012   syn match   luaFunc /\<os\.tmpname\>/
    1              0.000008   syn match   luaFunc /\<debug\.debug\>/
    1              0.000014   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000008   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000010   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000010   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000009   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000010   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000009   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000010   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000004   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
                                syn match luaFunc /\<debug\.getmetatable\>/
                                syn match luaFunc /\<debug\.setmetatable\>/
                                syn match luaFunc /\<debug\.getregistry\>/
    1              0.000004   elseif lua_subversion == 2
    1              0.000009     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000009     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000009     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000009     syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000009     syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000009     syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000010     syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000002   endif
    1              0.000002 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000028 hi def link luaStatement		Statement
    1              0.000019 hi def link luaRepeat		Repeat
    1              0.000034 hi def link luaFor			Repeat
    1              0.000017 hi def link luaString		String
    1              0.000017 hi def link luaString2		String
    1              0.000034 hi def link luaNumber		Number
    1              0.000021 hi def link luaOperator		Operator
    1              0.000018 hi def link luaIn			Operator
    1              0.000015 hi def link luaConstant		Constant
    1              0.000016 hi def link luaCond		Conditional
    1              0.000014 hi def link luaElse		Conditional
    1              0.000015 hi def link luaFunction		Function
    1              0.000014 hi def link luaComment		Comment
    1              0.000014 hi def link luaTodo		Todo
    1              0.000014 hi def link luaTable		Structure
    1              0.000015 hi def link luaError		Error
    1              0.000016 hi def link luaParenError		Error
    1              0.000016 hi def link luaBraceError		Error
    1              0.000017 hi def link luaSpecial		SpecialChar
    1              0.000017 hi def link luaFunc		Identifier
    1              0.000014 hi def link luaLabel		Label
                            
                            
    1              0.000010 let b:current_syntax = "lua"
                            
    1              0.000030 let &cpo = s:cpo_save
    1              0.000007 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /usr/share/nvim/runtime/syntax/vim/generated.vim
Sourced 3 times
Total time:   0.011459
 Self time:   0.011459

count  total (s)   self (s)
    3              0.005111 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bal[t] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cal[l] cat[ch] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev]
    3              0.000432 syn keyword vimCommand contained  cnorem[enu] co[py] col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cons[t] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ev[al] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags]
    3              0.000422 syn keyword vimCommand contained  ha[rdcopy] hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd]
    3              0.000437 syn keyword vimCommand contained  lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] perlf[ile] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead]
    3              0.000408 syn keyword vimCommand contained  rec[over] red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellra[re] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu]
    3              0.000429 syn keyword vimCommand contained  sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[enu] tma[p] tmapc[lear] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmenu] tunma[p] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo] wv[iminfo]
    3              0.000073 syn keyword vimCommand contained  x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    3              0.000196 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl
    3              0.000505 syn keyword vimOption contained  buftype bt casemap cmp cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot completeslash csl confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    3              0.000225 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
    3              0.000216 syn keyword vimOption contained  foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc
    3              0.000189 syn keyword vimOption contained  imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs jumpoptions jop keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl
    3              0.000182 syn keyword vimOption contained  magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelineexpr mle invmodelineexpr nomodelineexpr invmle nomle modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt
    3              0.000180 syn keyword vimOption contained  patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumblend pb pumheight ph pumwidth pw pyxversion pyx quickfixtextfunc qftf quoteescape qe readonly ro invreadonly noreadonly invro noro redrawdebug rdb redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk
    3              0.000193 syn keyword vimOption contained  scrollbind scb invscrollbind noscrollbind invscb noscb scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs
    3              0.000194 syn keyword vimOption contained  smartindent si invsmartindent nosmartindent invsi nosi smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps spelloptions spo splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tagfunc tfu tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi
    3              0.000185 syn keyword vimOption contained  termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc termpastefilter tpf terse invterse noterse textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut varsofttabstop vsts vartabstop vts verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi viminfofile vif virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu
    3              0.000106 syn keyword vimOption contained  wildmode wim wildoptions wop winaltkeys wak winblend winbl winhighlight winhl window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    3              0.000008 syn case ignore
                            
    3              0.000246 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdUndefined CmdWinEnter CmdWinLeave CmdlineChanged CmdlineEnter CmdlineLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre
    3              0.000117 syn keyword vimAutoEvent contained  MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermEnter TermLeave TermResponse TextChanged TextChangedI TextChangedP TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinEnter WinLeave WinNew BufWrite FileEncoding BufCreate BufRead
                            
    3              0.000043 syn keyword nvimAutoEvent contained  BufModifiedSet Signal WinScrolled UIEnter TabNewEntered TermClose UILeave WinClosed DirChanged TabClosed TabNew TermOpen
                            
    3              0.000005 syn case match
                            
    3              0.000153 syn keyword vimFuncName contained  ceil lispindent nvim_buf_line_count nvim_put sign_getplaced rubyeval jobsend settabwinvar tagfiles append getwinposx msgpackparse nvim_buf_get_commands pathshorten nvim_set_current_tabpage inputrestore nvim_buf_get_changedtick expandcmd log resolve inputsave nvim__id nvim_win_set_cursor range sqrt winheight dictwatcheradd screenrow getcmdline getbufinfo histnr nvim_get_proc_children float2nr nvim_echo nvim_get_chan_info dictwatcherdel settagstack win_findbuf nvim__id_float rpcstop hasmapto rpcnotify atan2 screenpos timer_stopall screenchar setcharsearch nvim__get_lib_dir nvim_win_get_width nvim_win_set_var jobpid nvim_get_current_tabpage asin sort winbufnr windowsversion getjumplist msgpackdump assert_nobeep foreground setfperm nvim_open_win str2nr strridx invert reg_recording getcompletion extend serverstop
    3              0.000166 syn keyword vimFuncName contained  min nextnonblank appendbufline call nvim_set_current_dir tabpagenr bufloaded stdpath setloclist atan nvim_win_get_height nvim_list_tabpages line2byte assert_inrange setqflist searchpair isinf getloclist buffer_exists virtcol len nvim_input serverlist getwininfo cosh nvim_buf_is_valid nvim_set_option nvim_get_namespaces exp json_encode nvim_replace_termcodes str2float spellbadword nvim_buf_del_var getcharsearch sign_place escape readfile str2list sign_jump nvim_set_keymap iconv strtrans nvim_buf_get_extmarks setbufline gettabinfo matchstrpos haslocaldir strdisplaywidth join nvim_del_keymap getqflist filewritable nvim_input_mouse assert_equalfile nvim_buf_is_loaded tr eval localtime repeat getwinpos filereadable insert nvim_buf_get_name pow foldlevel hostname getchar getmatches type count byteidxcomp last_buffer_nr
    3              0.000168 syn keyword vimFuncName contained  tabpagebuflist log10 has getenv flatten nvim_notify foldclosed json_decode ctxget exepath reltime trunc matchlist assert_true getfsize sha256 nvim_buf_set_virtual_text byteidx wordcount setmatches libcall remove bufname wait assert_false win_execute hlexists tolower mapcheck getcwd nvim_win_get_cursor search items spellsuggest did_filetype nvim_get_color_map undotree exists eventhandler prevnonblank tempname chansend keys perleval matchend ctxpush isdirectory file_readable nvim_buf_set_option nvim_out_write highlightID timer_info bufadd deletebufline nvim_get_proc debugbreak luaeval argidx add max nvim_get_runtime_file systemlist deepcopy nvim_win_get_position win_getid sinh interrupt nvim_tabpage_get_win inputdialog shellescape tabpagewinnr jobclose map test_garbagecollect_now inputlist has_key sign_define
    3              0.000154 syn keyword vimFuncName contained  test_write_list_log libcallnr nvim_open_term setbufvar swapinfo ctxsize acos getbufvar setwinvar pyeval nvim_win_set_config expand setline pum_getpos delete round nvim_paste nvim_get_color_by_name globpath funcref nvim_list_uis nvim_buf_del_extmark substitute synconcealed nvim_feedkeys indent reverse nvim_buf_get_keymap serverstart nvim_tabpage_get_number nvim_get_hl_by_name garbagecollect diff_filler nvim_tabpage_get_var char2nr maparg nvim_win_set_buf bufload foldclosedend pumvisible nvim_get_hl_by_id nvim_win_hide getftime rename fmod nvim_strwidth nvim__id_array pyxeval tanh nvim_win_get_option nvim__get_hl_defs changenr setreg assert_report nvim_set_current_win sign_getdefined nvim__buf_stats timer_start nvim_list_runtime_paths sign_placelist nvim_call_dict_function glob2regpat nvim_set_current_line sockconnect
    3              0.000160 syn keyword vimFuncName contained  nvim_set_var winwidth nvim_win_close getcmdtype prompt_setprompt foldtext nvim_buf_add_highlight arglistid nvim__screenshot nvim_command_output getregtype nvim__inspect_cell glob timer_stop inputsecret ctxset getcmdpos getmarklist hlID getwinvar matcharg tan clearmatches nvim_err_write assert_equal buffer_number nvim__stats searchcount copy strchars winlayout winnr strptime nvim_buf_set_lines getwinposy strpart getchangelist setcmdpos nvim_win_del_var win_screenpos nvim_create_namespace sign_unplace gettabwinvar values strcharpart nr2char nvim_buf_get_offset execute stdioopen or prompt_setinterrupt nvim_get_current_buf nvim_get_vvar bufwinnr nvim_buf_get_option undofile synIDattr nvim_parse_expression reltimestr termopen strgetchar matchdelete synID py3eval nvim_get_current_line nvim_tabpage_del_var assert_exception
    3              0.000157 syn keyword vimFuncName contained  winline nvim_buf_get_extmark_by_id winsaveview nvim_buf_clear_highlight searchpairpos winrestview system swapname floor nvim_buf_set_extmark simplify nvim_win_get_buf rpcrequest nvim_win_is_valid getcharmod nvim_tabpage_set_var nvim_get_current_win printf rpcstart nvim_buf_set_name nvim_buf_set_var sin foldtextresult environ argv menu_get sign_undefine split nvim_tabpage_is_valid strftime synIDtrans matchadd complete cos getline nvim_call_function cindent uniq isnan submatch taglist empty assert_notmatch nvim_buf_set_text synstack fnamemodify col getbufline nvim_list_chans nvim_set_hl nvim_win_set_width diff_hlID charidx nvim_list_wins nvim_buf_clear_namespace cursor nvim__id_dictionary prompt_setcallback get mode argc and complete_check nvim_err_writeln string win_id2tabwin jobstop readdir jobstart toupper
    3              0.000161 syn keyword vimFuncName contained  reltimefloat wincol nvim_get_commands win_gettype setpos fnameescape strwidth nvim_create_buf jobresize nvim_win_get_config win_gotoid buffer_name mkdir histget browsedir nvim_win_get_tabpage complete_info stridx nvim_win_set_option soundfold nvim_list_bufs input nvim_win_get_var bufexists complete_add nvim_win_set_height nvim_get_option feedkeys wildmenumode browse nvim_load_context jobwait xor nvim_eval ctxpop nvim_buf_get_mark getfperm nvim_buf_get_var nvim_set_current_buf sign_unplacelist line screencol match assert_beeps win_id2win filter nvim_get_hl_id_by_name visualmode nvim_buf_set_keymap writefile executable highlight_exists gettagstack findfile nvim_get_all_options_info nvim_get_keymap win_splitmove strlen searchdecl buflisted bufwinid nvim_del_current_line reg_executing finddir nvim_select_popupmenu_item
    3              0.000131 syn keyword vimFuncName contained  confirm matchstr nvim_buf_delete chanclose trim prompt_getprompt nvim_exec api_info function index nvim_tabpage_list_wins getreg getcurpos bufnr byte2line nvim_buf_attach nvim_get_mode searchpos nvim_set_vvar nvim_buf_get_lines nvim_buf_get_number assert_fails nvim_command id nvim__set_hl_ns nvim_buf_del_keymap cscope_connection histadd setenv nvim_get_context gettabvar assert_notequal winrestcmd nvim_del_var list2str getpos getcmdwintype getfontname nvim_get_var nvim_win_get_number assert_match abs shiftwidth screenattr islocked settabvar matchaddpos nvim_get_option_info getpid getftype timer_pause histdel

SCRIPT  /home/ahacad/.config/nvim/plugged/vim-css-color/after/syntax/vim.vim
Sourced 1 time
Total time:   0.052582
 Self time:   0.000473

count  total (s)   self (s)
    1   0.052567   0.000457 call css_color#init('hex', 'none', 'vimHiGuiRgb,vimString,vimComment,vimLineComment')

SCRIPT  /home/ahacad/.config/nvim/plugged/vim-css-color/autoload/css_color.vim
Sourced 1 time
Total time:   0.050678
 Self time:   0.015011

count  total (s)   self (s)
                            " Language:     Colorful CSS Color Preview
                            " Author:       Aristotle Pagaltzis <pagaltzis@gmx.de>
                            " Commit:       $Format:%H$
                            " Licence:      The MIT License (MIT)
                            
    1              0.000041 if ! ( v:version >= 700 && has('syntax') && ( has('gui_running') || has('nvim') || &t_Co == 256 ) )
                            	function! css_color#init(type, keywords, groups)
                            	endfunction
                            	function! css_color#extend(groups)
                            	endfunction
                            	finish
    1              0.000003 endif
                            
    1              0.000011 function! s:rgb2color(r,g,b)
                            	" Convert 80% -> 204, 100% -> 255, etc.
                            	let rgb = map( [a:r,a:g,a:b], 'v:val =~ "%$" ? ( 255 * v:val ) / 100 : v:val' )
                            	return printf( '%02x%02x%02x', rgb[0], rgb[1], rgb[2] )
                            endfunction
                            
    1              0.000005 function! s:hsl2color(h,s,l)
                            	" Convert 80% -> 0.8, 100% -> 1.0, etc.
                            	let [s,l] = map( [a:s, a:l], 'v:val =~ "%$" ? v:val / 100.0 : v:val + 0.0' )
                            	" algorithm transcoded to vim from http://www.w3.org/TR/css3-color/#hsl-color
                            	let hh = ( a:h % 360 ) / 360.0
                            	let m2 = l <= 0.5 ? l * ( s + 1 ) : l + s - l * s
                            	let m1 = l * 2 - m2
                            	let rgb = []
                            	for h in [ hh + (1/3.0), hh, hh - (1/3.0) ]
                            		let h = h < 0 ? h + 1 : h > 1 ? h - 1 : h
                            		let v =
                            			\ h * 6 < 1 ? m1 + ( m2 - m1 ) * h * 6 :
                            			\ h * 2 < 1 ? m2 :
                            			\ h * 3 < 2 ? m1 + ( m2 - m1 ) * ( 2/3.0 - h ) * 6 :
                            			\ m1
                            		if v > 1.0 | return '' | endif
                            		let rgb += [ float2nr( 255 * v ) ]
                            	endfor
                            	return printf( '%02x%02x%02x', rgb[0], rgb[1], rgb[2] )
                            endfunction
                            
    1              0.000013 let s:_1_3 = 1.0/3
    1              0.000008 let s:_16_116 = 16.0/116.0
    1              0.000080 let s:cos16 = cos(16*(180/atan2(0,-1)))
    1              0.000011 let s:sin16 = sin(16*(180/atan2(0,-1)))
                            
    1              0.000006 function s:rgb2din99(rgb)
                            	let [r,g,b] = map( copy(a:rgb), 'v:val > 0.04045 ? pow((v:val + 0.055) / 1.055, 2.4) : v:val / 12.92' )
                            
                            	let x = r * 0.4124 + g * 0.3576 + b * 0.1805
                            	let y = r * 0.2126 + g * 0.7152 + b * 0.0722
                            	let z = r * 0.0193 + g * 0.1192 + b * 0.9505
                            
                            	" Observer 2°, Illuminant D65
                            	let x = ( x * 100 ) /  95.0489
                            	let z = ( z * 100 ) / 108.8840
                            
                            	let [x,y,z] = map( [x,y,z], 'v:val > 0.008856 ? pow(v:val, s:_1_3) : 7.787 * v:val + s:_16_116' )
                            
                            	let [L,a,b] = [ (116 * y) - 16, 500 * (x - y), 200 * (y - z) ]
                            
                            	let L99 = 105.51 * log(1 + 0.0158 * L)
                            
                            	let e =        a * s:cos16 + b * s:sin16
                            	let f = 0.7 * (b * s:cos16 - a * s:sin16)
                            
                            	let g = 0.045 * sqrt(e*e + f*f)
                            	if g == 0
                            		let [a99, b99] = [0.0, 0.0]
                            	else
                            		let k = log(1 + g) / g
                            		let a99 = k * e
                            		let b99 = k * f
                            	endif
                            
                            	return [L99, a99, b99]
                            endfunction
                            
    1              0.000007 let s:hex={}
  257              0.000828 for i in range(0, 255)
  256              0.002049 	let s:hex[ printf( '%02x', i ) ] = i
  257              0.000294 endfor
                            
    1              0.000006 let s:exe=[]
    1              0.000007 function! s:flush_exe()
                            	if len(s:exe) | exe join( remove( s:exe, 0, -1 ), ' | ' ) | endif
                            endfunction
                            
    1              0.000013 if has('gui_running')
                            	function! s:create_highlight(color, is_bright)
                            		call add( s:exe, 'hi BG'.a:color.' guibg=#'.a:color.' guifg=#'.( a:is_bright ? '000000' : 'ffffff' ) )
                            	endfunction
    1              0.000002 else
                            	" preset 16 vt100 colors
    1              0.000048 	let s:xtermcolor = [
                            		\ [ 0x00, 0x00, 0x00 ],
                            		\ [ 0xCD, 0x00, 0x00 ],
                            		\ [ 0x00, 0xCD, 0x00 ],
                            		\ [ 0xCD, 0xCD, 0x00 ],
                            		\ [ 0x00, 0x00, 0xEE ],
                            		\ [ 0xCD, 0x00, 0xCD ],
                            		\ [ 0x00, 0xCD, 0xCD ],
                            		\ [ 0xE5, 0xE5, 0xE5 ],
                            		\ [ 0x7F, 0x7F, 0x7F ],
                            		\ [ 0xFF, 0x00, 0x00 ],
                            		\ [ 0x00, 0xFF, 0x00 ],
                            		\ [ 0xFF, 0xFF, 0x00 ],
                            		\ [ 0x5C, 0x5C, 0xFF ],
                            		\ [ 0xFF, 0x00, 0xFF ],
                            		\ [ 0x00, 0xFF, 0xFF ],
                            		\ [ 0xFF, 0xFF, 0xFF ]]
                            
                            	" the 6 values used in the xterm color cube
                            	"                    0    95   135   175   215   255
    1              0.000008 	let s:cubergb = [ 0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF ]
    7              0.000018 	for s:rrr in s:cubergb
   42              0.000081 		for s:ggg in s:cubergb
  252              0.000498 			for s:bbb in s:cubergb
  216              0.001215 				call add( s:xtermcolor, [ s:rrr, s:ggg, s:bbb ] )
  252              0.000271 			endfor
   42              0.000044 		endfor
    7              0.000010 	endfor
                            
                            	" grayscale ramp
    1              0.000141 	let s:xtermcolor += map( range(24), 'repeat( [10 * v:val + 8], 3 )' )
                            
  257              0.001051 	for idx in range(len(s:xtermcolor))
  256   0.042576   0.006908 		let s:xtermcolor[idx] = s:rgb2din99( map(s:xtermcolor[idx], 'v:val / 255.0') )
  257              0.000330 	endfor
                            
                            	" selects the nearest xterm color for a rgb value like #FF0000
    1              0.000006 	function! s:rgb2xterm(color)
                            		let best_match=0
                            		let smallest_distance = 10000000000
                            		let color = tolower(a:color)
                            		let r = s:hex[color[0:1]]
                            		let g = s:hex[color[2:3]]
                            		let b = s:hex[color[4:5]]
                            
                            		let [L1,a1,b1] = s:rgb2din99([ r/255.0, g/255.0, b/255.0 ])
                            
                            		for idx in range(len(s:xtermcolor))
                            			let [L2,a2,b2] = s:xtermcolor[idx]
                            			let dL = L1 - L2
                            			let da = a1 - a2
                            			let db = b1 - b2
                            			let distance = dL*dL + da*da + db*db
                            			if distance == 0 | return idx | endif
                            			if distance > smallest_distance | continue | endif
                            			let smallest_distance = distance
                            			let best_match = idx
                            		endfor
                            		return best_match
                            	endfunction
                            
    1              0.000005 	let s:color_idx = {}
    1              0.000005 	function! s:create_highlight(color, is_bright)
                            		let color_idx = get( s:color_idx, a:color, -1 )
                            		if color_idx == -1
                            			let color_idx = s:rgb2xterm(a:color)
                            			let s:color_idx[a:color] = color_idx
                            		endif
                            		call add( s:exe,
                            			\   'hi BG'.a:color
                            			\ . ' guibg=#' .a:color  .' guifg=#' .( a:is_bright ? '000000' : 'ffffff' )
                            			\ . ' ctermbg='.color_idx.' ctermfg='.( a:is_bright ? 0 : 15 )
                            			\ )
                            	endfunction
    1              0.000001 endif
                            
    1              0.000004 function! s:recreate_highlights()
                            	call filter( copy( b:css_color_hi ), 's:create_highlight( v:key, v:val )' )
                            endfunction
                            
    1              0.000004 let s:pattern_color = {}
    1              0.000003 let s:color_bright  = {}
    1              0.000003 function! s:create_syn_match()
                            
                            	let pattern = submatch(0)
                            
                            	if has_key( b:css_color_syn, pattern ) | return | endif
                            	let b:css_color_syn[pattern] = 1
                            
                            	let rgb_color = get( s:pattern_color, pattern, '' )
                            
                            	if ! strlen( rgb_color )
                            		let hex = submatch(1)
                            		let funcname = submatch(2)
                            
                            		let rgb_color
                            			\ = funcname == 'rgb' ? s:rgb2color(submatch(3),submatch(4),submatch(5))
                            			\ : funcname == 'hsl' ? s:hsl2color(submatch(3),submatch(4),submatch(5))
                            			\ : strlen(hex) >= 6  ? tolower(hex[0:5])
                            			\ : strlen(hex) >= 3  ? tolower(hex[0].hex[0].hex[1].hex[1].hex[2].hex[2])
                            			\ : ''
                            
                            		if rgb_color == '' | throw 'css_color: create_syn_match invoked on bad match data' | endif
                            		let s:pattern_color[pattern] = rgb_color
                            	endif
                            
                            	if ! has_key( b:css_color_hi, rgb_color )
                            		let is_bright = get( s:color_bright, rgb_color, -1 )
                            		if is_bright == -1
                            			let r = s:hex[rgb_color[0:1]]
                            			let g = s:hex[rgb_color[2:3]]
                            			let b = s:hex[rgb_color[4:5]]
                            			let is_bright = r*30 + g*59 + b*11 > 12000
                            			let s:color_bright[rgb_color] = is_bright
                            		endif
                            
                            		call s:create_highlight( rgb_color, is_bright )
                            		let b:css_color_hi[rgb_color] = is_bright
                            	endif
                            
                            	" iff pattern ends on word character, require word break to match
                            	if pattern =~ '\>$' | let pattern .= '\>' | endif
                            	call add( s:exe, 'syn match BG'.rgb_color.' /'.escape(pattern, '/').'/ contained containedin=@colorableGroup' )
                            
                            	return ''
                            endfunction
                            
    1              0.000003 function! s:clear_matches()
                            	call map(get(w:, 'css_color_match_id', []), 'matchdelete(v:val)')
                            	let w:css_color_match_id = []
                            endfunction
                            
    1              0.000002 function! s:create_matches()
                            	call s:clear_matches()
                            	if ! &l:cursorline | return | endif
                            	" adds matches based that duplicate the highlighted colors on the current line
                            	let lnr = line('.')
                            	let group = ''
                            	let groupstart = 0
                            	let endcol = &l:synmaxcol ? &l:synmaxcol : col('$')
                            	for col in range( 1, endcol )
                            		let nextgroup = col < endcol ? synIDattr( synID( lnr, col, 1 ), 'name' ) : ''
                            		if group == nextgroup | continue | endif
                            		if group =~ '^BG\x\{6}$'
                            			let regex = '\%'.lnr.'l\%'.groupstart.'c'.repeat( '.', col - groupstart )
                            			let w:css_color_match_id += [ matchadd( group, regex, -1 ) ]
                            		endif
                            		let group = nextgroup
                            		let groupstart = col
                            	endfor
                            endfunction
                            
    1              0.000005 let s:_hexcolor   = '#\(\x\{3}\%(\>\|\x\{3}\>\)\)' " submatch 1
    1              0.000004 let s:_rgbacolor  = '#\(\x\{3}\%(\>\|\x\%(\>\|\x\{2}\%(\>\|\x\{2}\>\)\)\)\)' " submatch 1
    1              0.000003 let s:_funcname   = '\(rgb\|hsl\)a\?' " submatch 2
    1              0.000003 let s:_ws_        = '\s*'
    1              0.000006 let s:_numval     = s:_ws_ . '\(\d\{1,3}%\?\)' " submatch 3,4,5
    1              0.000004 let s:_listsep    = s:_ws_ . ','
    1              0.000004 let s:_otherargs_ = '\%(,[^)]*\)\?'
    1              0.000015 let s:_funcexpr   = s:_funcname . '[(]' . s:_numval . s:_listsep . s:_numval . s:_listsep . s:_numval . s:_ws_ . s:_otherargs_ . '[)]'
    1              0.000006 let s:_csscolor   = s:_rgbacolor . '\|' . s:_funcexpr
                            " N.B. sloppy heuristic constants for performance reasons:
                            "      a) start somewhere left of screen in case of partially visible colorref
                            "      b) take some multiple of &columns to handle multibyte chars etc
                            " N.B. these substitute() calls are here just for the side effect
                            "      of invoking s:create_syn_match during substitution -- because
                            "      match() and friends do not allow finding all matches in a single
                            "      scan without examining the start of the string over and over
    1              0.000003 function! s:parse_screen()
                            	let leftcol = winsaveview().leftcol
                            	let left = max([ leftcol - 15, 0 ])
                            	let width = &columns * 4
                            	call filter( range( line('w0'), line('w$') ), 'substitute( strpart( getline(v:val), col([v:val, left]), width ), b:css_color_pat, ''\=s:create_syn_match()'', ''g'' )' )
                            	call s:flush_exe()
                            endfunction
                            
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000003 function! css_color#reinit()
                            	call s:recreate_highlights()
                            	call s:flush_exe()
                            endfunction
                            
    1              0.000002 function! css_color#enable()
                            	if ! b:css_color_off | return | endif
                            	if len( b:css_color_grp ) | exe 'syn cluster colorableGroup add=' . join( b:css_color_grp, ',' ) | endif
                            	augroup CSSColor
                            		autocmd! * <buffer>
                            		if has('nvim-0.3.1')
                            			autocmd CursorMoved,CursorMovedI <buffer> call s:parse_screen()
                            		else
                            			autocmd CursorMoved,CursorMovedI <buffer> call s:parse_screen() | call s:create_matches()
                            			autocmd BufWinEnter <buffer> call s:create_matches()
                            			autocmd BufWinLeave <buffer> call s:clear_matches()
                            		endif
                            		autocmd ColorScheme <buffer> call css_color#reinit()
                            	augroup END
                            	let b:css_color_off = 0
                            	doautocmd CSSColor CursorMoved
                            endfunction
                            
    1              0.000002 function! css_color#disable()
                            	if b:css_color_off | return | endif
                            	if len( b:css_color_grp ) | exe 'syn cluster colorableGroup remove=' . join( b:css_color_grp, ',' ) | endif
                            	autocmd! CSSColor * <buffer>
                            	let b:css_color_off = 1
                            endfunction
                            
    1              0.000002 function! css_color#toggle()
                            	if b:css_color_off | call css_color#enable()
                            	else               | call css_color#disable()
                            	endif
                            endfunction
                            
    1              0.000006 let s:type         = [ 'none', 'hex', 'rgba', 'css', 'none' ] " with wraparound for index() == -1
    1              0.000008 let s:pat_for_type = [ '^$', s:_hexcolor, s:_rgbacolor, s:_csscolor, '^$' ]
                            
    1              0.000005 function! css_color#init(type, keywords, groups)
                            	let new_type = index( s:type, a:type )
                            	let old_type = index( s:pat_for_type, get( b:, 'css_color_pat', '$^' ) )
                            
                            	let b:css_color_pat = s:pat_for_type[ max( [ old_type, new_type ] ) ]
                            	let b:css_color_grp = extend( get( b:, 'css_color_grp', [] ), split( a:groups, ',' ), 0 )
                            	let b:css_color_hi  = {}
                            	let b:css_color_syn = {}
                            	let b:css_color_off = 1
                            
                            	call css_color#enable()
                            
                            	if a:keywords != 'none'
                            		exe 'syntax include syntax/colornames/'.a:keywords.'.vim'
                            		call extend( s:color_bright, b:css_color_hi )
                            	endif
                            endfunction
                            
                            " utility function for development use
    1              0.000003 function! css_color#dump_highlights()
                            	call s:recreate_highlights()
                            	let cmd = join( sort( remove( s:exe, 0, -1 ) ),  "\n" )
                            	let cmd = substitute( cmd, '#......', '\U&', 'g' )
                            	let cmd = substitute( cmd, 'ctermbg=\zs\d\+', '\=printf("%-3d",submatch(0))', 'g' )
                            	return cmd
                            endfunction

SCRIPT  /home/ahacad/.config/nvim/plugged/vim/after/syntax/vim.vim
Sourced 1 time
Total time:   0.000056
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000042   0.000029 if dracula#should_abort('vim')
    1              0.000003     finish
                            endif
                            
                            hi! link vimAutoCmdSfxList     Type
                            hi! link vimAutoEventList      Type
                            hi! link vimEnvVar             Constant
                            hi! link vimFunction           Function
                            hi! link vimHiBang             Keyword
                            hi! link vimOption             Type
                            hi! link vimSetMod             Keyword
                            hi! link vimSetSep             Delimiter
                            hi! link vimUserAttrbCmpltFunc Function
                            hi! link vimUserFunc           Function

SCRIPT  /usr/share/nvim/runtime/indent/vim.vim
Sourced 1 time
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Apr 18
                            
                            " Only load this indent file when no other was loaded.
    1              0.000005 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000003 let b:did_indent = 1
                            
    1              0.000007 setlocal indentexpr=GetVimIndent()
    1              0.000005 setlocal indentkeys+==end,=},=else,=cat,=finall,=END,0\\,0=\"\\\ 
    1              0.000003 setlocal indentkeys-=0#
                            
    1              0.000003 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000003 if exists("*GetVimIndent")
                              finish
    1              0.000001 endif
    1              0.000010 let s:keepcpo= &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000002 function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
    1              0.000002 let s:lineContPat = '^\s*\(\\\|"\\ \)'
                            
    1              0.000002 function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " The previous line, ignoring line continuation
                              let prev_text_end = lnum > 0 ? getline(lnum) : ''
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ s:lineContPat
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " the start of the previous line, skipping over line continuation
                              let prev_text = getline(lnum)
                              let found_cont = 0
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                            
                              " In heredoc indenting works completely differently.
                              if has('syntax_items') 
                                let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
                                if syn_here =~ 'vimLetHereDocStop'
                                  " End of heredoc: use indent of matching start line
                                  let lnum = v:lnum - 1
                                  while lnum > 0
                            	let attr = synIDattr(synID(lnum, 1, 1), "name")
                            	if attr != '' && attr !~ 'vimLetHereDoc'
                            	  return indent(lnum)
                            	endif
                            	let lnum -= 1
                                  endwhile
                                  return 0
                                endif
                                if syn_here =~ 'vimLetHereDoc'
                                  if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
                            	" First line in heredoc: increase indent
                            	return ind + shiftwidth()
                                  endif
                                  " Heredoc continues: no change in indent
                                  return ind
                                endif
                              endif
                            
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                let found_cont = 1
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                " A { may start a block or a dict.  Assume that when a } follows it's a
                                " terminated dict.
                                if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
                                  let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|fu\%[nction]\|def\|el\%[seif]\)\>\)')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                              " For a line starting with "}" find the matching "{".  If it is at the start
                              " of the line align with it, probably end of a block.
                              " Use the mapped "%" from matchit to find the match, otherwise we may match
                              " a { inside a comment or string.
                              if cur_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe v:lnum
                                  silent! normal %
                                  if line('.') < v:lnum && getline('.') =~ '^\s*{'
                            	let ind = indent('.')
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Below a line starting with "}" find the matching "{".  If it is at the
                              " end of the line we must be below the end of a dictionary.
                              if prev_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe lnum
                                  silent! normal %
                                  if line('.') == lnum || getline('.') !~ '^\s*{'
                            	let ind = ind - shiftwidth()
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Below a line starting with "]" we must be below the end of a list.
                              " Include a "}" and "},} in case a dictionary ends too.
                              if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
                                let ind = ind - shiftwidth()
                              endif
                            
                              let ends_in_comment = has('syntax_items')
                            	\ && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
                            
                              " A line ending in "{" or "[" is most likely the start of a dict/list literal,
                              " indent the next line more.  Not for a continuation line or {{{.
                              if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
                                let ind = ind + shiftwidth()
                              endif
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|finall\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
    1              0.000009 let &cpo = s:keepcpo
    1              0.000003 unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /home/ahacad/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim
Sourced 1 time
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    1              0.000018 let s:available = has('nvim') || (
                                  \   has('job') && (
                                  \     (has('patch-7-4-1826') && !has('gui_running')) ||
                                  \     (has('patch-7-4-1850') &&  has('gui_running')) ||
                                  \     (has('patch-7-4-1832') &&  has('gui_macvim'))
                                  \   )
                                  \ )
                            
    1              0.000002 let s:jobs = {}
                            
    1              0.000003 function! gitgutter#async#available()
                              return s:available
                            endfunction
                            
                            
    1              0.000004 function! gitgutter#async#execute(cmd, bufnr, handler) abort
                              call gitgutter#debug#log('[async] '.a:cmd)
                            
                              let options = {
                                    \   'stdoutbuffer': [],
                                    \   'buffer': a:bufnr,
                                    \   'handler': a:handler
                                    \ }
                              let command = s:build_command(a:cmd)
                            
                              if has('nvim')
                                call jobstart(command, extend(options, {
                                      \   'on_stdout': function('s:on_stdout_nvim'),
                                      \   'on_stderr': function('s:on_stderr_nvim'),
                                      \   'on_exit':   function('s:on_exit_nvim')
                                      \ }))
                              else
                                let job = job_start(command, {
                                      \   'out_cb':   function('s:on_stdout_vim', options),
                                      \   'err_cb':   function('s:on_stderr_vim', options),
                                      \   'close_cb': function('s:on_exit_vim', options)
                                      \ })
                                let s:jobs[s:job_id(job)] = 1
                              endif
                            endfunction
                            
                            
    1              0.000003 function! s:build_command(cmd)
                              if has('unix')
                                return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'
                            endfunction
                            
                            
    1              0.000003 function! s:on_stdout_nvim(_job_id, data, _event) dict abort
                              if empty(self.stdoutbuffer)
                                let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] +
                                      \ [self.stdoutbuffer[-1] . a:data[0]] +
                                      \ a:data[1:]
                              endif
                            endfunction
                            
    1              0.000003 function! s:on_stderr_nvim(_job_id, data, _event) dict abort
                              if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
                              endif
                            endfunction
                            
    1              0.000002 function! s:on_exit_nvim(_job_id, exit_code, _event) dict abort
                              if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
                            
    1              0.000002 function! s:on_stdout_vim(_channel, data) dict abort
                              call add(self.stdoutbuffer, a:data)
                            endfunction
                            
    1              0.000002 function! s:on_stderr_vim(channel, _data) dict abort
                              call self.handler.err(self.buffer)
                            endfunction
                            
    1              0.000002 function! s:on_exit_vim(channel) dict abort
                              let job = ch_getjob(a:channel)
                              let jobid = s:job_id(job)
                              if has_key(s:jobs, jobid) | unlet s:jobs[jobid] | endif
                              while 1
                                if job_status(job) == 'dead'
                                  let exit_code = job_info(job).exitval
                                  break
                                endif
                                sleep 5m
                              endwhile
                            
                              if !exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
                              endif
                            endfunction
                            
    1              0.000002 function! s:job_id(job)
                              " Vim
                              return job_info(a:job).process
                            endfunction

SCRIPT  /home/ahacad/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim
Sourced 1 time
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    1              0.000014 let s:plugin_dir  = expand('<sfile>:p:h:h:h').'/'
    1              0.000004 let s:log_file    = s:plugin_dir.'gitgutter.log'
    1              0.000003 let s:channel_log = s:plugin_dir.'channel.log'
    1              0.000002 let s:new_log_session = 1
                            
                            
    1              0.000003 function! gitgutter#debug#debug()
                              " Open a scratch buffer
                              vsplit __GitGutter_Debug__
                              normal! ggdG
                              setlocal buftype=nofile
                              setlocal bufhidden=delete
                              setlocal noswapfile
                            
                              call s:vim_version()
                              call s:separator()
                            
                              call s:git_version()
                              call s:separator()
                            
                              call s:grep_version()
                              call s:separator()
                            
                              call s:option('updatetime')
                            endfunction
                            
                            
    1              0.000002 function! s:separator()
                              call s:output('')
                            endfunction
                            
    1              0.000002 function! s:vim_version()
                              redir => version_info
                                silent execute 'version'
                              redir END
                              call s:output(split(version_info, '\n')[0:2])
                            endfunction
                            
    1              0.000001 function! s:git_version()
                              let v = system(g:gitgutter_git_executable.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            endfunction
                            
    1              0.000001 function! s:grep_version()
                              let v = system(g:gitgutter_grep.' --version')
                              call s:output( substitute(v, '\n$', '', '') )
                            
                              let v = system(g:gitgutter_grep.' --help')
                              call s:output( substitute(v, '\%x00', '', 'g') )
                            endfunction
                            
    1              0.000002 function! s:option(name)
                              if exists('+' . a:name)
                                let v = eval('&' . a:name)
                                call s:output(a:name . '=' . v)
                                " redir => output
                                "   silent execute "verbose set " . a:name . "?"
                                " redir END
                                " call s:output(a:name . '=' . output)
                              else
                                call s:output(a:name . ' [n/a]')
                              end
                            endfunction
                            
    1              0.000001 function! s:output(text)
                              call append(line('$'), a:text)
                            endfunction
                            
                            " assumes optional args are calling function's optional args
    1              0.000002 function! gitgutter#debug#log(message, ...) abort
                              if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif
                            endfunction
                            
    1              0.000002 function! s:format_for_log(data) abort
                              if type(a:data) == 1
                                return join(split(a:data,'\n'),"\n")
                              elseif type(a:data) == 3
                                return '['.join(a:data,"\n").']'
                              else
                                return a:data
                              endif
                            endfunction
                            

SCRIPT  /home/ahacad/.config/nvim/plugged/vim-bookmarks/autoload/bm_sign.vim
Sourced 1 time
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000007 if !exists("g:bm_sign_init")
    1              0.000009   let g:bm_sign_init = 0
    1              0.000001 endif
                            
                            " Sign {{{
                            
    1              0.000003 function! bm_sign#lazy_init()
                              if g:bm_sign_init ==# 0
                                call bm_sign#init()
                                let g:bm_sign_init = 1
                              endif
                            endfunction
                            
    1              0.000002 function! bm_sign#init()
                              call bm_sign#define_highlights()
                              sign define Bookmark texthl=BookmarkSign
                              sign define BookmarkAnnotation texthl=BookmarkAnnotationSign
                              execute "sign define Bookmark text=". g:bookmark_sign
                              execute "sign define BookmarkAnnotation text=". g:bookmark_annotation_sign
                              if g:bookmark_highlight_lines
                                sign define Bookmark linehl=BookmarkLine
                                sign define BookmarkAnnotation linehl=BookmarkAnnotationLine
                              else
                                sign define Bookmark linehl=
                                sign define BookmarkAnnotation linehl=
                              endif
                            endfunction
                            
    1              0.000002 function! bm_sign#define_highlights()
                              highlight BookmarkSignDefault ctermfg=33 ctermbg=NONE
                              highlight BookmarkAnnotationSignDefault ctermfg=28 ctermbg=NONE
                              highlight BookmarkLineDefault ctermfg=232 ctermbg=33
                              highlight BookmarkAnnotationLineDefault ctermfg=232 ctermbg=28
                              highlight default link BookmarkSign BookmarkSignDefault
                              highlight default link BookmarkAnnotationSign BookmarkAnnotationSignDefault
                              highlight default link BookmarkLine BookmarkLineDefault
                              highlight default link BookmarkAnnotationLine BookmarkAnnotationLineDefault
                            endfunction
                            
    1              0.000003 function! bm_sign#add(file, line_nr, is_annotation)
                              call bm_sign#lazy_init()
                              let sign_idx = g:bm_sign_index
                              call bm_sign#add_at(a:file, sign_idx, a:line_nr, a:is_annotation)
                              return sign_idx
                            endfunction
                            
                            " add sign with certain index
    1              0.000003 function! bm_sign#add_at(file, sign_idx, line_nr, is_annotation)
                              call bm_sign#lazy_init()
                              let name = a:is_annotation ==# 1 ? "BookmarkAnnotation" : "Bookmark"
                              execute "sign place ". a:sign_idx ." line=" . a:line_nr ." name=". name ." file=". a:file
                              if (a:sign_idx >=# g:bm_sign_index)
                                let g:bm_sign_index = a:sign_idx + 1
                              endif
                            endfunction
                            
    1              0.000003 function! bm_sign#update_at(file, sign_idx, line_nr, is_annotation)
                              call bm_sign#del(a:file, a:sign_idx)
                              call bm_sign#add_at(a:file, a:sign_idx, a:line_nr, a:is_annotation)
                            endfunction
                            
    1              0.000002 function! bm_sign#del(file, sign_idx)
                              call bm_sign#lazy_init()
                              try
                                execute "sign unplace ". a:sign_idx ." file=". a:file
                              catch
                              endtry
                            endfunction
                            
                            " Returns dict with {'sign_idx': 'line_nr'}
    1              0.000002 function! bm_sign#lines_for_signs(file)
                              call bm_sign#lazy_init()
                              let bufnr = bufnr(a:file)
                              let signs_raw = util#redir_execute(":sign place file=". a:file)
                              let lines = split(signs_raw, "\n")
                              let result = {}
                              for line in lines
                                let results = matchlist(line, 'line=\(\d\+\)\W\+id=\(\d\+\)\W\+name=bookmark\c')
                                if len(results) ># 0
                                  let result[results[2]] = results[1]
                                endif
                              endfor
                              return result
                            endfunction
                            
                            " }}}

SCRIPT  /home/ahacad/.config/nvim/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.000364
 Self time:   0.000364

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2021 Christian Brabandt et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000004 scriptencoding utf-8
                            
    1              0.000005 let s:untracked_jobs = {}
    1              0.000003 let s:mq_jobs        = {}
    1              0.000002 let s:po_jobs        = {}
    1              0.000002 let s:clean_jobs     = {}
                            
                            " Generic functions handling on exit event of the various async functions
    1              0.000005 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction
                            
                            " also called from branch extension (for non-async vims)
    1              0.000003 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000002 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("%s", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000002 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction
                            
    1              0.000004 function! airline#async#vcs_untracked(config, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
                              else
                                " nvim async or vim without job-feature
                                noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000003 function! s:set_clean_variables(file, vcs, val)
                              let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
                              if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') &&
                                    \ type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
                                let var[a:vcs].dirty=a:val
                                try
                                  call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
                                  unlet! b:airline_head
                                catch
                                endtry
                              endif
                            endfunction
                            
    1              0.000003 function! s:set_clean_jobs_variable(vcs, file, id)
                              if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
                              endif
                              let s:clean_jobs[a:vcs][a:file]=a:id
                            endfunction
                            
    1              0.000002 function! s:on_exit_clean(...) dict abort
                              let buf=self.buf
                              call s:set_clean_variables(self.file, self.vcs, !empty(buf))
                              if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
                                call remove(s:clean_jobs[self.vcs], self.file)
                              endif
                            endfunction
                            
    1              0.000002 function! airline#async#vcs_clean(cmd, file, vcs)
                              if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
                              elseif has("nvim")
                                " nvim async
                                noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000009 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                              " TODO: Check if we need the cwd option for the job_start() functions
                              "       (only works starting with Vim 8.0.0902)
                            
                              function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction
                            
                              function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction
                            
                              function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction
                            
                              function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction
                            
                              function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#get_msgfmt_stat(cmd, file)
                                if !executable('msgfmt')
                                  " no msgfmt
                                  return
                                endif
                                if g:airline#init#is_windows
                                  let cmd = 'cmd /C ' . a:cmd. shellescape(a:file)
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#vim_vcs_clean(cmd, file, vcs)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                let options = {'buf': '', 'vcs': a:vcs, 'file': a:file}
                                let jobs = get(s:clean_jobs, a:vcs, {})
                                if has_key(jobs, a:file)
                                  if job_status(get(jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(jobs, a:file)
                                    " still running
                                    return
                                    " jobs dict should be cleaned on exit, so not needed here
                                    " call remove(jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'null',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_clean', options)})
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
                              function! airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = [&shell, &shellcmdflag, a:config['cmd'] . shellescape(a:file)]
                                endif
                            
                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction
                            
    1              0.000009 elseif has("nvim")
                              " NVim specific functions
                            
    1              0.000006   function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction
                            
    1              0.000003   function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction
                            
    1              0.000002   function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction
                            
    1              0.000002   function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction
                            
    1              0.000002   function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
    1              0.000002   function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd. shellescape(a:file)]
                                endif
                            
                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction
                            
    1              0.000002   function! airline#async#nvim_vcs_clean(cmd, file, vcs)
                                let config = {
                                \ 'buf': '',
                                \ 'vcs': a:vcs,
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:on_exit_clean')}
                                if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
                                else
                                  let cmd = [&shell, &shellcmdflag, a:cmd]
                                endif
                            
                                if !has_key(s:clean_jobs, a:vcs)
                                  let s:clean_jobs[a:vcs] = {}
                                endif
                                if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
                                  return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
                                endif
                                let id = jobstart(cmd, config)
                                call s:set_clean_jobs_variable(a:vcs, a:file, id)
                              endfunction
                            
    1              0.000001 endif
                            
                            " Should work in either Vim pre 8 or Nvim
    1              0.000003 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                try
                                let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
                                endtry
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction
                            
    1              0.000002 function! airline#async#vim7_vcs_clean(cmd, file, vcs)
                              " Vim pre 8, fallback using system()
                              " don't want to to see error messages
                              if g:airline#init#is_windows && &shell =~ 'cmd'
                                let cmd = a:cmd .' 2>nul'
                              elseif g:airline#init#is_windows && &shell =~ 'powerline'
                                let cmd = a:cmd .' 2> $null'
                              else
                                let cmd = a:cmd .' 2>/dev/null'
                              endif
                              let output=system(cmd)
                              call s:set_clean_variables(a:file, a:vcs, !empty(output))
                            endfunction

SCRIPT  /home/ahacad/.config/nvim/plugged/coc.nvim/autoload/coc/highlight.vim
Sourced 1 time
Total time:   0.000465
 Self time:   0.000465

count  total (s)   self (s)
    1              0.000008 scriptencoding utf-8
    1              0.000011 let s:is_vim = !has('nvim')
    1              0.000007 let s:clear_match_by_window = has('nvim-0.5.0') || has('patch-8.1.1084')
    1              0.000005 let s:prop_offset = get(g:, 'coc_text_prop_offset', 1000)
    1              0.000003 let s:namespace_map = {}
    1              0.000002 let s:ns_id = 1
                            
    1              0.000003 if has('nvim-0.5.0')
    1              0.000001   try
    1              0.000041     call getmatches(0)
                              catch /^Vim\%((\a\+)\)\=:E118/
                                let s:clear_match_by_window = 0
    1              0.000002   endtry
    1              0.000001 endif
                            
                            " Get namespaced coc highlights from range of bufnr
                            " start - 0 based start line index
                            " end - 0 based end line index, could be -1 for last line (exclusive)
    1              0.000005 function! coc#highlight#get(bufnr, key, start, end) abort
                              if !has('nvim-0.5.0') && !exists('*prop_list')
                                throw 'Get highlights requires neovim 0.5.0 or vim support prop_list()'
                              endif
                              if !has_key(s:namespace_map, a:key) || !bufloaded(a:bufnr)
                                return {}
                              endif
                              let ns = coc#highlight#create_namespace(a:key)
                              let current = {}
                              if has('nvim-0.5.0')
                                let end = a:end == -1 ? [-1, -1] : [a:end, 0]
                                let markers = nvim_buf_get_extmarks(a:bufnr, ns, [a:start, 0], end, {'details': v:true})
                                for [_, row, start_col, details] in markers
                                  let delta = details['end_row'] - row
                                  if delta > 1 || (delta == 1 && details['end_col'] != 0)
                                    " Don't known neovim's api for multiple lines markers.
                                    continue
                                  endif
                                  let lines = getbufline(a:bufnr, row + 1)
                                  if empty(lines)
                                    " It's possible that markers exceeded last line.
                                    continue
                                  endif
                                  let text = lines[0]
                                  let curr = get(current, string(row), [])
                                  call add(curr, {
                                      \ 'hlGroup': details['hl_group'],
                                      \ 'lnum': row,
                                      \ 'colStart': start_col,
                                      \ 'colEnd': delta == 1 ? strlen(text) : details['end_col']
                                      \ })
                                  let current[string(row)] = curr
                                endfor
                              else
                                let id = s:prop_offset + ns
                                " we could only get textprops line by line
                                let end = a:end == -1 ? getbufinfo(a:bufnr)[0]['linecount'] : a:end
                                for line in range(a:start + 1, end)
                                  let items = []
                                  for prop in prop_list(line, {'bufnr': a:bufnr, 'id': id})
                                    " vim have support for cross line text props, but we're not using
                                    call add(items, {
                                          \ 'hlGroup': s:prop_type_hlgroup(prop['type']),
                                          \ 'lnum': line - 1,
                                          \ 'colStart': prop['col'] - 1,
                                          \ 'colEnd': prop['col'] - 1 + prop['length'] - (prop['end'] == 0 ? 1 : 0),
                                          \ })
                                  endfor
                                  if !empty(items)
                                    let current[string(line - 1)] = items
                                  endif
                                endfor
                              endif
                              return current
                            endfunction
                            
                            " Update highlights by check exists highlights.
    1              0.000003 function! coc#highlight#update_highlights(bufnr, key, highlights, ...) abort
                              if !bufloaded(a:bufnr)
                                return
                              endif
                              let start = get(a:, 1, 0)
                              let end = get(a:, 2, -1)
                              if empty(a:highlights)
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
                                return
                              endif
                              let total = len(a:highlights)
                              " index list that exists with current highlights
                              let exists = []
                              let ns = coc#highlight#create_namespace(a:key)
                              let currIndex = 0
                              if has('nvim-0.5.0') || exists('*prop_list')
                                let current = coc#highlight#get(a:bufnr, a:key, start, end)
                                for lnum in sort(map(keys(current), 'str2nr(v:val)'), {a, b -> a - b})
                                  let items = current[lnum]
                                  let indexes = []
                                  let nextIndex = currIndex
                                  if currIndex != total
                                    for item in items
                                      for i in range(currIndex, total - 1)
                                        let hi = a:highlights[i]
                                        if hi['lnum'] > item['lnum']
                                          let nextIndex = i
                                          break
                                        endif
                                        if coc#helper#obj_equal(item, hi)
                                          call add(indexes, i)
                                          let nextIndex = max([nextIndex, i + 1])
                                        endif
                                      endfor
                                    endfor
                                  endif
                                  let currIndex = nextIndex
                                  " all highlights of current line exists, not clear.
                                  if len(indexes) == len(items)
                                    let exists = exists + indexes
                                  else
                                    if has('nvim')
                                      call nvim_buf_clear_namespace(a:bufnr, ns, lnum, lnum + 1)
                                    else
                                      call coc#api#call('buf_clear_namespace', [a:bufnr, ns, lnum, lnum + 1])
                                    endif
                                  endif
                                endfor
                              else
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
                              endif
                              for i in range(0, total - 1)
                                if index(exists, i) == -1
                                  let hi = a:highlights[i]
                                  call coc#highlight#add_highlight(a:bufnr, ns, hi['hlGroup'], hi['lnum'], hi['colStart'], hi['colEnd'])
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! coc#highlight#get_highlights(bufnr, key) abort
                              if !has_key(s:namespace_map, a:key) || !bufloaded(a:bufnr)
                                return []
                              endif
                              let res = []
                              let ns = s:namespace_map[a:key]
                              if exists('*prop_list')
                                let lines = getbufline(a:bufnr, 1, '$')
                                let linecount = len(lines)
                                for line in range(1, linecount)
                                  for prop in prop_list(line, {'bufnr': a:bufnr, 'id': s:prop_offset + ns})
                                    if prop['start'] == 0 || prop['end'] == 0
                                      " multi line tokens are not supported; simply ignore it
                                      continue
                                    endif
                                    let text = lines[line - 1]
                                    call add(res, {
                                          \   'hlGroup': s:prop_type_hlgroup(prop['type']),
                                          \   'lnum': line - 1,
                                          \   'colStart': coc#helper#get_charactor(text, prop['col']),
                                          \   'colEnd': coc#helper#get_charactor(text, prop['col'] + prop['length'])
                                          \ })
                                  endfor
                                endfor
                              elseif has('nvim-0.5.0')
                                let markers = nvim_buf_get_extmarks(a:bufnr, ns, 0, -1, {'details': v:true})
                                let lines = getbufline(a:bufnr, 1, '$')
                                let total = len(lines)
                                for [_, line, start_col, details] in markers
                                  if line >= total
                                    " Could be markers exceed end of line
                                    continue
                                  endif
                                  let text = lines[line]
                                  let delta = details['end_row'] - line
                                  if delta > 1 || (delta == 1 && details['end_col'] != 0)
                                    " can't handle, single line only
                                    continue
                                  endif
                                  call add(res, {
                                        \   'hlGroup': details['hl_group'],
                                        \   'lnum': line,
                                        \   'colStart': coc#helper#get_charactor(text, start_col + 1),
                                        \   'colEnd': delta == 1 ? strchars(text) : coc#helper#get_charactor(text, details['end_col'] + 1)
                                        \ })
                                endfor
                              else
                                throw 'Get highlights requires neovim 0.5.0 or vim support prop_list'
                              endif
                              return res
                            endfunction
                            
                            " highlight LSP range,
    1              0.000004 function! coc#highlight#ranges(bufnr, key, hlGroup, ranges) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr) || !exists('*getbufline')
                                return
                              endif
                              let synmaxcol = getbufvar(a:bufnr, '&synmaxcol', 1000)
                              if synmaxcol == 0
                                let synmaxcol = 1000
                              endif
                              let synmaxcol = min([synmaxcol, 1000])
                              let srcId = coc#highlight#create_namespace(a:key)
                              for range in a:ranges
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  if start['character'] > synmaxcol || end['character'] > synmaxcol
                                    continue
                                  endif
                                  " TODO don't know how to count UTF16 code point, should work most cases.
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) : 0
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) : -1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call coc#highlight#add_highlight(bufnr, srcId, a:hlGroup, lnum - 1, colStart, colEnd)
                                endfor
                              endfor
                            endfunction
                            
    1              0.000004 function! coc#highlight#add_highlight(bufnr, src_id, hl_group, line, col_start, col_end) abort
                              if has('nvim')
                                call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                              else
                                call coc#api#call('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end])
                              endif
                            endfunction
                            
    1              0.000003 function! coc#highlight#clear_highlight(bufnr, key, start_line, end_line) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr)
                                return
                              endif
                              let src_id = coc#highlight#create_namespace(a:key)
                              if has('nvim')
                                call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
                              endif
                            endfunction
                            
                            " highlight buffer in winid with CodeBlock &HighlightItems
                            " export interface HighlightItem {
                            "   lnum: number // 0 based
                            "   hlGroup: string
                            "   colStart: number // 0 based
                            "   colEnd: number
                            " }
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    1              0.000003 function! coc#highlight#add_highlights(winid, codes, highlights) abort
                              " clear highlights
                              call coc#compat#execute(a:winid, 'syntax clear')
                              let bufnr = winbufnr(a:winid)
                              call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
                              if !empty(a:codes)
                                call coc#highlight#highlight_lines(a:winid, a:codes)
                              endif
                              if !empty(a:highlights)
                                for item in a:highlights
                                  call coc#highlight#add_highlight(bufnr, -1, item['hlGroup'], item['lnum'], item['colStart'], item['colEnd'])
                                endfor
                              endif
                            endfunction
                            
                            
                            " Add highlights to line groups of winid, support hlGroup and filetype
                            " config should have startLine, endLine (1 based, end excluded) and filetype or hlGroup
                            " endLine should > startLine and endLine is excluded
                            "
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    1              0.000002 function! coc#highlight#highlight_lines(winid, blocks) abort
                              let currwin = win_getid()
                              let switch = has('nvim') && currwin != a:winid
                              if switch
                                noa call nvim_set_current_win(a:winid)
                              endif
                              let defined = []
                              let region_id = 1
                              for config in a:blocks
                                let start = config['startLine'] + 1
                                let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
                                let filetype = get(config, 'filetype', '')
                                let hlGroup = get(config, 'hlGroup', '')
                                if !empty(hlGroup)
                                  call s:execute(a:winid, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
                                else
                                  let filetype = matchstr(filetype, '\v^\w+')
                                  if empty(filetype) || filetype == 'txt' || index(get(g:, 'coc_markdown_disabled_languages', []), filetype) != -1
                                    continue
                                  endif
                                  if index(defined, filetype) == -1
                                    call s:execute(a:winid, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
                                    if has('nvim')
                                      unlet! b:current_syntax
                                    elseif exists('*win_execute')
                                      call win_execute(a:winid, 'unlet! b:current_syntax')
                                    endif
                                    call add(defined, filetype)
                                  endif
                                  call s:execute(a:winid, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype).' keepend')
                                  let region_id = region_id + 1
                                endif
                              endfor
                              if switch
                                noa call nvim_set_current_win(currwin)
                              endif
                            endfunction
                            
                            " Copmpose hlGroups with foreground and background colors.
    1              0.000002 function! coc#highlight#compose_hlgroup(fgGroup, bgGroup) abort
                              let hlGroup = 'Fg'.a:fgGroup.'Bg'.a:bgGroup
                              if a:fgGroup == a:bgGroup
                                return a:fgGroup
                              endif
                              if hlexists(hlGroup)
                                return hlGroup
                              endif
                              let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'gui')
                              let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'gui')
                              if fg =~# '^#' || bg =~# '^#'
                                call s:create_gui_hlgroup(hlGroup, fg, bg, '')
                              else
                                let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'cterm')
                                let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'cterm')
                                call s:create_cterm_hlgroup(hlGroup, fg, bg, '')
                              endif
                              return hlGroup
                            endfunction
                            
                            " add matches for winid, use 0 for current window.
    1              0.000003 function! coc#highlight#match_ranges(winid, bufnr, ranges, hlGroup, priority) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
                              if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
                              endif
                              if !s:clear_match_by_window
                                let curr = win_getid()
                                if has('nvim')
                                  noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
                                endif
                              endif
                              let ids = []
                              for range in a:ranges
                                let pos = []
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call add(pos, [lnum, colStart, colEnd - colStart])
                                endfor
                                if !empty(pos)
                                  let opts = s:clear_match_by_window ? {'window': a:winid} : {}
                                  let i = 1
                                  let l = []
                                  for p in pos
                                    call add(l, p)
                                    if i % 8 == 0
                                      let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
                                      call add(ids, id)
                                      let l = []
                                    endif
                                    let i += 1
                                  endfor
                                  if !empty(l)
                                    let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
                                    call add(ids, id)
                                  endif
                                endif
                              endfor
                              if !s:clear_match_by_window
                                if has('nvim')
                                  noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
                                endif
                              endif
                              return ids
                            endfunction
                            
                            " Clear matches by hlGroup regexp.
    1              0.000002 function! coc#highlight#clear_match_group(winid, match) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
                                for item in arr
                                  call matchdelete(item['id'], winid)
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction
                            
                            " Clear matches by match ids, use 0 for current win.
    1              0.000002 function! coc#highlight#clear_matches(winid, ids)
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                for id in a:ids
                                  try
                                    call matchdelete(id, winid)
                                  catch /^Vim\%((\a\+)\)\=:E803/
                                    " ignore
                                  endtry
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  for id in a:ids
                                    try
                                      call matchdelete(id)
                                    catch /^Vim\%((\a\+)\)\=:E803/
                                      " ignore
                                    endtry
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction
                            
                            " Sets the highlighting for the given group
    1              0.000004 function! s:create_gui_hlgroup(group, fg, bg, attr)
                              if a:fg != ""
                                exec "silent hi " . a:group . " guifg=" . a:fg . " ctermfg=" . coc#color#rgb2term(strpart(a:fg, 1))
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " guibg=" . a:bg . " ctermbg=" . coc#color#rgb2term(strpart(a:bg, 1))
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
                              endif
                            endfun
                            
    1              0.000003 function! s:create_cterm_hlgroup(group, fg, bg, attr) abort
                              if a:fg != ""
                                exec "silent hi " . a:group . " ctermfg=" . a:fg
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " ctermbg=" . a:bg
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " cterm=" . a:attr
                              endif
                            endfunction
                            
    1              0.000002 function! s:execute(winid, cmd) abort
                              if has('nvim')
                                execute 'silent! ' a:cmd
                              else
                                call win_execute(a:winid, a:cmd, 'silent!')
                              endif
                            endfunction
                            
    1              0.000002 function! s:prop_type_hlgroup(type) abort
                              if a:type=~# '^CocHighlight'
                                return a:type[12:]
                              endif
                              return prop_type_get(a:type)['highlight']
                            endfunction
                            
    1              0.000002 function! coc#highlight#create_namespace(key) abort
                              if type(a:key) == 0
                                return a:key
                              endif
                              if has_key(s:namespace_map, a:key)
                                return s:namespace_map[a:key]
                              endif
                              if has('nvim')
                                let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
                              else
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]
                            endfunction

FUNCTION  <SNR>135_update_hg_branch()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:145
Called 53 times
Total time:   0.006450
 Self time:   0.005813

count  total (s)   self (s)
   53   0.001264   0.000628   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   53              0.000054   else
   53              0.000248     let s:vcs_config['mercurial'].branch = ''
   53              0.000052   endif

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:280
Called 1 time
Total time:   0.000809
 Self time:   0.000557

count  total (s)   self (s)
    1   0.000011   0.000009   let path = s:Slash(a:path)
    1              0.000005   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    1              0.000002   elseif empty(path)
                                return ''
    1              0.000005   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    1              0.000001   else
    1              0.000010     let path = fnamemodify(path, ':p:h:s?/$??')
    1              0.000001   endif
    1              0.000011   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    1              0.000004   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    1              0.000001   endif
    1              0.000013   let root = resolve(path)
    1              0.000002   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    1              0.000001   endif
    1              0.000002   let previous = ""
    1              0.000010   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    1   0.000025   0.000012   call s:Tree(env_git_dir)
    6              0.000011   while root !=# previous
    5              0.000029     if root =~# '\v^//%([^/]+/?)?$'
                                  break
    5              0.000002     endif
    5   0.000198   0.000047     if index(s:CeilingDirectories(), root) >= 0
                                  break
    5              0.000002     endif
    5              0.000022     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
    5              0.000016     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
    5              0.000002     endif
    5              0.000036     let dir = substitute(root, '[\/]$', '', '') . '/.git'
    5              0.000026     let type = getftype(dir)
    5              0.000011     if type ==# 'dir' && FugitiveIsGitDir(dir)
                                  return dir
    5              0.000009     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
    5              0.000009     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
    5   0.000122   0.000035     elseif FugitiveIsGitDir(root)
                                  return root
    5              0.000003     endif
    5              0.000008     let previous = root
    5              0.000014     let root = fnamemodify(root, ':h')
    6              0.000006   endwhile
    1              0.000001   return ''

FUNCTION  <SNR>165_tab_num()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:390
Called 2 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
                              " Format the tab number, for either the tab label or the right corner. {{{1
                              "
                              " @param tabnr: tab number
                              " Returns: the formatted tab number
                            
    2              0.000007   if s:v.tabline_mode != 'tabs'
                                return printf("%s %d/%d ", "%#XTNumSel#", a:tabnr, tabpagenr('$'))
    2              0.000003   else
    2              0.000031     return a:tabnr == tabpagenr() ?   printf("%s %d ", "%#XTNumSel#", a:tabnr) : printf("%s %d ", "%#XTNum#", a:tabnr)
                              endif

FUNCTION  airline#extensions#vista#currenttag()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/vista.vim:10
Called 53 times
Total time:   0.004072
 Self time:   0.001270

count  total (s)   self (s)
   53              0.000371   if get(w:, 'airline_active', 0)
   53   0.003647   0.000845     return airline#util#shorten(get(b:, 'vista_nearest_method_or_function', ''), 91, 9)
                              endif

FUNCTION  <SNR>109_LocalBrowse()
    Defined: /usr/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 1 time
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    1              0.000003   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    1              0.000001   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    1              0.000005   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    1              0.000008   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    1              0.000001   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    1              0.000001   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  coc#client#get_channel()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim:149
Called 24 times
Total time:   0.000308
 Self time:   0.000308

count  total (s)   self (s)
   24              0.000077   if s:is_vim
                                return a:client['channel']
   24              0.000028   endif
   24              0.000092   return a:client['chan_id']

FUNCTION  9()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/autoloclist.vim:15
Called 1 time
Total time:   0.000123
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000023   0.000009     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    1   0.000099   0.000007     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  airline#async#nvim_vcs_clean()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:305
Called 2 times
Total time:   0.001745
 Self time:   0.001689

count  total (s)   self (s)
    2   0.000101   0.000075     let config = { 'buf': '', 'vcs': a:vcs, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')), 'on_stdout': function('s:nvim_output_handler'), 'on_stderr': function('s:nvim_output_handler'), 'on_exit': function('s:on_exit_clean')}
    2              0.000005     if g:airline#init#is_windows && &shell =~ 'cmd\|powershell'
                                  let cmd = a:cmd
    2              0.000001     else
    2              0.000011       let cmd = [&shell, &shellcmdflag, a:cmd]
    2              0.000001     endif
                            
    2              0.000007     if !has_key(s:clean_jobs, a:vcs)
    1              0.000004       let s:clean_jobs[a:vcs] = {}
    2              0.000001     endif
    2              0.000007     if has_key(s:clean_jobs[a:vcs], a:file)
                                  " still running
    1              0.000001       return
                                  " jobs dict should be cleaned on exit, so not needed here
                                  " call remove(s:clean_jobs[a:vcs], a:file)
    1              0.000001     endif
    1              0.001494     let id = jobstart(cmd, config)
    1   0.000097   0.000066     call s:set_clean_jobs_variable(a:vcs, a:file, id)

FUNCTION  airline#extensions#undotree#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/undotree.vim:11
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000003   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{exists("t:undotree") ? t:undotree.GetStatusLine() : ""}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{exists("t:diffpanel") ? t:diffpanel.GetStatusLine() : ""}')
                                endif
    1              0.000000   endif

FUNCTION  <SNR>163_match_word()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:108
Called 9 times
Total time:   0.000828
 Self time:   0.000828

count  total (s)   self (s)
    9              0.000049   if (a:word ==# '\<\>')
    4              0.000006     return
    5              0.000008   endif
    5              0.000021   if g:Illuminate_highlightUnderCursor
    5              0.000287     if hlexists('illuminatedCurWord')
                                  let w:match_id = matchadd('illuminatedWord', '\V\(\k\*\%#\k\*\)\@\!\&' . a:word, g:Illuminate_highlightPriority)
                                  let w:match_curword_id = matchadd('illuminatedCurWord', '\V\(\k\*\%#\k\*\)\&' . a:word, g:Illuminate_highlightPriority)
    5              0.000010     else
    5              0.000253       let w:match_id = matchadd('illuminatedWord', '\V' . a:word, g:Illuminate_highlightPriority)
    5              0.000011     endif
                              else
                                let w:match_id = matchadd('illuminatedWord', '\V\(\k\*\%#\k\*\)\@\!\&' . a:word, g:Illuminate_highlightPriority)
    5              0.000007   endif

FUNCTION  <SNR>118_IndentLinesEnable()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:148
Called 1 time
Total time:   0.000694
 Self time:   0.000651

count  total (s)   self (s)
    1              0.000002     if g:indentLine_newVersion
    1              0.000004         if exists("b:indentLine_enabled") && b:indentLine_enabled == 0
                                        return
    1              0.000001         endif
                            
    1              0.000003         if !exists("w:indentLine_indentLineId")
                                        let w:indentLine_indentLineId = []
    1              0.000001         endif
                            
    1   0.000053   0.000011         call s:SetConcealOption()
                            
    1              0.000002         if g:indentLine_showFirstIndentLevel
                                        call add(w:indentLine_indentLineId, matchadd('Conceal', '^ ', 0, -1, {'conceal': g:indentLine_first_char}))
    1              0.000001         endif
                            
    1              0.000004         let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
    1              0.000003         let n = len(g:indentLine_char_list)
    1              0.000002         let level = 0
   21              0.000029         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
   20              0.000023             if n > 0
   20              0.000053                 let char = g:indentLine_char_list[level % n]
   20              0.000033                 let level += 1
                                        else
                                            let char = g:indentLine_char
   20              0.000010             endif
   20              0.000380             call add(w:indentLine_indentLineId, matchadd('Conceal', '^\s\+\zs\%'.i.'v ', 0, -1, {'conceal': char}))
   21              0.000019         endfor
                            
    1              0.000001         return
                                endif
                            
                                if exists("b:indentLine_enabled") && b:indentLine_enabled
                                    return
                                else
                                    let b:indentLine_enabled = 1
                                endif
                            
                                call s:SetConcealOption()
                            
                                let g:mysyntaxfile = g:indentLine_mysyntaxfile
                            
                                let space = &l:shiftwidth == 0 ? &l:tabstop : &l:shiftwidth
                            
                                if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
                                if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
                                    let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
                                    for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
                                        execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
                                    endfor
                                endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:93
Called 1 time
Total time:   0.001824
 Self time:   0.000201

count  total (s)   self (s)
   13              0.000017     for Fn in a:list
   13   0.001761   0.000139       let code = call(Fn, a:000)
   13              0.000015       if code != 0
    1              0.000001         return code
   12              0.000006       endif
   12              0.000007     endfor
                                return 0

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000005   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    1              0.000001   endif

FUNCTION  rainbow_main#gen_config()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow_main.vim:78
Called 1 time
Total time:   0.000192
 Self time:   0.000138

count  total (s)   self (s)
    1              0.000009 	let g = exists('g:rainbow_conf')? g:rainbow_conf : {}
                            	"echom 'g:rainbow_conf:' string(g)
    1              0.000006 	let s = get(g, 'separately', {})
                            	"echom 'g:rainbow_conf.separately:' string(s)
    1              0.000018 	let dft_conf = extend(copy(s:rainbow_conf), g) | unlet dft_conf.separately
                            	"echom 'default config options:' string(dft_conf)
    1              0.000004 	let dx_conf = s:rainbow_conf.separately['*']
                            	"echom 'default star config:' string(dx_conf)
    1              0.000006 	let ds_conf = get(s:rainbow_conf.separately, a:ft, dx_conf)
                            	"echom 'default separately config:' string(ds_conf)
    1              0.000004 	let ux_conf = get(s, '*', ds_conf)
                            	"echom 'user star config:' string(ux_conf)
    1              0.000003 	let us_conf = get(s, a:ft, ux_conf)
                            	"echom 'user separately config:' string(us_conf)
    1   0.000021   0.000013 	let af_conf = (s:eq(us_conf, 'default') ? ds_conf : us_conf)
                            	"echom 'almost finally config:' string(af_conf)
    1   0.000012   0.000008 	if s:eq(af_conf, 0)
                            		return 0
    1              0.000001 	else
    1              0.000025 		let conf = extend(extend({'syn_name_prefix': substitute(a:ft, '\v\A+(\a)', '\u\1', 'g').'Rainbow'}, dft_conf), af_conf)
    1   0.000073   0.000031 		let conf.cycle = (has('gui_running') || (has('termguicolors') && &termguicolors)) ? s:lcm(len(conf.guifgs), len(conf.guis)) : s:lcm(len(conf.ctermfgs), len(conf.cterms))
    1              0.000001 		return conf
                            	endif

FUNCTION  <SNR>118_LeadingSpaceDisable()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:364
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000002     if g:indentLine_newVersion
    1              0.000004         if exists("w:indentLine_leadingSpaceId") && ! empty(w:indentLine_leadingSpaceId)
                                        for id in w:indentLine_leadingSpaceId
                                            try
                                                call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
                                            endtry
                                        endfor
                                        let w:indentLine_leadingSpaceId = []
    1              0.000001         endif
                            
    1              0.000001         return
                                endif
                            
                                let b:indentLine_leadingSpaceEnabled = 0
                                try
                                    syntax clear IndentLineLeadingSpace
                                catch /^Vim\%((\a\+)\)\=:E28/   " catch error E28
                                endtry

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 1 time
Total time:   0.003142
 Self time:   0.000054

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    1   0.000246   0.000009   if gitgutter#utility#is_active(a:bufnr)
                            
    1              0.000005     if has('patch-7.4.1559')
    1              0.000008       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    1              0.000001     endif
    1   0.002869   0.000017     let how = s:setup_path(a:bufnr, l:Callback)
    1              0.000005     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    1              0.000001       return
                                endif
                            
                                if a:force || s:has_fresh_changes(a:bufnr)
                            
                                  let diff = 'NOT SET'
                                  try
                                    let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
                                  if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
                                endif
                              endif

FUNCTION  <SNR>75_bookmark_remove()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:419
Called 4 times
Total time:   0.001241
 Self time:   0.000359

count  total (s)   self (s)
    4   0.000050   0.000036   let bookmark = bm#get_bookmark_by_line(a:file, a:line_nr)
    4   0.001036   0.000281   call bm_sign#del(a:file, bookmark['sign_idx'])
    4   0.000152   0.000040   call bm#del_bookmark_at_line(a:file, a:line_nr)

FUNCTION  AirlineWebDevIcons()
    Defined: ~/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:581
Called 1 time
Total time:   0.000077
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000008   let w:airline_section_x = get(w:, 'airline_section_x', get(g:, 'airline_section_x', ''))
    1              0.000004   let w:airline_section_x .= ' %{WebDevIconsGetFileTypeSymbol()} '
    1   0.000056   0.000010   let hasFileFormatEncodingPart = airline#parts#ffenc() !=? ''
    1              0.000004   if g:webdevicons_enable_airline_statusline_fileformat_symbols && hasFileFormatEncodingPart
    1              0.000003     let w:airline_section_y = ' %{&fenc . " " . WebDevIconsGetFileFormatSymbol()} '
    1              0.000001   endif

FUNCTION  <SNR>131_get_hunks_gitgutter()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 53 times
Total time:   0.001717
 Self time:   0.001056

count  total (s)   self (s)
   53   0.001576   0.000914   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
   53              0.000083     return ''
                              endif
                              return GitGutterGetHunkSummary()

FUNCTION  bm#has_bookmark_at_line()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:15
Called 53 times
Total time:   0.000519
 Self time:   0.000519

count  total (s)   self (s)
   53              0.000340   if !has_key(g:line_map, a:file)
   53              0.000092     return 0
                              endif
                              return has_key(g:line_map[a:file], a:line_nr)

FUNCTION  gitgutter#debug#log()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000002   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    1              0.000001   endif

FUNCTION  xtabline#buffer#update()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/buffer.vim:51
Called 1 time
Total time:   0.000070
 Self time:   0.000031

count  total (s)   self (s)
                              " Refresh buffer informations.
    1   0.000049   0.000010   let buf = xtabline#buffer#get(a:nr)
    1              0.000020   let buf.path = fnamemodify(bufname(a:nr), ':p')

FUNCTION  <SNR>159_synID()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:43
Called 216 times
Total time:   0.000865
 Self time:   0.000865

count  total (s)   self (s)
  216              0.000806 	return a:prefix.'_lv'.a:lv.'_'.a:group.a:id

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 53 times
Total time:   0.003235
 Self time:   0.000714

count  total (s)   self (s)
   53   0.003197   0.000677   return airline#extensions#coc#get('error')

FUNCTION  <SNR>95_root()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:117
Called 2 times
Total time:   0.003454
 Self time:   0.001320

count  total (s)   self (s)
    2   0.000079   0.000017   let dir = s:current()
                            
                              " breadth-first search
   10              0.000009   while 1
   60              0.000084     for pattern in g:rooter_patterns
   50              0.000081       if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
   50              0.000025       else
   50              0.000138         let [p, exclude] = [pattern, 0]
   50              0.000027       endif
   50   0.002373   0.000336       if s:match(dir, p)
                                    if exclude
                                      break
                                    else
                                      return dir
                                    endif
   50              0.000024       endif
   60              0.000043     endfor
                            
   10   0.000126   0.000090     let [current, dir] = [dir, s:parent(dir)]
   18              0.000027     if current == dir | break | endif
   10              0.000011   endwhile
                            
    2              0.000002   return ''

FUNCTION  <SNR>95_current()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:208
Called 2 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000019   let fn = expand('%:p', 1)
    2              0.000016   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
    2              0.000009   if empty(fn) | return getcwd() | endif  " opening vim without a file
    2              0.000008   if g:rooter_resolve_links | let fn = resolve(fn) | endif
    2              0.000006   return fnamemodify(fn, ':h')

FUNCTION  <SNR>129_get_syn()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:44
Called 916 times
Total time:   0.047962
 Self time:   0.047962

count  total (s)   self (s)
  916              0.002885     let color = ''
  916              0.008698     if hlexists(a:group)
  912              0.013005       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
  916              0.001200     endif
  916              0.004573     if empty(color) || color == -1
                                  " should always exist
    4              0.000066       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
    4              0.000009       if empty(color) || color == -1
    4              0.000006         let color = 'NONE'
    4              0.000002       endif
  916              0.000895     endif
  916              0.002169     return color

FUNCTION  <SNR>75_remove_all_bookmarks()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:443
Called 1 time
Total time:   0.001414
 Self time:   0.000141

count  total (s)   self (s)
    1   0.000010   0.000006   let files = bm#all_files()
    4              0.000005   for file in files
    3   0.000051   0.000022     let lines = bm#all_lines(file)
    7              0.000011     for line_nr in lines
    4   0.001308   0.000067       call s:bookmark_remove(file, line_nr)
    7              0.000006     endfor
    4              0.000003   endfor

FUNCTION  <SNR>83_template()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/tab.vim:24
Called 1 time
Total time:   0.000069
 Self time:   0.000021

count  total (s)   self (s)
                              " Template for tab.
    1   0.000067   0.000020   return { 'name':    '', 'cwd':     s:F.fulldir(getcwd()), 'locked':  0, 'icon':    '', 'files':   [], 'buffers': {'valid': [], 'order': [], 'extra': [], 'recent': []},}

FUNCTION  <SNR>73_on_vimleavepre()
    Defined: ~/.config/nvim/plugged/vim-startify/plugin/startify.vim:52
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000025   if get(g:, 'startify_session_persistence') && exists('v:this_session') && filewritable(v:this_session)
                                call startify#session_write(fnameescape(v:this_session))
    1              0.000002   endif

FUNCTION  <SNR>50_QuitPreHook()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim:370
Called 1 time
Total time:   0.000653
 Self time:   0.000230

count  total (s)   self (s)
    1   0.000321   0.000059     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000139   0.000066     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000122   0.000033     if !syntastic#util#var('check_on_wq')
                                    call syntastic#util#setWids()
                                    call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
    1              0.000003     endif
                            
    1              0.000018     if !empty(get(w:, 'syntastic_loclist_set', []))
                                    call SyntasticLoclistHide()
    1              0.000002     endif

FUNCTION  bm#total_count()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:112
Called 2 times
Total time:   0.001078
 Self time:   0.000050

count  total (s)   self (s)
    2   0.001070   0.000042   return len(bm#location_list())

FUNCTION  MatchTagAlways#Setup()
    Defined: ~/.config/nvim/plugged/MatchTagAlways/autoload/MatchTagAlways.vim:42
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                              " When vim is in diff mode, don't run
    1              0.000002   if &diff
                                return
    1              0.000001   endif
                            
                              " If this is not an allowed filetype, don't do anything
    1              0.000005   if !get( g:mta_filetypes, &filetype, 0 )
    1              0.000001     return
                              endif
                            
                              augroup matchtagalways
                                autocmd! CursorMoved,CursorMovedI,WinEnter <buffer> call s:HighlightEnclosingTagsIfPossible()
                              augroup END
                            
                              if !g:mta_use_matchparen_group && g:mta_set_default_matchtag_color
                                hi MatchTag ctermfg=black ctermbg=lightblue guifg=black guibg=lightblue
                              endif

FUNCTION  airline#util#append()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:49
Called 371 times
Total time:   0.006527
 Self time:   0.006527

count  total (s)   self (s)
  371              0.001528   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  371              0.000304   endif
  371              0.001930   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  371              0.001880   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#vimtex#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/vimtex.vim:44
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   if exists("b:vimtex")
                                let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
                                let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
    1              0.000001   endif

FUNCTION  <SNR>118_SetConcealOption()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:96
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000002     if !g:indentLine_setConceal
                                    return
    1              0.000001     endif
    1              0.000004     if !(exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet)
    1              0.000004         let b:indentLine_ConcealOptionSet = 1
    1              0.000004         let b:indentLine_original_concealcursor = &l:concealcursor
    1              0.000004         let b:indentLine_original_conceallevel = &l:conceallevel
    1              0.000010         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    1              0.000009         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    1              0.000001     endif

FUNCTION  <SNR>36_sortByLength()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim:467
Called 21 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
   21              0.000061   return len(a:i2[0])-len(a:i1[0])

FUNCTION  <SNR>101_variables()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:239
Called 1 time
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
    1              0.000007   let info = getbufinfo(a:bufnr)
    1              0.000048   let variables = empty(info) ? {} : copy(info[0]['variables'])
   50              0.000063   for key in keys(variables)
   49              0.000121     if key !~# '\v^coc'
   49              0.000106       unlet variables[key]
   49              0.000022     endif
   50              0.000026   endfor
    1              0.000002   return variables

FUNCTION  signature#utils#IsValidMarker()
    Defined: ~/.config/nvim/plugged/vim-signature/autoload/signature/utils.vim:183
Called 52 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
   52              0.000171   return (  (b:SignatureIncludeMarkers =~# a:marker) && (a:marker != ' ') )

FUNCTION  <SNR>95_activate()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:87
Called 2 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
                              " Directory browser plugins (e.g. vim-dirvish, NERDTree) tend to
                              " set a nofile buftype when you open a directory.
    2              0.000013   if &buftype != '' && &buftype != 'nofile' | return 0 | endif
                            
    2              0.000016   let patterns = split(g:rooter_targets, ',')
    2              0.000024   let fn = expand('%:p', 1)
                            
    2              0.000022   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
                            
                              " directory
    2              0.000008   if empty(fn) || fn[-1:] == '/'
                                return index(patterns, '/') != -1
    2              0.000001   endif
                            
                              " file
    2              0.000023   if !filereadable(fn) | return 0 | endif
    2              0.000008   if !exists('*glob2regpat') | return 1 | endif
                            
    2              0.000021   for p in filter(copy(patterns), 'v:val != "/"')
    2              0.000021     if fn =~ glob2regpat(p)
    2              0.000003       return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:190
Called 51 times
Total time:   0.001335
 Self time:   0.001335

count  total (s)   self (s)
   51              0.000365   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
   51              0.000430   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   51              0.000049   endif

FUNCTION  bm#get_bookmark_by_line()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:22
Called 16 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
   16              0.000090   return g:line_map[a:file][a:line_nr]

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/themes.vim:35
Called 70 times
Total time:   0.027944
 Self time:   0.001795

count  total (s)   self (s)
   70   0.027882   0.001733     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>71_unc_path()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 1 time
Total time:   0.000048
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000047   0.000011   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>149_get_transitioned_seperator()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 7 times
Total time:   0.006586
 Self time:   0.000329

count  total (s)   self (s)
    7              0.000012   let line = ''
    7              0.000047   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
    7              0.000005   else
    7   0.006338   0.000081     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
    7              0.000039     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
    7              0.000038     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
    7              0.000021     let line .= '%#'.a:group.'#'
    7              0.000005   endif
    7              0.000010   return line

FUNCTION  <SNR>118_ResetConcealOption()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:110
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005     if exists("b:indentLine_ConcealOptionSet") && b:indentLine_ConcealOptionSet
                                    if exists("b:indentLine_original_concealcursor")
                                        let &l:concealcursor = b:indentLine_original_concealcursor
                                    endif
                                    if exists("b:indentLine_original_conceallevel")
                                        let &l:conceallevel = b:indentLine_original_conceallevel
                                    endif
                                    let b:indentLine_ConcealOptionSet = 0
    1              0.000001     endif

FUNCTION  signature#sign#Refresh()
    Defined: ~/.config/nvim/plugged/vim-signature/autoload/signature/sign.vim:157
Called 1 time
Total time:   0.004352
 Self time:   0.000531

count  total (s)   self (s)
                              " Description: Add signs for new marks/markers and remove signs for deleted marks/markers
                              " Arguments:   Specify an argument to force a sign refresh
                            
    1   0.000232   0.000011   call s:InitializeVars(a:0 && a:1)
                              " If Signature is not enabled, return
    1              0.000003   if !b:sig_enabled | return | endif
                            
   53   0.000977   0.000056   for i in signature#mark#GetList('free', 'buf_curr')
                                " ... remove it
   52   0.002098   0.000355     call signature#sign#Remove(i, 0)
   53              0.000030   endfor
                            
                              " Add signs for marks ...
    1   0.000920   0.000013   for [l:mark, l:lnum, _] in signature#mark#GetList('used', 'buf_curr')
                                " ... if mark is not present in our b:sig_marks list or if it is present but at the wrong line,
                                " remove the old sign and add a new one
                                if (  !has_key(b:sig_marks, l:lnum) || (b:sig_marks[l:lnum] !~# l:mark) || a:0 )
                                  call signature#sign#Remove(l:mark, 0)
                                  call signature#sign#Place (l:mark, l:lnum)
                                endif
    1              0.000001   endfor
                            
    1   0.000048   0.000019   call signature#sign#ToggleDummy()
                            
                              " We do not add signs for markers as SignRefresh is executed periodically and we don't have a way to determine if the
                              " marker already has a sign or not

FUNCTION  <SNR>78_recent_buffers()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:286
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " Update list of recent buffers for the current tab. {{{1
    2              0.000005   let B = a:tab.buffers
                            
    2              0.000007   if get(s:Sets, 'recent_buffers', 10) <= 0
                                return copy(B.valid)
    2              0.000001   endif
                            
                              " if list of recent buffers is still empty, set it to current valid buffers
    2              0.000006   if empty(B.recent)
    2              0.000007     return copy(B.valid)
                              endif
                              " ensure recent buffers are valid, and all valid buffers are present
                              call filter(B.recent, 'index(B.valid, v:val) >= 0')
                              return extend(B.recent, filter(copy(B.valid), 'index(B.recent, v:val) < 0'))

FUNCTION  <SNR>165_get_mode_label()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:573
Called 2 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000021   let [labels, mode] = [s:Sets.mode_labels, s:v.tabline_mode]
    2              0.000030   if labels == 'none' || labels == 'secondary' && index(s:Sets.tabline_modes, mode) == 0 || labels != 'all' && labels != 'secondary' && labels !~ mode
    2              0.000005     return ''
                              else
                                return printf("%%#XTExtra# %s %%#XTFill# ", mode)
                              endif

FUNCTION  airline#util#has_custom_scm()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:172
Called 53 times
Total time:   0.000404
 Self time:   0.000404

count  total (s)   self (s)
   53              0.000367   return !empty(get(g:, 'airline#extensions#branch#custom_head', ''))

FUNCTION  <SNR>21_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:13
Called 1 time
Total time:   0.001312
 Self time:   0.001115

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000001     endif
    1              0.000004     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000009       for name in split(s, '\.')
    1   0.000777   0.000580         exe 'runtime! indent/' . name . '.vim'
    1              0.000498         exe 'runtime! indent/' . name . '.lua'
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 53 times
Total time:   0.003457
 Self time:   0.000761

count  total (s)   self (s)
   53   0.003412   0.000716   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 106 times
Total time:   0.007243
 Self time:   0.007243

count  total (s)   self (s)
  106              0.006850   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
  106              0.000246     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  syntastic#log#debug()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/log.vim:63
Called 8 times
Total time:   0.000175
 Self time:   0.000132

count  total (s)   self (s)
    8   0.000155   0.000111     if !s:_isDebugEnabled(a:level)
    8              0.000013         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  bm#add_bookmark()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:35
Called 4 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    4              0.000013   if !has_key(g:line_map, a:file)
    3              0.000011     let g:line_map[a:file] = {}
    3              0.000008     let g:sign_map[a:file] = {}
    4              0.000003   endif
    4              0.000011   let annotation = a:0 ==# 1 ? a:1 : ""
    4              0.000026   let entry = {'sign_idx': a:sign_idx, 'line_nr': a:line_nr, 'content': a:content, 'annotation': annotation}
    4              0.000030   let g:line_map[a:file][a:line_nr]  = entry
    4              0.000014   let g:sign_map[a:file][a:sign_idx] = a:line_nr
    4              0.000005   return entry

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 1 time
Total time:   0.002772
 Self time:   0.000312

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    1   0.000030   0.000010   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    1   0.000240   0.000028   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    1   0.000380   0.000234   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    1              0.000006     let handler = copy(s:set_path_handler)
    1              0.000003     let handler.continuation = a:continuation
    1   0.002104   0.000023     call gitgutter#async#execute(cmd, a:bufnr, handler)
    1              0.000003     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  <SNR>182_set_clean_jobs_variable()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:80
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000012   if !has_key(s:clean_jobs, a:vcs)
                                let s:clean_jobs[a:vcs] = {}
    1              0.000002   endif
    1              0.000008   let s:clean_jobs[a:vcs][a:file]=a:id

FUNCTION  bm#all_files()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:148
Called 4 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    4              0.000034   return keys(g:line_map)

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:143
Called 55 times
Total time:   0.000738
 Self time:   0.000738

count  total (s)   self (s)
   55              0.000256   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
   55              0.000043   endif
   55              0.000122   return s:has_fugitive

FUNCTION  xtabline#update_this_session()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:89
Called 1 time
Total time:   0.000119
 Self time:   0.000119

count  total (s)   self (s)
                              " {{{1
    1              0.000017   if v:this_session != "" && !exists('g:loaded_obsession') && exists('g:Xtsession')
                                exe 'mksession!' v:this_session
                                if &sessionoptions !~ 'globals'
                                  let body = readfile(v:this_session)
                                  for line in range(len(body))
                                    if match(body[line], '^let g:Xtsession') == 0
                                      let body[line] = 'let g:Xtsession = '.string(g:Xtsession)
                                      return writefile(body, v:this_session)
                                    endif
                                  endfor
                                  call insert(body, 'let g:Xtsession = '.string(g:Xtsession), 3)
                                  call writefile(body, v:this_session)
                                endif
    1              0.000002   endif

FUNCTION  coc#util#cursor()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:36
Called 4 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    4              0.000061   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  xtabline#filter_buffers()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:194
Called 1 time
Total time:   0.000599
 Self time:   0.000246

count  total (s)   self (s)
                              " Filter buffers so that only valid buffers for this tab will be shown. {{{1
    1   0.000009   0.000007   if !s:ready() | return | endif
                            
                              " Types of tab buffers:
                              "
                              " 'valid' is a list of buffer numbers that belong to the tab, either because:
                              "     - their path is valid for this tab
                              "     - tab is locked and buffers are included
                              "
                              " 'extra' are buffers that have been purposefully added by other means to the tab
                              "     - not a dynamic list, elements are manually added or removed
                              "     - they aren't handled here, they are handled at render time
                            
    1              0.000001   try
    1   0.000169   0.000010     let T = xtabline#tab#check()
                              catch /.*/
                                return
    1              0.000001   endtry
                            
    1              0.000006   let T.buffers.valid = T.locked? T.buffers.valid : []
    1              0.000005   let use_files = !empty(get(T, 'files', []))
                            
    1              0.000008   let tabPat = '^\V' . escape(getcwd(), '\')
                            
                              " /////////////////// ITERATE BUFFERS //////////////////////
                            
    4              0.000009   for buf in range(1, bufnr("$"))
    5              0.000011     if !bufexists(buf) | continue | endif
    2   0.000073   0.000016     let B = xtabline#buffer#get(buf)
                            
                                " if special, buffer will be handled by the render script
    2   0.000037   0.000020     let is_special = s:F.has_win(buf) && s:X._buffers[buf].special
                            
    2              0.000003     if is_special
                                  continue
                            
    2              0.000010     elseif !buflisted(buf) || getbufvar(buf, "&buftype") != ''
                                  " unlisted or otherwise invalid buffer, skip it
    1              0.000001       continue
                            
    1              0.000002     elseif !T.locked
                                  " if tab is locked, there's no filtering to do
                            
    1              0.000002       if !s:Sets.buffer_filtering
                                    " buffer filtering is disabled, accept all buffers
                                    let valid = v:true
                            
    1              0.000001       elseif use_files
                                    " to be accepted, buffer's path must be among valid files
                                    let valid = index(T.files, B.path) >= 0
                            
    1              0.000001       else
                                    " to be accepted, buffer's path must be valid for this tab
    1              0.000026         let valid = fnamemodify(bufname(buf), ':p') =~ tabPat
    1              0.000002       endif
                            
    1              0.000001       if valid
    1              0.000004         call add(T.buffers.valid, buf)
    1              0.000001       endif
    1              0.000001     endif
    2              0.000003   endfor
                            
                              " //////////////////////////////////////////////////////////
                            
    1   0.000109   0.000012   let T.buffers.order  = s:ordered_buffers(T)
    1   0.000026   0.000010   let T.buffers.recent = s:recent_buffers(T)
    1   0.000017   0.000012   call xtabline#persistance()

FUNCTION  <SNR>182_set_clean_variables()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:67
Called 1 time
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000016   let var=getbufvar(fnameescape(a:file), 'buffer_vcs_config', {})
    1              0.000019   if has_key(var, a:vcs) && has_key(var[a:vcs], 'dirty') && type(getbufvar(fnameescape(a:file), 'buffer_vcs_config')) == type({})
    1              0.000003     let var[a:vcs].dirty=a:val
    1              0.000001     try
    1              0.000012       call setbufvar(fnameescape(a:file), 'buffer_vcs_config', var)
    1              0.000005       unlet! b:airline_head
                                catch
    1              0.000001     endtry
    1              0.000000   endif

FUNCTION  <SNR>129_get_array()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:60
Called 229 times
Total time:   0.003793
 Self time:   0.003793

count  total (s)   self (s)
  229              0.003605     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>50_BufReadPostHook()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim:301
Called 1 time
Total time:   0.000088
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000074   0.000011     let buf = syntastic#util#fname2buf(a:fname)
    1              0.000003     if g:syntastic_check_on_open && buf > 0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
                                    if index(s:_check_stack, buf) == -1
                                        call add(s:_check_stack, buf)
                                    endif
    1              0.000000     endif

FUNCTION  <SNR>50_BufWinEnterHook()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim:346
Called 1 time
Total time:   0.000185
 Self time:   0.000091

count  total (s)   self (s)
    1   0.000121   0.000045     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000040   0.000022     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    1              0.000005     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000008         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000002         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  airline#parts#filetype()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 53 times
Total time:   0.001991
 Self time:   0.001130

count  total (s)   self (s)
   53   0.001939   0.001079   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  signature#sign#Remove()
    Defined: ~/.config/nvim/plugged/vim-signature/autoload/signature/sign.vim:38
Called 52 times
Total time:   0.001743
 Self time:   0.001558

count  total (s)   self (s)
                              " Description: Remove signs for marks/markers from the specified line number
                              " Arguments:
                              "   sign : The mark/marker whose sign is to be placed/removed/toggled
                              "   lnum : Line number from which the sign is to be removed
                              "          If sign is a marker and lnum is 0, the sign will be removed from all lines
                              "          If sign is a mark   and lnum is 0, the lnum will be found and the sign will be removed from that line
                            
                              "echom "DEBUG: sign = " . a:sign . ",  lnum = " . a:lnum
                            
                              " If Signature is not enabled, return
   52              0.000107   if !b:sig_enabled | return | endif
                            
                              " Remove sign for markers
   52   0.000527   0.000342   if signature#utils#IsValidMarker(a:sign)
                                let b:sig_markers[a:lnum] = substitute(b:sig_markers[a:lnum], "\\C" . escape( a:sign, '$^' ), "", "")
                            
                                " If there are no markers on the line, delete signs on that line
                                if b:sig_markers[a:lnum] == ""
                                  call remove(b:sig_markers, a:lnum)
                                endif
                                call s:RefreshLine(a:lnum)
                            
                              " Remove sign for marks
   52              0.000026   else
                                " For marks, if a:lnum == 0, find out the line where the mark was placed
   52              0.000061     if a:lnum == 0
   52              0.000208       let l:arr = keys(filter(copy(b:sig_marks), 'v:val =~# a:sign'))
   52              0.000098       if empty(l:arr) | return | endif
                                else
                                  let l:arr = [a:lnum]
                                endif
                                if (v:version >= 800)
                                  call assert_true(len(l:arr) == 1, "Multiple marks found where one was expected")
                                elseif (len(l:arr) != 1)
                                  echoerr "Multiple marks found where one was expected"
                                endif
                            
                                for l:lnum in l:arr
                                  " FIXME: Placed guard to avoid triggering issue #53
                                  if has_key(b:sig_marks, l:lnum)
                                    let b:sig_marks[l:lnum] = substitute(b:sig_marks[l:lnum], "\\C" . a:sign, "", "")
                                    " If there are no marks on the line, delete signs on that line
                                    if b:sig_marks[l:lnum] == ""
                                      call remove(b:sig_marks, l:lnum)
                                    endif
                                  endif
                                  call s:RefreshLine(l:lnum)
                                endfor
                              endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 53 times
Total time:   0.000574
 Self time:   0.000574

count  total (s)   self (s)
   53              0.000256   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   53              0.000041   endif
   53              0.000072   return ''

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000006   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    1              0.000001   endif

FUNCTION  <SNR>163_illuminate()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:95
Called 9 times
Total time:   0.004440
 Self time:   0.001002

count  total (s)   self (s)
    9              0.000071   if !get(b:, 'illuminate_enabled', s:enabled)
                                return
    9              0.000010   endif
                            
    9   0.000968   0.000154   call s:remove_illumination()
                            
    9   0.000817   0.000178   if s:should_illuminate_word()
    9   0.001794   0.000353     call s:match_word(s:get_cur_word())
    9              0.000011   endif
    9   0.000718   0.000174   let s:previous_match = s:get_cur_word()

FUNCTION  airline#parts#spell()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 53 times
Total time:   0.002595
 Self time:   0.002595

count  total (s)   self (s)
   53              0.001109   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   53              0.000218   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   53              0.000043   endif
   53              0.000081   return ''

FUNCTION  <SNR>78_ordered_buffers()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:271
Called 1 time
Total time:   0.000097
 Self time:   0.000035

count  total (s)   self (s)
                              " Ensure the tab's ordered buffers are valid. {{{1
    1              0.000002   let B = a:tab.buffers
                            
                              "clean up ordered/recent buffers list
    1              0.000005   call filter(B.order, 'index(B.valid, v:val) >= 0 || index(B.extra, v:val) >= 0')
    1   0.000031   0.000009   call s:F.uniq(B.extra)
                            
                              " add missing entries in ordered list
    2              0.000003   for buf in B.valid
    1   0.000047   0.000008     call s:F.add_ordered(buf, 0)
    2              0.000002   endfor
    1              0.000001   return B.order

FUNCTION  <SNR>88_SetupDebugMode()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:147
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003         if !s:debug_mode_already_setup
                                        if s:GetIniSetting('settings', 'debug') == 'true'
                                            let s:is_debug_on = s:true
                                        else
                                            let s:is_debug_on = s:false
                                        endif
                                        let s:debug_mode_already_setup = s:true
    1              0.000001         endif

FUNCTION  coc#float#get_related()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:1205
Called 14 times
Total time:   0.000368
 Self time:   0.000368

count  total (s)   self (s)
   14              0.000154   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
   14              0.000029   endfor
   14              0.000030   return 0

FUNCTION  <SNR>98_Slash()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:383
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return a:path

FUNCTION  <SNR>36_ExpandMap()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim:596
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000003   let map = a:map
    1              0.000011   let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
    1              0.000024   let map = substitute(map, '\(<Plug>([^)]*)\)', '\=maparg(submatch(1), "i")', 'g')
    1              0.000002   return map

FUNCTION  <SNR>182_valid_dir()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:50
Called 4 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    4              0.000031   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
    4              0.000003   endif
    4              0.000007   return a:dir

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 106 times
Total time:   0.005217
 Self time:   0.005217

count  total (s)   self (s)
  106              0.000740   if !exists(':CocCommand')
                                return ''
  106              0.000091   endif
  106              0.000652   let _backup = get(g:, 'coc_stl_format', '')
  106              0.000498   let is_err = (a:type  is# 'error')
  106              0.000180   if is_err
   53              0.000439     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
   53              0.000045   else
   53              0.000467     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  106              0.000093   endif
  106              0.000560   let info = get(b:, 'coc_diagnostic_info', {})
  106              0.000524   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                let lnum = printf('(L%d)', (info.lnums)[is_err ? 0 : 1])
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt.lnum
                              endif

FUNCTION  <SNR>78_Do()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:329
Called 2 times
Total time:   0.000781
 Self time:   0.000329

count  total (s)   self (s)
                              " Called by several autocommands. {{{1
    2              0.000018   if exists('g:SessionLoad') || empty(g:xtabline.Tabs) | return | endif
                            
    2              0.000005   let X = g:xtabline
    2              0.000005   let F = X.Funcs
    2              0.000004   let V = X.Vars
    2              0.000006   let N = tabpagenr() - 1
    2              0.000015   let B = bufnr(str2nr(expand('<abuf>')))
                            
                              " """""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    2              0.000004   if a:action == 'new'
                            
                                call insert(X.Tabs, xtabline#tab#new(), N)
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    2              0.000004   elseif a:action == 'bufenter'
                            
    1   0.000082   0.000012     call xtabline#buffer#update(B)
                            
    1              0.000008     if get(s:, 'last_dir', '') != getcwd()
                                  call xtabline#filter_buffers()
    1              0.000001     else
    1   0.000039   0.000020       let X.Tabs[N].buffers.recent = s:recent_buffers(X.Tabs[N])
    1              0.000001     endif
    1   0.000040   0.000011     call s:reorder_recent_buffers(B)
                            
    1              0.000007     let s:last_dir = getcwd()
                            
                                " if variable for buffer customization has been set, pick it up
    1              0.000003     if !empty(s:v.buffer_properties)
                                  let s:X.Buffers[B] = extend(copy(s:X._buffers[B]), s:v.buffer_properties)
                                  let s:v.buffer_properties = {}
    1              0.000001     endif
                            
    1   0.000046   0.000008     call xtabline#update()
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001   elseif a:action == 'bufwrite'
                            
                                call xtabline#buffer#update(B)
                                call xtabline#update()
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001   elseif a:action == 'buffilepost'
                            
                                call xtabline#buffer#reset(B)
                                call xtabline#update()
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
    1              0.000001   elseif a:action == 'filetype'
                            
    1   0.000305   0.000010     if xtabline#buffer#is_special(B)
                                  call xtabline#update()
    1              0.000001     endif
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                              elseif a:action == 'enter'
                            
                                call xtabline#tab#check_all()
                                call xtabline#tab#check()
                                call xtabline#update(1)
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                              elseif a:action == 'leave'
                            
                                let V.last_tabn = N + 1
                                let V.last_tab = X.Tabs[N]
                                let V.last_tab.active_buffer = B
                                let V.last_tab.wd_cmd = F.is_local_dir() ? 2 : F.is_tab_dir() ? 1 : 0
                                call F.set_tab_wd()
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                              elseif a:action == 'close'
                            
                                " add this tab to the list of closed tabs, but first remove any tab with
                                " the same cwd, because the tab that we're adding is more up-to-date
                                for Tx in range(len(X.closed_tabs))
                                  if X.closed_tabs[Tx].cwd ==# V.last_tab.cwd
                                    call remove(X.closed_tabs, Tx)
                                    break
                                  endif
                                endfor
                                call add(X.closed_tabs, deepcopy(V.last_tab))
                                call remove(X.Tabs, index(X.Tabs, V.last_tab))
                                call xtabline#update()
                            
                                """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                              elseif a:action == 'terminal'
                            
                                call xtabline#buffer#terminal(B)
                                call xtabline#update()
                            
    2              0.000001   endif

FUNCTION  <SNR>165_tab_mod_flag()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:484
Called 4 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
                              " Flag for the 'modified' state for a tab label. {{{1
                              "
                              " @param tabnr:  the tab number
                              " @param corner: if the flag is for the right corner
                              " Returns: the formatted flag
                            
    4              0.000021   let flag = s:Sets.indicators.modified
    8              0.000040   for buf in tabpagebuflist(a:tabnr)
    4              0.000053     if getbufvar(buf, "&mod")
                                  return a:corner ? "%#XTVisibleMod#" . flag : a:tabnr == tabpagenr()   ? "%#XTSelectMod#" . flag . ' '   : "%#XTHiddenMod#" . flag . ' '
    4              0.000006     endif
    8              0.000014   endfor
    4              0.000010   return ""

FUNCTION  airline#extensions#csv#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/csv.vim:24
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005   if &ft ==# "csv"
                                call airline#extensions#prepend_to_section('gutter', g:airline_left_alt_sep.' %{airline#extensions#csv#get_column()}')
    1              0.000000   endif

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 1 time
Total time:   0.000043
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000043   0.000013   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>118_Setup()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:317
Called 1 time
Total time:   0.000812
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000003     if &filetype ==# ""
                                    call s:InitColor()
    1              0.000001     endif
                            
    1   0.000043   0.000011     if s:Filter() && g:indentLine_enabled || exists("b:indentLine_enabled") && b:indentLine_enabled
    1   0.000712   0.000018         call s:IndentLinesEnable()
    1              0.000001     endif
                            
    1   0.000045   0.000014     if s:Filter() && g:indentLine_leadingSpaceEnabled || exists("b:indentLine_leadingSpaceEnabled") && b:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
    1              0.000001     endif

FUNCTION  10()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/autoloclist.vim:20
Called 1 time
Total time:   0.000092
 Self time:   0.000060

count  total (s)   self (s)
    1   0.000019   0.000008     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    1   0.000025   0.000007     let auto_loc_list = syntastic#util#var('auto_loc_list')
    1   0.000008   0.000005     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
    1              0.000001     else
    1              0.000006         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
    1              0.000001         endif
    1              0.000001     endif

FUNCTION  12()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/balloons.vim:19
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  syntastic#util#stamp()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim:407
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000024     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  signature#mark#GetList()
    Defined: ~/.config/nvim/plugged/vim-signature/autoload/signature/mark.vim:281
Called 2 times
Total time:   0.001828
 Self time:   0.001828

count  total (s)   self (s)
                              " Arguments: mode    = 'used'     : Returns list of [ [used marks, line no., buf no.] ]
                              "                      'free'     : Returns list of [ free marks ]
                              "            scope   = 'buf_curr' : Limits scope to current buffer i.e used/free marks in current buffer
                              "                      'buf_all'  : Set scope to all buffers i.e used/free marks from all buffers
                              "            [type]  = 'global'   : Return only global marks
                            
    2              0.000005   let l:marks_list = []
    2              0.000006   let l:line_tot = line('$')
    2              0.000005   let l:buf_curr = bufnr('%')
    2              0.000006   let l:type     = (a:0 ? a:1 : "")
                            
                              " Respect order specified in g:SignatureIncludeMarks
  106              0.000190   for i in split(b:SignatureIncludeMarks, '\zs')
  104              0.000227     if (i =~# "[A-Z]")
   52              0.000192       let [ l:buf, l:line, l:col, l:off ] = getpos( "'" . i )
   52              0.000145       let l:marks_list = add(l:marks_list, [i, l:line, l:buf])
   52              0.000074     elseif (l:type !=? "global")
   52              0.000207       let l:marks_list = add(l:marks_list, [i, line("'" .i), l:buf_curr])
  104              0.000045     endif
  106              0.000053   endfor
                            
    2              0.000004   if (a:mode ==? 'used')
    1              0.000002     if (a:scope ==? 'buf_curr')
    1              0.000098       call filter( l:marks_list, '(v:val[2] == l:buf_curr) && (v:val[1] > 0)' )
                                else
                                  call filter( l:marks_list, 'v:val[1] > 0' )
    1              0.000001     endif
    1              0.000001   else
    1              0.000002     if (a:scope ==? 'buf_all')
                                  call filter( l:marks_list, 'v:val[1] == 0' )
    1              0.000001     else
    1              0.000075       call filter( l:marks_list, '(v:val[1] == 0) || (v:val[2] != l:buf_curr)' )
    1              0.000001     endif
    1              0.000041     call map( l:marks_list, 'v:val[0]' )
    2              0.000001   endif
                            
    2              0.000003   return l:marks_list

FUNCTION  xtabline#persistance()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:58
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                              " {{{1
    1              0.000004   if !get(s:Sets, 'persistance', 0) | return | endif
                              let session = 'let g:xtabline = get(g:, "xtabline", {})'.' | if exists("*xtabline#session_loaded")'.' | let g:xtabline.Tabs = '.string(s:X.Tabs).' | let g:xtabline.Buffers = '.string(s:X.Buffers).' | let g:xtabline.pinned_buffers = '.string(s:X.pinned_buffers).' | call xtabline#session_loaded()'.' | endif'
                              if exists('g:loaded_obsession')
                                if !exists('g:obsession_append')
                                  let g:obsession_append = [session]
                                else
                                  for i in g:obsession_append
                                    if match(i, "^let g:xtabline") >= 0
                                      call remove(g:obsession_append, i)
                                      break
                                    endif
                                  endfor
                                  call add(g:obsession_append, session)
                                endif
                              else
                                let g:Xtsession = session
                              endif

FUNCTION  101()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim:27
Called 2 times
Total time:   0.000058
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000057   0.000019     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  102()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim:31
Called 1 time
Total time:   0.000363
 Self time:   0.000050

count  total (s)   self (s)
    1   0.000024   0.000009     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    1   0.000016   0.000007     let old_signs = copy(self._bufSignIds())
    1   0.000032   0.000005     if self.enabled()
    1              0.000002         if !s:setup_done
    1   0.000198   0.000006             call self._setup()
    1              0.000002             let s:setup_done = 1
    1              0.000002             lockvar s:setup_done
    1              0.000000         endif
                            
    1   0.000062   0.000008         call self._signErrors(a:loclist)
    1              0.000001     endif
    1   0.000022   0.000006     call self._removeSigns(old_signs)

FUNCTION  103()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim:52
Called 1 time
Total time:   0.000192
 Self time:   0.000192

count  total (s)   self (s)
    1              0.000003     if has('signs')
    1              0.000015         if !hlexists('SyntasticErrorSign')
    1              0.000019             highlight link SyntasticErrorSign error
    1              0.000001         endif
    1              0.000009         if !hlexists('SyntasticWarningSign')
    1              0.000015             highlight link SyntasticWarningSign todo
    1              0.000001         endif
    1              0.000009         if !hlexists('SyntasticStyleErrorSign')
    1              0.000009             highlight link SyntasticStyleErrorSign SyntasticErrorSign
    1              0.000001         endif
    1              0.000009         if !hlexists('SyntasticStyleWarningSign')
    1              0.000009             highlight link SyntasticStyleWarningSign SyntasticWarningSign
    1              0.000001         endif
    1              0.000009         if !hlexists('SyntasticStyleErrorLine')
    1              0.000016             highlight link SyntasticStyleErrorLine SyntasticErrorLine
    1              0.000001         endif
    1              0.000009         if !hlexists('SyntasticStyleWarningLine')
    1              0.000016             highlight link SyntasticStyleWarningLine SyntasticWarningLine
    1              0.000001         endif
                            
                                    " define the signs used to display syntax and style errors/warns
    1              0.000013         execute 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
    1              0.000008         execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
    1              0.000007         execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
    1              0.000007         execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
    1              0.000001     endif

FUNCTION  104()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim:86
Called 1 time
Total time:   0.000054
 Self time:   0.000051

count  total (s)   self (s)
    1              0.000002     let loclist = a:loclist
    1   0.000008   0.000005     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
    1              0.000001     endif

FUNCTION  105()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim:119
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000003     if has('signs')
    1              0.000004         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
    1              0.000001         endfor
    1              0.000001     endif

FUNCTION  bm_sign#define_highlights()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm_sign.vim:29
Called 1 time
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    1              0.000051   highlight BookmarkSignDefault ctermfg=33 ctermbg=NONE
    1              0.000017   highlight BookmarkAnnotationSignDefault ctermfg=28 ctermbg=NONE
    1              0.000013   highlight BookmarkLineDefault ctermfg=232 ctermbg=33
    1              0.000013   highlight BookmarkAnnotationLineDefault ctermfg=232 ctermbg=28
    1              0.000010   highlight default link BookmarkSign BookmarkSignDefault
    1              0.000010   highlight default link BookmarkAnnotationSign BookmarkAnnotationSignDefault
    1              0.000009   highlight default link BookmarkLine BookmarkLineDefault
    1              0.000009   highlight default link BookmarkAnnotationLine BookmarkAnnotationLineDefault

FUNCTION  <SNR>88_JoinArgs()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:238
Called 1 time
Total time:   0.000777
 Self time:   0.000439

count  total (s)   self (s)
    1              0.000007         let safeArgs = []
   13              0.000046         for arg in a:args
   12   0.000661   0.000323             let safeArgs = safeArgs + [s:SanitizeArg(arg)]
   13              0.000028         endfor
    1              0.000019         return join(safeArgs, ' ')

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/po.vim:64
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000004   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * call s:autocmd_handler()
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    1              0.000000   endif

FUNCTION  <SNR>165_reuse_last_tabline()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:617
Called 2 times
Total time:   0.000777
 Self time:   0.000171

count  total (s)   self (s)
                              " Check if it's time to update the tabline or not. {{{1
                              " Returns: bool
    2              0.000014   let currentbuf = winbufnr(0)
                            
                              " Update if flag is set, or buffer has been modified
    2              0.000026   if exists('s:v.time_to_update')|| !has_key(s:last_modified_state, currentbuf)|| &modified != s:last_modified_state[currentbuf]
                            
    2              0.000007     if s:v.queued_update == 2
    1              0.000002       let s:v.queued_update = 1
    1   0.000608   0.000009       call xtabline#filter_buffers()
    1              0.000002     else
    1   0.000024   0.000018       let T = s:T()
    1              0.000008       if exists('T.refilter')
                                    unlet T.refilter
                                    call xtabline#filter_buffers()
    1              0.000002       endif
    2              0.000002     endif
    2              0.000022     let s:last_modified_state[currentbuf] = &modified
    2              0.000010     silent! unlet s:v.time_to_update
    2              0.000007     return v:false
                              endif
                              return v:true

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 1 time
Total time:   0.000150
 Self time:   0.000029

count  total (s)   self (s)
    1   0.000077   0.000020   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    1   0.000073   0.000009   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:136
Called 3 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    3              0.000063   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
    3              0.000096   return match(a:name, pat) > -1

FUNCTION  113()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:69
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
                              " Return full path. {{{1
    2              0.000021   let path = expand(a:path)
    2              0.000008   let path = empty(path) ? a:path : path "expand can fail
    2              0.000012   return fnamemodify(path, ':p')

FUNCTION  114()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:86
Called 2 times
Total time:   0.000085
 Self time:   0.000041

count  total (s)   self (s)
                              " Return full directory with trailing slash. {{{1
    2   0.000075   0.000032   let path = self.fullpath(a:path)
    2              0.000007   return path[-1:] != '/' ? path.'/' : path

FUNCTION  116()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:109
Called 1 time
Total time:   0.000039
 Self time:   0.000030

count  total (s)   self (s)
                              " Add a buffer to the Tab.buffers.order list. {{{1
                            
    1              0.000003   let b    = a:buf          " the buffer number that must be added
    1   0.000017   0.000008   let bufs = s:oB()         " the list of ordered buffers
    1              0.000003   let i    = index(bufs, b) " the index of the buffer in the list
                            
                              " if the buffer goes first, remove it from the list if present
    1              0.000005   if i >= 0 && a:put_first | call remove(bufs, i) | endif
                            
                              " if the buffer doesn't go first, only add it if not present
    1              0.000003   if a:put_first | call insert(bufs, b, 0)
    1              0.000004   elseif i < 0   | call add(bufs, b)
    1              0.000001   endif

FUNCTION  117()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:126
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                              " Make sure an element appears only once in the list. {{{1
    1              0.000006   let [ i, max ] = [ 0, len(a:list)-2 ]
    1              0.000002   while i <= max
                                let extra = index(a:list, a:list[i], i+1)
                                if extra > 0
                                  call remove(a:list, extra)
                                  let max -= 1
                                else
                                  let i += 1
                                endif
    1              0.000001   endwhile
    1              0.000002   return a:list

FUNCTION  css_color#init()
    Defined: ~/.config/nvim/plugged/vim-css-color/autoload/css_color.vim:311
Called 1 time
Total time:   0.001388
 Self time:   0.000097

count  total (s)   self (s)
    1              0.000010 	let new_type = index( s:type, a:type )
    1              0.000010 	let old_type = index( s:pat_for_type, get( b:, 'css_color_pat', '$^' ) )
                            
    1              0.000010 	let b:css_color_pat = s:pat_for_type[ max( [ old_type, new_type ] ) ]
    1              0.000023 	let b:css_color_grp = extend( get( b:, 'css_color_grp', [] ), split( a:groups, ',' ), 0 )
    1              0.000004 	let b:css_color_hi  = {}
    1              0.000003 	let b:css_color_syn = {}
    1              0.000003 	let b:css_color_off = 1
                            
    1   0.001307   0.000016 	call css_color#enable()
                            
    1              0.000004 	if a:keywords != 'none'
                            		exe 'syntax include syntax/colornames/'.a:keywords.'.vim'
                            		call extend( s:color_bright, b:css_color_hi )
    1              0.000001 	endif

FUNCTION  airline#util#winwidth()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:19
Called 484 times
Total time:   0.008204
 Self time:   0.008204

count  total (s)   self (s)
  484              0.002646   let nr = get(a:000, 0, 0)
  484              0.001865   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  484              0.000472   else
  484              0.001656     return winwidth(nr)
                              endif

FUNCTION  signature#sign#ToggleDummy()
    Defined: ~/.config/nvim/plugged/vim-signature/autoload/signature/sign.vim:198
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                              " Description: Places a dummy sign to prevent flickering of the gutter when the mark is moved or the line containing
                              "              a mark/marker is deleted and then the delete is undone
                              " Arguments: (optional) 0 : force remove
                              "                       1 : force place
                            
    1              0.000008   let l:place  = a:0 ?  a:1 : (len(b:sig_marks) + len(b:sig_markers) == 1) && !b:sig_DummyExists
    1              0.000005   let l:remove = a:0 ? !a:1 : (len(b:sig_marks) + len(b:sig_markers) == 0) &&  b:sig_DummyExists
                            
    1              0.000001   if (l:place)
                                sign define Signature_Dummy
                                execute 'sign place 666 line=1 name=Signature_Dummy buffer=' . bufnr('%')
                                let b:sig_DummyExists = 1
    1              0.000001   elseif (l:remove)
                                silent! execute 'sign unplace 666 buffer=' . bufnr('%')
                                let b:sig_DummyExists = 0
    1              0.000001   endif

FUNCTION  <SNR>159_resolve_parenthesis_from_config()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:39
Called 1 time
Total time:   0.000257
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000256   0.000024 	return s:resolve_parenthesis_with(['', 0, '', a:config.contains_prefix, '', a:config.operators], a:config.parentheses_options)

FUNCTION  airline#util#doautocmd()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:176
Called 4 times
Total time:   0.000800
 Self time:   0.000239

count  total (s)   self (s)
    4              0.000041   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
    4              0.000006   endif
    4   0.000735   0.000174   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  illuminate#on_cursor_moved()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:12
Called 14 times
Total time:   0.009177
 Self time:   0.001704

count  total (s)   self (s)
   14   0.001520   0.000266   if !s:should_illuminate_file()
                                return
   14              0.000016   endif
                            
   14   0.001273   0.000284   if s:previous_match !=# s:get_cur_word()
    9   0.000972   0.000182     call s:remove_illumination()
    5              0.000273   elseif get(g:, 'Illuminate_highlightUnderCursor', 1) == 0 || hlexists('illuminatedCurWord')
                                call s:remove_illumination()
                                call s:illuminate()
                                return
    5              0.000005   else
    5              0.000007     return
    9              0.000011   endif
                            
                              " Any delay at or below 17 milliseconds gets counted as no delay
    9              0.000087   if !has('timers') || g:Illuminate_delay <= 17
    9   0.004621   0.000181     call s:illuminate()
    9              0.000020     return
                              endif
                            
                              if exists('s:timer_id') && s:timer_id > -1
                                call timer_stop(s:timer_id)
                              endif
                            
                              let s:timer_id = timer_start(g:Illuminate_delay, function('s:illuminate'))

FUNCTION  36()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/cursor.vim:15
Called 2 times
Total time:   0.000059
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000058   0.000014     return syntastic#util#var('echo_current_error')

FUNCTION  37()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/cursor.vim:19
Called 1 time
Total time:   0.000051
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000037   0.000010     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    1              0.000001     endif

FUNCTION  <SNR>165_tab_hi()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:405
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                              " The highlight group for the tab label {{{1
    2              0.000021   let special = s:Sets.special_tabs && s:is_special(s:tab_buffer(a:tnr))
    2              0.000016   return a:tnr == tabpagenr() ? special ? 'Special' : 'Select' : 'Hidden'

FUNCTION  121()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:177
Called 2 times
Total time:   0.000315
 Self time:   0.000315

count  total (s)   self (s)
                              " A shortened CWD, 'h' is the number of non-collapsed directory names. {{{1
    2              0.000030   let path = a:0 ? a:1 : getcwd()
                            
    2              0.000005   if !a:h
                                return fnamemodify(path, ":t")
    2              0.000003   else
    2              0.000036     let H = fnamemodify(path, ":~")
    2              0.000015     if s:v.winOS | let H = tr(H, '\', '/')
    2              0.000002   endif
                            
    2              0.000028   let splits = split(H, '/')
    2              0.000012   if len(splits) > a:h
    2              0.000032     let [ head, tail ] = [splits[:-(a:h+1)], splits[-(a:h):]]
    2              0.000083     call map(head, "substitute(v:val, '\\(.\\).*', '\\1', '')")
    2              0.000025     let H = join(head + tail, '/')
    2              0.000003   endif
    2              0.000005   if s:v.winOS
                                let H = tr(H, '/', '\')
    2              0.000002   endif
    2              0.000005   return H

FUNCTION  122()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:201
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
                              " A shortened file path, see :h xtabline-paths {{{1
    1              0.000001   if !a:h
                                return fnamemodify(bufname(a:bnr), ":t")
    1              0.000003   elseif empty(bufname(a:bnr))
                                return ''
    1              0.000001   endif
                            
    1              0.000011   let H = fnamemodify(bufname(a:bnr), ":~:.")
                            
    1              0.000001   if s:v.winOS
                                let H = tr(H, '\', '/')
    1              0.000001   else
    1              0.000003     let is_root = H[:0] == '/'
    1              0.000001   endif
                            
    1              0.000005   if H !~ '/' | return H | endif
                            
                              let splits  = split(H, '/')
                            
                              if a:h < 0
                                let h = min([len(splits) - 1, abs(a:h)])
                                let head = splits[:-2]
                                let tail = splits[-1:]
                                return join(head[-h:] + tail, s:v.winOS ? '\' : '/')
                              else
                                let h = min([len(splits), abs(a:h)])
                                let head = splits[:-(h+1)]
                                let tail = splits[-h:]
                              endif
                              call map(head, "substitute(v:val, '\\(.\\).*', '\\1', '')")
                              let H = join(head + tail, '/')
                              if s:v.winOS
                                let H = tr(H, '/', '\')
                              elseif is_root
                                let H = '/' . H
                              endif
                              return H

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:215
Called 5 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    5              0.000035   let path = substitute(a:path, '[\/]$', '', '') . '/'
    5              0.000049   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  gitgutter#async#available()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   return s:available

FUNCTION  <SNR>150_get_section()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 11 times
Total time:   0.000608
 Self time:   0.000483

count  total (s)   self (s)
   11              0.000033   if has_key(s:section_truncate_width, a:key)
    8   0.000149   0.000069     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
    8              0.000004     endif
   11              0.000006   endif
   11              0.000026   let spc = g:airline_symbols.space
   11              0.000047   if !exists('g:airline_section_{a:key}')
                                return ''
   11              0.000005   endif
   11   0.000164   0.000119   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   11              0.000083   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   11              0.000046   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>149_section_is_empty()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 9 times
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    9              0.000016   let start=1
                            
                              " do not check for inactive windows or the tabline
    9              0.000019   if a:self._context.active == 0
                                return 0
    9              0.000028   elseif get(a:self._context, 'tabline', 0)
                                return 0
    9              0.000005   endif
                            
                              " only check, if airline#skip_empty_sections == 1
    9              0.000027   if get(g:, 'airline_skip_empty_sections', 0) == 0
    9              0.000008     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  40()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/highlighting.vim:28
Called 2 times
Total time:   0.000052
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000051   0.000015     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  41()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/highlighting.vim:33
Called 1 time
Total time:   0.000257
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000030   0.000005     if self.enabled()
    1   0.000022   0.000009         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    1   0.000152   0.000006         call self._reset()
    1              0.000003         let buf = bufnr('')
    1   0.000016   0.000013         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    1              0.000002         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
    1              0.000001         endfor
    1              0.000001     endif

FUNCTION  44()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/highlighting.vim:94
Called 1 time
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
   21              0.000051     for match in getmatches()
   20              0.000041         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
   20              0.000008         endif
   21              0.000010     endfor

FUNCTION  45()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim:10
Called 107 times
Total time:   0.007706
 Self time:   0.007706

count  total (s)   self (s)
  107              0.002705     let newObj = copy(self)
                            
  107              0.000972     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
  107              0.000430     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
  107              0.000201     endfor
                            
  107              0.000427     let newObj._rawLoclist = llist
  107              0.000273     let newObj._name = ''
  107              0.000416     let newObj._owner = bufnr('')
  107              0.000238     let newObj._sorted = 0
  107              0.000441     let newObj._columns = g:syntastic_cursor_columns
                            
  107              0.000221     return newObj

FUNCTION  46()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim:30
Called 107 times
Total time:   0.014716
 Self time:   0.005699

count  total (s)   self (s)
  107              0.000717     let buf = a:0 ? a:1 : bufnr('')
  107   0.003171   0.001860     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
  107              0.000856     if type(loclist) != type({}) || empty(loclist)
  107              0.000360         unlet! loclist
  107   0.009081   0.001375         let loclist = g:SyntasticLoclist.New([])
  107              0.000105     endif
  107              0.000196     return loclist

FUNCTION  49()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim:56
Called 5 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    5              0.000013     return empty(self._rawLoclist)

FUNCTION  <SNR>98_CeilingDirectories()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:263
Called 5 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
    5              0.000015   if !exists('s:ceiling_directories')
    1              0.000003     let s:ceiling_directories = []
    1              0.000002     let resolve = 1
    2              0.000015     for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
    1              0.000002       if empty(dir)
    1              0.000002         let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
    1              0.000001       endif
    2              0.000002     endfor
    5              0.000003   endif
    5              0.000022   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  <SNR>159_resolve_parenthesis_with()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:13
Called 4 times
Total time:   0.000953
 Self time:   0.000919

count  total (s)   self (s)
    4              0.000036 	let [paren, contained, containedin, contains_prefix, contains, op] = a:init_state
    4              0.000054 	let p = (type(a:p) == type([])) ? ((len(a:p) == 3) ? printf('start=#%s# step=%s end=#%s#', a:p[0], op, a:p[-1]) : printf('start=#%s# end=#%s#', a:p[0], a:p[-1])) : a:p "NOTE: preprocess the old style parentheses config
                            
    4              0.000202 	let ls = split(p, '\v%(%(start|step|end)\=(.)%(\1@!.)*\1[^ ]*|\w+%(\=[^ ]*)?) ?\zs', 0)
   14              0.000025 	for s in ls
   10              0.000203 		let [k, v] = [matchstr(s, '^[^=]\+\ze\(=\|$\)'), matchstr(s, '^[^=]\+=\zs.*')]
   10              0.000019 		if k == 'step'
                            			let op = s:trim(v)
   10              0.000017 		elseif k == 'contains_prefix'
                            			let contains_prefix = s:trim(v)
   10              0.000013 		elseif k == 'contains'
                            			let contains = s:concat([contains, s:trim(v)])
   10              0.000013 		elseif k == 'containedin'
    1   0.000055   0.000021 			let containedin = s:concat([containedin, s:trim(v)])
    9              0.000012 		elseif k == 'contained'
                            			let contained = 1
    9              0.000007 		else
    9              0.000024 			let paren .= s
   10              0.000007 		endif
   14              0.000015 	endfor
    4              0.000026 	let rst = [paren, contained, containedin, contains_prefix, contains, op]
                            	"echom json_encode(rst)
    4              0.000008 	return rst

FUNCTION  137()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  139()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 8 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    8              0.000036   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>131_is_branch_empty()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 53 times
Total time:   0.000661
 Self time:   0.000661

count  total (s)   self (s)
   53              0.000615   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  xtabline#tab#check_all()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/tab.vim:94
Called 2 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
                              " Create or remove tab dicts if necessary.
    2              0.000014   let Tabs = g:xtabline.Tabs
    2              0.000038   while len(Tabs) < tabpagenr("$") | call add(Tabs, xtabline#tab#new()) | endwhile
    2              0.000021   while len(Tabs) > tabpagenr('$') | call remove(Tabs, -1)              | endwhile
    2              0.000013   if !has_key(s:v, 'last_tab')
                                let s:v.last_tab = s:T()
    2              0.000002   endif

FUNCTION  <SNR>135_update_git_branch()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:87
Called 53 times
Total time:   0.012075
 Self time:   0.002855

count  total (s)   self (s)
   53   0.001681   0.000795   call airline#util#ignore_next_focusgain()
   53   0.001326   0.000606   if airline#util#has_fugitive()
   53   0.008344   0.000729     call s:config_fugitive_branch()
                              elseif airline#util#has_gina()
                                call s:config_gina_branch()
                              else
                                let s:vcs_config['git'].branch = ''
                                return
   53              0.000047   endif

FUNCTION  <SNR>75_add_missing_signs()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:479
Called 2 times
Total time:   0.000054
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000035   0.000023   let bookmarks = values(bm#all_bookmarks_by_line(a:file))
    2              0.000005   for bookmark in bookmarks
                                call bm_sign#add_at(a:file, bookmark['sign_idx'], bookmark['line_nr'], bookmark['annotation'] !=# "")
    2              0.000002   endfor

FUNCTION  BookmarkSave()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:201
Called 1 time
Total time:   0.003158
 Self time:   0.000552

count  total (s)   self (s)
    1   0.001038   0.000119   call s:refresh_line_numbers()
    1   0.000838   0.000032   if (bm#total_count() > 0 || (!g:bookmark_save_per_working_dir && !g:bookmark_manage_per_buffer))
    1   0.000910   0.000028     let serialized_bookmarks = bm#serialize()
    1              0.000314     call writefile(serialized_bookmarks, a:target_file)
    1              0.000015     if (!a:silent)
                                  echo "All bookmarks saved"
    1              0.000004     endif
                              elseif (g:bookmark_save_per_working_dir || g:bookmark_manage_per_buffer)
                                call delete(a:target_file) " remove file, if no bookmarks
    1              0.000003   endif

FUNCTION  50()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim:60
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003     if !exists('self._stamp')
    1              0.000002         let self._stamp = []
    1              0.000001         return 0
                                endif
                                return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  51()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim:68
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003     return copy(self._rawLoclist)

FUNCTION  55()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/loclist.vim:84
Called 106 times
Total time:   0.013872
 Self time:   0.013872

count  total (s)   self (s)
  106              0.000532     if !exists('self._stl_format')
  106              0.000314         let self._stl_format = ''
  106              0.000098     endif
  106              0.000346     if !exists('self._stl_flag')
  106              0.000248         let self._stl_flag = ''
  106              0.000086     endif
                            
  106              0.000456     if g:syntastic_stl_format !=# self._stl_format
  106              0.000396         let self._stl_format = g:syntastic_stl_format
                            
  106              0.000353         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
  106              0.000132         else
  106              0.000263             let self._stl_flag = ''
  106              0.000101         endif
  106              0.000081     endif
                            
  106              0.000264     return self._stl_flag

FUNCTION  syntastic#util#rawVar()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim:165
Called 8 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    8              0.000077     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  <SNR>118_InitColor()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:35
Called 2 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
    2              0.000005     if !g:indentLine_setColors
                                    return
    2              0.000001     endif
                            
    2              0.000005     let default_term_bg = "NONE"
    2              0.000004     let default_gui_bg  = "NONE"
    2              0.000005     if &background ==# "light"
                                    let default_term_fg = 249
                                    let default_gui_fg = "Grey70"
    2              0.000002     else
    2              0.000003         let default_term_fg = 239
    2              0.000003         let default_gui_fg = "Grey30"
    2              0.000001     endif
                            
    2              0.000005     if g:indentLine_defaultGroup != ""
                                    let default_id = synIDtrans(hlID(g:indentLine_defaultGroup))
                                    let default_term_fg = synIDattr(default_id, "fg", "cterm") == "" ? default_term_fg :  synIDattr(default_id, "fg", "cterm")
                                    let default_term_bg = synIDattr(default_id, "bg", "cterm") == "" ? default_term_bg :  synIDattr(default_id, "bg", "cterm")
                                    let default_gui_fg = synIDattr(default_id, "fg", "gui") == "" ? default_gui_fg :  synIDattr(default_id, "fg", "gui")
                                    let default_gui_bg = synIDattr(default_id, "bg", "gui") == "" ? default_gui_bg :  synIDattr(default_id, "bg", "gui")
    2              0.000001     endif
                            
    2              0.000007     if !exists("g:indentLine_color_term")
                                    let term_color = default_term_fg
    2              0.000001     else
    2              0.000004         let term_color = g:indentLine_color_term
    2              0.000001     endif
                            
    2              0.000006     if !exists("g:indentLine_bgcolor_term")
    2              0.000004         let term_bgcolor = default_term_bg
                                else
                                    let term_bgcolor = g:indentLine_bgcolor_term
    2              0.000002     endif
                            
    2              0.000005     if !exists("g:indentLine_color_gui")
    2              0.000004         let gui_color = default_gui_fg
                                else
                                    let gui_color = g:indentLine_color_gui
    2              0.000001     endif
                            
    2              0.000005     if !exists("g:indentLine_bgcolor_gui")
    2              0.000004         let gui_bgcolor = default_gui_bg
                                else
                                    let gui_bgcolor = g:indentLine_bgcolor_gui
    2              0.000001     endif
                            
    2              0.000051     execute "highlight Conceal cterm=NONE ctermfg=" . term_color . " ctermbg=" . term_bgcolor
    2              0.000033     execute "highlight Conceal gui=NONE guifg=" . gui_color .  " guibg=" . gui_bgcolor
                            
    2              0.000004     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
    2              0.000001     endif

FUNCTION  <SNR>182_nvim_output_handler()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:232
Called 4 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    4              0.000013     if a:event == 'stdout' || a:event == 'stderr'
    4              0.000015       let self.buf .=  join(a:data)
    4              0.000003     endif

FUNCTION  <SNR>140_check_mixed_indent_file()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 1 time
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000009   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000006   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    1              0.000001   else
    1              0.000002     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000026   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000008   let indent_spc  = search(head_spc, 'nw')
    1              0.000003   if indent_tabs > 0 && indent_spc > 0
    1              0.000006     return printf("%d:%d", indent_tabs, indent_spc)
                              else
                                return ''
                              endif

FUNCTION  144()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 1 time
Total time:   0.011396
 Self time:   0.001060

count  total (s)   self (s)
    1              0.000002   let side = 1
    1              0.000001   let line = ''
    1              0.000001   let i = 0
    1              0.000003   let length = len(self._sections)
    1              0.000001   let split = 0
    1              0.000002   let is_empty = 0
    1              0.000002   let prev_group = ''
                            
   10              0.000017   while i < length
    9              0.000026     let section = self._sections[i]
    9              0.000019     let group = section[0]
    9              0.000018     let contents = section[1]
    9              0.000014     let pgroup = prev_group
    9   0.000223   0.000103     let prev_group = airline#builder#get_prev_group(self._sections, i)
    9              0.000033     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
    9              0.000042     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
    9              0.000034     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
    9              0.000006     endif
    9              0.000010     if is_empty
                                  let prev_group = pgroup
    9              0.000004     endif
    9   0.000239   0.000093     let is_empty = s:section_is_empty(self, contents)
                            
    9              0.000008     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
    9              0.000004     endif
                            
    9              0.000012     if group == ''
                                  let line .= contents
    9              0.000012     elseif group == '|'
    1              0.000001       let side = 0
    1              0.000002       let line .= contents
    1              0.000001       let split = 1
    8              0.000004     else
    8              0.000011       if prev_group == ''
    1              0.000004         let line .= '%#'.group.'#'
    7              0.000007       elseif split
    1              0.000001         if !is_empty
    1   0.000961   0.000014           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    1              0.000001         endif
    1              0.000002         let split = 0
    6              0.000003       else
    6              0.000006         if !is_empty
    6   0.008693   0.000079           let line .= s:get_seperator(self, prev_group, group, side)
    6              0.000004         endif
    8              0.000004       endif
    8   0.000638   0.000129       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
    9              0.000006     endif
                            
    9              0.000018     let i = i + 1
   10              0.000010   endwhile
                            
    1              0.000002   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    1              0.000001   endif
    1              0.000003   return line

FUNCTION  <SNR>140_check_mixed_indent()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 1 time
Total time:   0.002829
 Self time:   0.002829

count  total (s)   self (s)
    1              0.000005   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000002   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    1              0.000002   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
    1              0.000001   else
    1              0.002806     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  <SNR>88_n2s()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:512
Called 4 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    4              0.000063         return substitute(printf('%d', a:number), ',', '.', '')

FUNCTION  bm#all_lines()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:123
Called 9 times
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    9              0.000049   if !has_key(g:line_map, a:file)
                                return []
    9              0.000009   endif
    9              0.000053   return keys(g:line_map[a:file])

FUNCTION  bm#all_bookmarks_by_line()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:116
Called 5 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    5              0.000072   if !has_key(g:line_map, a:file)
    2              0.000003     return {}
    3              0.000006   endif
    3              0.000018   return g:line_map[a:file]

FUNCTION  bm#del_bookmark_at_line()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:102
Called 4 times
Total time:   0.000112
 Self time:   0.000095

count  total (s)   self (s)
    4   0.000053   0.000036   let bookmark = bm#get_bookmark_by_line(a:file, a:line_nr)
    4              0.000012   unlet g:line_map[a:file][a:line_nr]
    4              0.000014   unlet g:sign_map[a:file][bookmark['sign_idx']]
    4              0.000012   if empty(g:line_map[a:file])
    3              0.000007     unlet g:line_map[a:file]
    3              0.000005     unlet g:sign_map[a:file]
    4              0.000003   endif

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 1 time
Total time:   0.001190
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000003   let winnr = a:context.winnr
    1              0.000002   let active = a:context.active
                            
    1   0.000016   0.000011   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    1   0.000375   0.000012     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    1              0.000001   endif
                            
    1   0.000065   0.000016   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    1   0.000012   0.000008   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    1   0.000702   0.000011     call s:build_sections(a:builder, a:context, s:layout[1])
    1              0.000001   endif
                            
    1              0.000001   return 1

FUNCTION  <SNR>84_template()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/buffer.vim:17
Called 1 time
Total time:   0.000145
 Self time:   0.000046

count  total (s)   self (s)
                              " Template for buffer entry.
    1              0.000024   let buf = { 'name':    '', 'path':    fnamemodify(bufname(a:nr), ':p'), 'icon':    '',}
                            
    1              0.000003   if !has_key(buf, 'special')
    1   0.000114   0.000015     call extend(buf, s:is_special(a:nr))
    1              0.000001   endif
    1              0.000001   return buf

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:189
Called 2 times
Total time:   0.000082
 Self time:   0.000060

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
    2   0.000078   0.000056   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  bm#location_list()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:130
Called 2 times
Total time:   0.001027
 Self time:   0.000763

count  total (s)   self (s)
    2   0.000062   0.000039   let files = sort(bm#all_files())
    2              0.000008   let locations = []
    8              0.000022   for file in files
    6   0.000295   0.000122     let line_nrs = sort(bm#all_lines(file), "bm#compare_lines")
   14              0.000044     for line_nr in line_nrs
    8   0.000216   0.000148       let bookmark = bm#get_bookmark_by_line(file, line_nr)
    8              0.000103       let content = bookmark['annotation'] !=# '' ? "Annotation: ". bookmark['annotation'] : (bookmark['content'] !=# ""   ? bookmark['content']   : "empty line")
    8              0.000085       call add(locations, file .":". line_nr .":". content)
   14              0.000024     endfor
    8              0.000010   endfor
    2              0.000005   return locations

FUNCTION  <SNR>85_DevIconsGetArtifactFix()
    Defined: ~/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:545
Called 108 times
Total time:   0.001543
 Self time:   0.001543

count  total (s)   self (s)
  108              0.000357   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
  108              0.000099   else
  108              0.000277     let artifactFix = ''
  108              0.000101   endif
                            
  108              0.000244   return artifactFix

FUNCTION  airline#update_tabline()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline.vim:290
Called 18 times
Total time:   0.000363
 Self time:   0.000363

count  total (s)   self (s)
   18              0.000192   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   18              0.000033   endif

FUNCTION  <SNR>154_setup_path()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 1 time
Total time:   0.002851
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000054   0.000011   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    1   0.002794   0.000022   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  airline#highlighter#exec()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:219
Called 147 times
Total time:   0.118059
 Self time:   0.035931

count  total (s)   self (s)
  147              0.000577     if pumvisible()
                                  return
  147              0.000179     endif
  147              0.000637     let colors = a:colors
  147              0.000641     if len(colors) == 4
   35              0.000184       call add(colors, '')
  147              0.000155     endif
                                " colors should always be string values
  147              0.006894     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  147              0.000469     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  147              0.000241     endif
  147   0.067190   0.003688     let old_hi = airline#highlighter#get_highlight(a:group)
  147              0.002920     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  147   0.008348   0.002805     let colors = s:CheckDefined(colors)
  147   0.006634   0.002579     if old_hi != new_hi || !s:hl_group_exists(a:group)
   37   0.009860   0.000832       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   37              0.000086       try
   37              0.001014         exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
   37              0.000086       endtry
   37              0.000266       if has_key(s:hl_groups, a:group)
   37              0.000246         let s:hl_groups[a:group] = colors
   37              0.000046       endif
  147              0.000155     endif

FUNCTION  <SNR>129_CheckDefined()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:108
Called 147 times
Total time:   0.005542
 Self time:   0.005542

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
  147              0.001301     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  147              0.000184     endif
  147              0.001226     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  147              0.000462       return a:colors
                                endif
                            
                                for val in a:colors
                                  if !empty(val) && val !=# 'NONE'
                                    return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>159_trim()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:5
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000017 	return substitute(a:s, '\v^\s*(.{-})\s*$', '\1', '')

FUNCTION  <SNR>75_lazy_init()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:386
Called 1 time
Total time:   0.000747
 Self time:   0.000747

count  total (s)   self (s)
    1              0.000008   if g:bm_has_any ==# 0
    1              0.000019     augroup bm_refresh
    1              0.000624       autocmd!
    1              0.000047       autocmd ColorScheme * call bm_sign#define_highlights()
    1              0.000011       autocmd BufLeave * call s:refresh_line_numbers()
    1              0.000004     augroup END
    1              0.000023     let g:bm_has_any = 1
    1              0.000004   endif

FUNCTION  106()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/signs.vim:129
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003     if !exists('b:syntastic_private_sign_ids')
    1              0.000002         let b:syntastic_private_sign_ids = []
    1              0.000001     endif
    1              0.000002     return b:syntastic_private_sign_ids

FUNCTION  FugitiveGitDir()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:17
Called 53 times
Total time:   0.004681
 Self time:   0.004681

count  total (s)   self (s)
   53              0.000160   if v:version < 704
                                return ''
   53              0.000374   elseif !a:0 || type(a:1) == type(0) && a:1 < 0
   53              0.000204     if exists('g:fugitive_event')
                                  return g:fugitive_event
   53              0.000050     endif
   53              0.000317     let dir = get(b:, 'git_dir', '')
   53              0.001334     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
   53              0.000800     elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                  return b:git_dir
   53              0.000050     endif
   53              0.000433     return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type(0)
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'git_dir', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>165_tab_label()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:435
Called 2 times
Total time:   0.000461
 Self time:   0.000178

count  total (s)   self (s)
                              " Build the tab label in tabs mode. {{{1
                              "
                              " The label can be either:
                              " 1. the shortened cwd
                              " 2. the name of the active special buffer for this tab
                              " 3. the name of the active buffer for this tab (option-controlled)
                              "
                              " @param tnr: the tab number
                              " Returns: the formatted tab label
                            
    2   0.000041   0.000026   let bnr = s:tab_buffer(a:tnr)
    2   0.000146   0.000032   let buf = s:buf(bnr)            " a buffer object in the xtabline dicts
    2              0.000011   let tab = s:X.Tabs[a:tnr-1]     " the tab object in the xtabline dicts
                            
    2   0.000144   0.000025   if s:is_special(bnr)
    1              0.000005     return buf.name
    1              0.000001   endif
                            
    1              0.000003   let fname = bufname(bnr)
    1              0.000003   let minimal = &columns < 100 " window is small
    1              0.000003   let current = a:tnr == tabpagenr()
                            
                              " not current tab, and has custom name
    1              0.000001   if !current
                                if !empty(tab.name)
                                  return tab.name
                                elseif !empty(buf.name)
                                  return buf.name
                                endif
    1              0.000001   endif
                            
    1              0.000011   if !filereadable(fname)                           " new files/scratch buffers
                                return empty(fname) ? &buftype != '' ? s:Sets.scratch_label                  : s:Sets.unnamed_label : &buftype != '' ? bufname('') : minimal ? fnamemodify(fname, ':t') : s:F.short_path(bnr, 1)
                            
    1              0.000001   elseif minimal
                                return fnamemodify(fname, ':t')
                            
    1              0.000001   else
    1   0.000050   0.000014     return s:F.short_path(bnr, current ? s:Sets.current_tab_paths                              : s:Sets.other_tabs_paths)
                              endif

FUNCTION  108()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:131
Called 1 time
Total time:   0.000038
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000037   0.000013   call gitgutter#utility#setbufvar(a:buffer, 'path', -2)

FUNCTION  <SNR>88_GetLastHeartbeat()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:494
Called 15 times
Total time:   0.000889
 Self time:   0.000889

count  total (s)   self (s)
   15              0.000204         if !s:last_heartbeat.last_activity_at || localtime() - s:last_heartbeat.last_activity_at > s:local_cache_expire
    1              0.000010             if !filereadable(s:data_file)
                                            return {'last_activity_at': 0, 'last_heartbeat_at': 0, 'file': ''}
    1              0.000001             endif
    1              0.000033             let last = readfile(s:data_file, '', 3)
    1              0.000004             if len(last) == 3
    1              0.000006                 let s:last_heartbeat.last_heartbeat_at = last[1]
    1              0.000005                 let s:last_heartbeat.file = last[2]
    1              0.000001             endif
   15              0.000023         endif
   15              0.000052         return s:last_heartbeat

FUNCTION  <SNR>165_get_tab_icon()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:411
Called 4 times
Total time:   0.001357
 Self time:   0.000368

count  total (s)   self (s)
                              " The icon for the tab label. {{{1
                              "
                              " @param tabnr: the tab number
                              " @param right_corner: if it's for the right corner
                              " Returns: the icon
                            
    4   0.000089   0.000076   if !empty(get(s:Tn(a:tabnr), 'icon', ''))
                                return s:Tn(a:tabnr).icon . ' '
    4              0.000005   endif
                            
    4              0.000010   if a:right_corner
    2              0.000008     let icon = s:Sets.tab_icon
                            
    2              0.000002   else
    2   0.000042   0.000026     let bnr  = s:tab_buffer(a:tabnr)
    2   0.000137   0.000029     let B    = s:buf(bnr)
    2              0.000024     let buf  = {'nr': bnr, 'icon': B.icon, 'name': B.name}
    2   0.000885   0.000034     let icon = s:get_buf_icon(buf)
    4              0.000005   endif
                            
    4              0.000053   return type(icon) == v:t_string ? icon : icon[a:tabnr != tabpagenr()] . ' '

FUNCTION  <SNR>118_IndentLinesDisable()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:209
Called 1 time
Total time:   0.000187
 Self time:   0.000170

count  total (s)   self (s)
    1              0.000002     if g:indentLine_newVersion
    1              0.000006         if exists("w:indentLine_indentLineId") && ! empty(w:indentLine_indentLineId)
   21              0.000018             for id in w:indentLine_indentLineId
   20              0.000011                 try
   20              0.000056                     call matchdelete(id)
                                            catch /^Vim\%((\a\+)\)\=:E80[23]/
   20              0.000012                 endtry
   21              0.000013             endfor
    1              0.000006             let w:indentLine_indentLineId = []
    1              0.000001         endif
                            
    1   0.000032   0.000015         call s:ResetConcealOption()
    1              0.000001         return
                                endif
                            
                                let b:indentLine_enabled = 0
                                try
                                    syntax clear IndentLine
                                    syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
                                endtry

FUNCTION  <SNR>163_get_cur_word()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:124
Called 32 times
Total time:   0.002146
 Self time:   0.002146

count  total (s)   self (s)
   32              0.000229   let line = getline('.')
   32              0.000176   let col = col('.') - 1
   32              0.000255   let left_part = strpart(line, 0, col + 1)
   32              0.000252   let right_part = strpart(line, col, col('$'))
   32              0.000875   let word = matchstr(left_part, '\k*$') . matchstr(right_part, '^\k*')[1:]
                            
   32              0.000262   return '\<' . escape(word, '/\') . '\>'

FUNCTION  xtabline#buffer#is_special()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/buffer.vim:58
Called 1 time
Total time:   0.000296
 Self time:   0.000026

count  total (s)   self (s)
                              " Check if a buffer is special.
    1   0.000191   0.000008   let buf = xtabline#buffer#get(a:nr)
    1              0.000002   if !buf.special
    1   0.000099   0.000013     call extend(buf, s:is_special(a:nr))
    1              0.000001   endif
    1              0.000002   return buf.special

FUNCTION  <SNR>135_init_buffer()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:51
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000005   let b:buffer_vcs_config = {}
    3              0.000008   for vcs in keys(s:vcs_config)
    2              0.000013     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',     'dirty': 0,   }
    3              0.000003   endfor
    1              0.000002   unlet! b:airline_head

FUNCTION  83()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic/notifiers.vim:25
Called 1 time
Total time:   0.001314
 Self time:   0.000347

count  total (s)   self (s)
    1   0.000045   0.000019     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
    1              0.000001     endif
                            
    1   0.000023   0.000009     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
    6              0.000011     for type in self._enabled_types
    5              0.000051         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000163   0.000063         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    4              0.000016             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    1              0.000005                 if !exists('b:syntastic_private_' . type . '_stamp')
    1              0.000005                     let b:syntastic_private_{type}_stamp = []
    1              0.000001                 endif
    1   0.000022   0.000013                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    1   0.000373   0.000010                     call self._notifier[type].refresh(a:loclist)
    1   0.000040   0.000015                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    1              0.000001                 endif
    3              0.000002             else
    3   0.000457   0.000026                 call self._notifier[type].refresh(a:loclist)
    4              0.000003             endif
    5              0.000003         endif
    6              0.000005     endfor

FUNCTION  <SNR>118_Disable()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:309
Called 1 time
Total time:   0.000043
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000038   0.000007     if s:Filter() == 0
                                    call s:IndentLinesDisable()
                                    call s:LeadingSpaceDisable()
    1              0.000001     endif

FUNCTION  rainbow#hi()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:98
Called 1 time
Total time:   0.001550
 Self time:   0.001377

count  total (s)   self (s)
    1              0.000003 	let conf = a:config
    1              0.000003 	let prefix = conf.syn_name_prefix
                            
    4              0.000008 	for id in range(len(conf.parentheses))
   27              0.000032 		for lv in range(conf.cycle)
   24   0.000514   0.000340 			let [pid, oid] = [s:synID(prefix, 'p', lv, id), s:synID(prefix, 'o', lv, id)]
   24              0.000072 			let ctermfg = conf.ctermfgs[lv % len(conf.ctermfgs)]
   24              0.000057 			let guifg = conf.guifgs[lv % len(conf.guifgs)]
   24              0.000055 			let cterm = conf.cterms[lv % len(conf.cterms)]
   24              0.000059 			let gui = conf.guis[lv % len(conf.guis)]
   24              0.000146 			let hi_style = 'ctermfg='.ctermfg.' guifg='.guifg.(len(cterm) > 0 ? ' cterm='.cterm : '').(len(gui) > 0 ? ' gui='.gui : '')
   24              0.000259 			exe 'hi '.pid.' '.hi_style
   24              0.000223 			exe 'hi '.oid.' '.hi_style
   27              0.000015 		endfor
    4              0.000003 	endfor

FUNCTION  airline#util#wrap()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:42
Called 586 times
Total time:   0.008634
 Self time:   0.007023

count  total (s)   self (s)
  586   0.005520   0.003908   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  586              0.000521   endif
  586              0.001169   return a:text

FUNCTION  <SNR>99_AsyncRequest()
    Defined: ~/.config/nvim/plugged/coc.nvim/plugin/coc.vim:112
Called 2 times
Total time:   0.000664
 Self time:   0.000149

count  total (s)   self (s)
    2              0.000035   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    2              0.000013   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    2              0.000003   endif
    2   0.000554   0.000040   call coc#rpc#notify(a:name, a:args)
    2              0.000005   return ''

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/float.vim:781
Called 14 times
Total time:   0.000806
 Self time:   0.000439

count  total (s)   self (s)
   14   0.000642   0.000274   let id = coc#float#get_related(a:winid, 'scrollbar')
   14              0.000069   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
   14              0.000015   endif

FUNCTION  <SNR>182_on_exit_clean()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:87
Called 1 time
Total time:   0.000090
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000003   let buf=self.buf
    1   0.000075   0.000013   call s:set_clean_variables(self.file, self.vcs, !empty(buf))
    1              0.000006   if has_key(get(s:clean_jobs, self.vcs, {}), self.file)
    1              0.000005     call remove(s:clean_jobs[self.vcs], self.file)
    1              0.000001   endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 9 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    9              0.000021   let x = a:i - 1
   10              0.000016   while x >= 0
    9              0.000025     let group = a:sections[x][0]
    9              0.000023     if group != '' && group != '|'
    8              0.000010       return group
    1              0.000001     endif
    1              0.000001     let x = x - 1
    2              0.000002   endwhile
    1              0.000001   return ''

FUNCTION  <SNR>158_lcm()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow_main.vim:74
Called 1 time
Total time:   0.000042
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000041   0.000017 	return (a:a / s:gcd(a:a, a:b)) * a:b

FUNCTION  airline#util#getwinvar()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:82
Called 17 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
   17              0.000064     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  FugitiveDetect()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:337
Called 1 time
Total time:   0.000842
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000002   if v:version < 704
                                return ''
    1              0.000001   endif
    1              0.000005   if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir
                                unlet b:git_dir
    1              0.000000   endif
    1              0.000002   if !exists('b:git_dir')
    1   0.000822   0.000013     let b:git_dir = FugitiveExtractGitDir(a:path)
    1              0.000001   endif
    1              0.000003   if empty(b:git_dir) || !exists('#User#Fugitive')
    1              0.000001     return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:184
Called 7 times
Total time:   0.006257
 Self time:   0.000152

count  total (s)   self (s)
    7              0.000051     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
    7   0.006202   0.000097     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  syntastic#util#getbufvar()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim:126
Called 107 times
Total time:   0.001311
 Self time:   0.001311

count  total (s)   self (s)
  107              0.001211     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  airline#extensions#syntastic#get()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/syntastic.vim:22
Called 106 times
Total time:   0.037696
 Self time:   0.006255

count  total (s)   self (s)
  106              0.000800   let _backup = get(g:, 'syntastic_stl_format', '')
  106              0.000470   let is_err = (a:type  is# 'error')
  106              0.000188   if is_err
   53              0.000426     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_err', '%E{[%fe(#%e)]}')
   53              0.000056   else
   53              0.000471     let g:syntastic_stl_format = get(g:, 'airline#extensions#syntastic#stl_format_warn', '%W{[%fw(#%w)]}')
  106              0.000096   endif
  106   0.032803   0.001362   let cnt = SyntasticStatuslineFlag()
  106              0.000371   if !empty(_backup)
  106              0.000617     let g:syntastic_stl_format = _backup
  106              0.000096   endif
  106              0.000277   if empty(cnt)
  106              0.000166     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  <SNR>129_exec_separator()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 35 times
Total time:   0.057580
 Self time:   0.003991

count  total (s)   self (s)
   35              0.000152     if pumvisible()
                                  return
   35              0.000038     endif
   35              0.000283     let group = a:from.'_to_'.a:to.a:suffix
   35   0.015259   0.000689     let l:from = airline#themes#get_highlight(a:from.a:suffix)
   35   0.014115   0.000741     let l:to = airline#themes#get_highlight(a:to.a:suffix)
   35              0.000079     if a:inverse
   10              0.000132       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   25              0.000028     else
   25              0.000274       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   35              0.000038     endif
   35              0.000279     let a:dict[group] = colors
   35   0.026509   0.000864     call airline#highlighter#exec(group, colors)

FUNCTION  css_color#enable()
    Defined: ~/.config/nvim/plugged/vim-css-color/autoload/css_color.vim:277
Called 1 time
Total time:   0.001291
 Self time:   0.000537

count  total (s)   self (s)
    1              0.000007 	if ! b:css_color_off | return | endif
    1              0.000055 	if len( b:css_color_grp ) | exe 'syn cluster colorableGroup add=' . join( b:css_color_grp, ',' ) | endif
    1              0.000006 	augroup CSSColor
    1              0.000412 		autocmd! * <buffer>
    1              0.000011 		if has('nvim-0.3.1')
    1              0.000013 			autocmd CursorMoved,CursorMovedI <buffer> call s:parse_screen()
                            		else
                            			autocmd CursorMoved,CursorMovedI <buffer> call s:parse_screen() | call s:create_matches()
                            			autocmd BufWinEnter <buffer> call s:create_matches()
                            			autocmd BufWinLeave <buffer> call s:clear_matches()
    1              0.000001 		endif
    1              0.000006 		autocmd ColorScheme <buffer> call css_color#reinit()
    1              0.000002 	augroup END
    1              0.000004 	let b:css_color_off = 0
    1   0.000767   0.000013 	doautocmd CSSColor CursorMoved

FUNCTION  AutoPairsInit()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim:471
Called 1 time
Total time:   0.001878
 Self time:   0.001290

count  total (s)   self (s)
    1              0.000003   let b:autopairs_loaded  = 1
    1              0.000003   if !exists('b:autopairs_enabled')
    1              0.000002     let b:autopairs_enabled = 1
    1              0.000001   end
                            
    1              0.000002   if !exists('b:AutoPairs')
    1   0.000094   0.000013     let b:AutoPairs = AutoPairsDefaultPairs()
    1              0.000001   end
                            
    1              0.000003   if !exists('b:AutoPairsMoveCharacter')
    1              0.000003     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    1              0.000001   end
                            
    1              0.000002   let b:autopairs_return_pos = 0
    1              0.000003   let b:autopairs_saved_pair = [0, 0]
    1              0.000002   let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
   11              0.000028   for [open, close] in items(b:AutoPairs)
   10              0.000024     let o = open[-1:-1]
   10              0.000015     let c = close[0]
   10              0.000030     let opt = {'mapclose': 1, 'multiline':1}
   10              0.000020     let opt['key'] = c
   10              0.000014     if o == c
    6              0.000011       let opt['multiline'] = 0
   10              0.000005     end
   10              0.000071     let m = matchlist(close, '\v(.*)//(.*)$')
   10              0.000022     if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
   10              0.000005     end
   10   0.000446   0.000096     call AutoPairsMap(o)
   10              0.000028     if o != c && c != '' && opt['mapclose']
    3   0.000112   0.000020       call AutoPairsMap(c)
   10              0.000006     end
   10              0.000042     let b:AutoPairsList += [[open, close, opt]]
   11              0.000009   endfor
                            
                              " sort pairs by length, longer pair should have higher priority
    1   0.000172   0.000106   let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
   11              0.000010   for item in b:AutoPairsList
   10              0.000019     let [open, close, opt] = item
   10              0.000014     if open == "'" && open == close
    1              0.000002       let item[0] = '\v(^|\W)\zs'''
   10              0.000005     end
   11              0.000006   endfor
                            
                            
    9              0.000022   for key in split(b:AutoPairsMoveCharacter, '\s*')
    8              0.000035     let escaped_key = substitute(key, "'", "''", 'g')
    8              0.000160     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
    9              0.000006   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    1              0.000002   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    1              0.000017     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    1              0.000001   end
                            
    1              0.000001   if g:AutoPairsMapCh
    1              0.000015     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    1              0.000001   endif
                            
    1              0.000002   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    1              0.000002     let do_abbrev = ""
    1              0.000004     if v:version == 703 && has("patch489") || v:version > 703
    1              0.000002       let do_abbrev = "<C-]>"
    1              0.000001     endif
    1              0.000019     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    1              0.000001   end
                            
    1              0.000002   if g:AutoPairsShortcutFastWrap != ''
    1              0.000017     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    1              0.000001   end
                            
    1              0.000002   if g:AutoPairsShortcutBackInsert != ''
    1              0.000016     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    1              0.000001   end
                            
    1              0.000002   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    1              0.000015     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    1              0.000019     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    1              0.000001   end
                            
    1              0.000002   if g:AutoPairsShortcutJump != ''
    1              0.000018     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    1              0.000017     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    1              0.000001   end
                            
    1              0.000002   if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
    1              0.000001   end
                            

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 53 times
Total time:   0.004686
 Self time:   0.002969

count  total (s)   self (s)
   53              0.000459   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
    1              0.000004     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
    1              0.000003     elseif exists('*GitGutterGetHunkSummary')
    1              0.000005       let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
    1              0.000001     endif
   53              0.000037   endif
   53   0.002660   0.000943   return {b:source_func}()

FUNCTION  airline#async#nvim_vcs_untracked()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:336
Called 2 times
Total time:   0.002035
 Self time:   0.002004

count  total (s)   self (s)
    2              0.000015   let cmd = a:cfg.cmd . shellescape(a:file)
    2              0.000004   let id = -1
    2   0.000081   0.000050   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
    2              0.000012   if has("nvim")
    2              0.000045     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
    2              0.000008     if has_key(s:untracked_jobs, config.file)
                                  " still running
    1              0.000001       return
    1              0.000001     endif
    1              0.000001     try
    1              0.001821     let id = jobstart(cmd, config)
                                catch
                                  " catch-all, jobstart() failed, fall back to system()
                                  let id=-1
    1              0.000002     endtry
    1              0.000008     let s:untracked_jobs[a:file] = id
    1              0.000001   endif
                              " vim without job feature or nvim jobstart failed
    1              0.000002   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
    1              0.000001   endif

FUNCTION  <SNR>88_EnoughTimePassed()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:521
Called 15 times
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
   15              0.000084         let prev = a:last.last_heartbeat_at
   15              0.000106         if a:now - prev > g:wakatime_HeartbeatFrequency * 60
                                        return s:true
   15              0.000019         endif
   15              0.000041         return s:false

FUNCTION  airline#extensions#syntastic#get_error()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/syntastic.vim:18
Called 53 times
Total time:   0.019097
 Self time:   0.000898

count  total (s)   self (s)
   53   0.019058   0.000858   return airline#extensions#syntastic#get('error')

FUNCTION  <SNR>88_AppendHeartbeat()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:260
Called 1 time
Total time:   0.000244
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000002         let file = a:file
    1              0.000002         if file == ''
                                        let file = a:last.file
    1              0.000001         endif
    1              0.000001         if file != ''
    1              0.000002             let heartbeat = {}
    1              0.000002             let heartbeat.entity = file
    1   0.000034   0.000010             let heartbeat.time = s:CurrentTimeStr()
    1              0.000002             let heartbeat.is_write = a:is_write
    1              0.000004             if !empty(&syntax)
    1              0.000002                 let heartbeat.language = &syntax
                                        else
                                            if !empty(&filetype)
                                                let heartbeat.language = &filetype
                                            endif
    1              0.000001             endif
    1              0.000007             let s:heartbeats_buffer = s:heartbeats_buffer + [heartbeat]
    1   0.000166   0.000012             call s:SetLastHeartbeat(a:now, a:now, file)
                            
    1              0.000004             if !s:buffering_heartbeats_enabled
                                            call s:SendHeartbeats()
    1              0.000001             endif
    1              0.000001         endif

FUNCTION  <SNR>95_is()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:162
Called 10 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
   10              0.000068   let identifier = substitute(a:identifier, '/$', '', '')
   10              0.000039   return fnamemodify(a:dir, ':t') ==# identifier

FUNCTION  <SNR>182_nvim_untracked_job_handler()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:238
Called 1 time
Total time:   0.000045
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000002     if a:event == 'exit'
    1   0.000033   0.000013       call s:untracked_output(self, self.buf)
    1              0.000004       if has_key(s:untracked_jobs, self.file)
    1              0.000004         call remove(s:untracked_jobs, self.file)
    1              0.000001       endif
    1              0.000000     endif

FUNCTION  <SNR>163_should_illuminate_file()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:157
Called 15 times
Total time:   0.001372
 Self time:   0.001036

count  total (s)   self (s)
   15              0.000269   let g:Illuminate_ftblacklist = get(g:, 'Illuminate_ftblacklist', [])
   15              0.000156   let g:Illuminate_ftwhitelist = get(g:, 'Illuminate_ftwhitelist', [])
                            
   15   0.000895   0.000559   return !s:list_contains_pat(g:Illuminate_ftblacklist, &filetype) && (empty(g:Illuminate_ftwhitelist) || s:list_contains_pat(g:Illuminate_ftwhitelist, &filetype))

FUNCTION  syntastic#util#var()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim:170
Called 8 times
Total time:   0.000224
 Self time:   0.000143

count  total (s)   self (s)
    8   0.000221   0.000139     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline.vim:173
Called 1 time
Total time:   0.000071
 Self time:   0.000037

count  total (s)   self (s)
    1   0.000042   0.000007   if airline#util#stl_disabled(winnr())
                                return
    1              0.000000   endif
    1              0.000003   for nr in a:range
                                if airline#util#stl_disabled(nr)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
    1              0.000002   endfor

FUNCTION  <SNR>75_bookmark_save_file()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:458
Called 2 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
                              " Managing bookmarks per buffer implies saving them to a location based on the
                              " open file (working dir doesn't make much sense unless auto changing the
                              " working directory based on current file location is turned on - but this is
                              " a serious dependency to try and require), so the function used to customize
                              " the bookmarks file location must be based on the current file.
                              " For backwards compatibility reasons, a new function is used.
    2              0.000012   if (g:bookmark_manage_per_buffer ==# 1)
                                return exists("*g:BMBufferFileLocation") ? g:BMBufferFileLocation(a:file) : s:default_file_location()
    2              0.000008   elseif (g:bookmark_save_per_working_dir)
                                return exists("*g:BMWorkDirFileLocation") ? g:BMWorkDirFileLocation() : s:default_file_location()
    2              0.000003   else
    2              0.000010     return g:bookmark_auto_save_file
                              endif

FUNCTION  <SNR>88_CurrentTimeStr()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:253
Called 1 time
Total time:   0.000024
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000001         if s:has_reltime
                                        return split(reltimestr(reltime()))[0]
    1              0.000001         endif
    1   0.000018   0.000008         return s:n2s(localtime())

FUNCTION  airline#async#vcs_untracked()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:57
Called 2 times
Total time:   0.002135
 Self time:   0.000100

count  total (s)   self (s)
    2              0.000005   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_untracked(a:config, a:file)
    2              0.000002   else
                                " nvim async or vim without job-feature
    2   0.002095   0.000060     noa call airline#async#nvim_vcs_untracked(a:config, a:file, a:vcs)
    2              0.000001   endif

FUNCTION  airline#async#vcs_clean()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:95
Called 2 times
Total time:   0.001871
 Self time:   0.000126

count  total (s)   self (s)
    2              0.000005   if g:airline#init#vim_async
                                " Vim 8 with async support
                                noa call airline#async#vim_vcs_clean(a:cmd, a:file, a:vcs)
    2              0.000010   elseif has("nvim")
                                " nvim async
    2   0.001813   0.000067     noa call airline#async#nvim_vcs_clean(a:cmd, a:file, a:vcs)
                              else
                                " Vim pre 8 using system()
                                call airline#async#vim7_vcs_clean(a:cmd, a:file, a:vcs)
    2              0.000002   endif

FUNCTION  <SNR>150_build_sections()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 2 times
Total time:   0.001055
 Self time:   0.000159

count  total (s)   self (s)
   10              0.000014   for key in a:keys
    8              0.000027     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
    8              0.000004     endif
    8   0.000976   0.000081     call s:add_section(a:builder, a:context, key)
   10              0.000009   endfor

FUNCTION  <SNR>19_DetectShebang()
    Defined: ~/.config/nvim/plugged/dart-vim-plugin/ftdetect/dart.vim:7
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   if did_filetype() | return | endif
                              if getline(1) ==# '#!/usr/bin/env dart'
                                setlocal filetype=dart
                              endif

FUNCTION  <SNR>88_SetLastHeartbeat()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:516
Called 1 time
Total time:   0.000154
 Self time:   0.000131

count  total (s)   self (s)
    1   0.000022   0.000012         call s:SetLastHeartbeatInMemory(a:last_activity_at, a:last_heartbeat_at, a:file)
    1   0.000131   0.000118         call writefile([s:n2s(a:last_activity_at), s:n2s(a:last_heartbeat_at), a:file], s:data_file)

FUNCTION  FugitiveHead()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:183
Called 53 times
Total time:   0.005775
 Self time:   0.001094

count  total (s)   self (s)
   53   0.005482   0.000801   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   53              0.000155   if empty(dir)
   53              0.000077     return ''
                              endif
                              return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:255
Called 4 times
Total time:   0.166054
 Self time:   0.023197

count  total (s)   self (s)
    4              0.000034     let bufnr = a:0 ? a:1 : ''
    4              0.000045     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    4              0.000106     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    4              0.000026     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    4              0.000020     let airline_grouplist = []
    4              0.000038     let buffers_in_tabpage = sort(tabpagebuflist())
    4              0.000024     if exists("*uniq")
    4              0.000024       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    4              0.000006     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
   10              0.000051     for mode in reverse(mapped)
    6              0.000088       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    4              0.000036         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   68              0.000337         for kvp in items(dict)
   64              0.000309           let mode_colors = kvp[1]
   64              0.000241           let name = kvp[0]
   64              0.000486           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                        let name = 'airline_c'.bufnr
   64              0.000083           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
   64              0.001109           if name =~# 'airline_c\d\+'
                                        let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                        if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                          continue
                                        endif
   64              0.000880           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   28              0.000058             continue
   36              0.000040           endif
   36   0.001722   0.000930           if s:group_not_done(airline_grouplist, name.suffix)
   36   0.031314   0.000998             call airline#highlighter#exec(name.suffix, mode_colors)
   36              0.000053           endif
                            
   36              0.000230           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   36              0.000046           endif
                            
  108              0.000620           for accent in keys(s:accents)
   72              0.000495             if !has_key(p.accents, accent)
                                          continue
   72              0.000089             endif
   72              0.000670             let colors = copy(mode_colors)
   72              0.000509             if p.accents[accent][0] != ''
   36              0.000260               let colors[0] = p.accents[accent][0]
   72              0.000094             endif
   72              0.000321             if p.accents[accent][2] != ''
   36              0.000189               let colors[2] = p.accents[accent][2]
   72              0.000079             endif
   72              0.000342             if len(colors) >= 5
   72              0.000661               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
   72              0.000089             endif
   72   0.003554   0.002057             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   72   0.060744   0.001967               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   72              0.000109             endif
  108              0.000205           endfor
   40              0.000061         endfor
                            
    4              0.000022         if empty(s:separators)
                                      " nothing to be done
                                      continue
    4              0.000005         endif
                                    " TODO: optimize this
   32              0.000174         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
   28   0.052538   0.001064           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   32              0.000067         endfor
    6              0.000008       endif
   10              0.000032     endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim:32
Called 24 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
   24              0.000269   if empty(s:client) || s:client['running'] == 0
                                return 0
   24              0.000030   endif
   24              0.000047   return 1

FUNCTION  <SNR>182_untracked_output()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/async.vim:12
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000007   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    1              0.000001   else
    1              0.000005     let a:dict.cfg.untracked[a:dict.file] = ''
    1              0.000001   endif

FUNCTION  signature#utils#Set()
    Defined: ~/.config/nvim/plugged/vim-signature/autoload/signature/utils.vim:4
Called 8 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
                              " Description: Assign value to var if var is unset or if an optional 3rd arg is provided to force
                            
    8              0.000024   if (!exists(a:var) || a:0 && a:1)
    8              0.000013     if type(a:value)
    3              0.000018       execute 'let' a:var '=' string(a:value)
    5              0.000003     else
    5              0.000023       execute 'let' a:var '=' a:value
    8              0.000004     endif
    8              0.000004   endif
    8              0.000008   return a:var

FUNCTION  airline#parts#ffenc()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000004   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    1              0.000003   let bomb     = &bomb ? '[BOM]' : ''
    1              0.000006   let noeolf   = &eol ? '' : '[!EOL]'
    1              0.000014   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    1              0.000008   if expected is# &fenc.bomb.noeolf.ff
                                return ''
    1              0.000001   else
    1              0.000006     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  <SNR>159_concat()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:9
Called 28 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
   28              0.000395 	return join(filter(a:strs, "v:val !~ '^[ ]*$'"), ',')

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 53 times
Total time:   0.003849
 Self time:   0.000848

count  total (s)   self (s)
   53   0.003806   0.000805   return airline#extensions#nvimlsp#get('Error')

FUNCTION  <SNR>95_rooter()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:68
Called 2 times
Total time:   0.003770
 Self time:   0.000099

count  total (s)   self (s)
    2   0.000203   0.000023   if !s:activate() | return | endif
                            
    2              0.000008   let root = getbufvar('%', 'rootDir')
    2              0.000004   if empty(root)
    2   0.003472   0.000018     let root = s:root()
    2              0.000013     call setbufvar('%', 'rootDir', root)
    2              0.000002   endif
                            
    2              0.000004   if empty(root)
    2   0.000056   0.000019     call s:rootless()
    2              0.000002     return
                              endif
                            
                              call s:cd(root)

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000037   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    3              0.000004     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
                                return shellescape(a:arg)
                              endif

FUNCTION  xtabline#tab#check()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/tab.vim:61
Called 1 time
Total time:   0.000159
 Self time:   0.000051

count  total (s)   self (s)
                              " Ensure all tab dict keys are present, and update tab CWD.
    1   0.000008   0.000005   let Tab = s:T()
    1   0.000051   0.000014   let Tab.cwd = s:F.fulldir(getcwd())
    1   0.000085   0.000016   call extend(Tab, s:template(), 'keep')
    1              0.000003   if !has_key(t:, 'xtab')
                                let t:xtab = Tab
    1              0.000001   endif
                            
                              " ensure 'recent' key is present
    1              0.000006   let bufs = extend(Tab.buffers, {'recent': []}, 'keep')
    1              0.000001   return Tab

FUNCTION  <SNR>165_get_buf_icon()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:351
Called 2 times
Total time:   0.000852
 Self time:   0.000113

count  total (s)   self (s)
                              " Return custom icon for buffer, or devicon if installed. {{{1
    2              0.000010   let nr = a:buf.nr
    2              0.000010   if !empty(a:buf.icon)
                                return a:buf.icon.' '
    2              0.000010   elseif get(s:Sets, 'use_devicons', 1)
    2              0.000004     try
    2   0.000790   0.000051       let icon = WebDevIconsGetFileTypeSymbol(bufname(a:buf.nr)).' '
    2              0.000008       return icon
                                catch
    2              0.000004     endtry
                              endif
                              return ''

FUNCTION  <SNR>78_reorder_recent_buffers()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:303
Called 1 time
Total time:   0.000028
 Self time:   0.000026

count  total (s)   self (s)
                              " Move the current buffer at the top of the recent buffers list. {{{1
    1   0.000009   0.000006   let bufs      = s:T().buffers
    1              0.000004   let rix       = index(bufs.recent, a:buf)
    1              0.000003   let is_recent = rix >= 0
    1              0.000003   let is_valid  = index(bufs.valid, a:buf) >= 0
                            
                              " remove the current buffer if present, it will be inserted if valid
    1              0.000001   if is_recent
                                call remove(bufs.recent, rix)
    1              0.000001   endif
                            
    1              0.000001   if is_valid
                                call insert(bufs.recent, a:buf)
    1              0.000000   endif

FUNCTION  <SNR>84_is_special()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/buffer.vim:113
Called 2 times
Total time:   0.000185
 Self time:   0.000166

count  total (s)   self (s)
                              " Customize special buffers, if visible in a window.
    2   0.000037   0.000018   if !s:F.has_win(a:nr) | return { 'special': 0 } | endif
                            
    2              0.000025   let [ n, ft, ret ] = [ a:nr, getbufvar(a:nr, "&ft"), {} ]
                            
    2              0.000010   let git = index(['gitcommit', 'magit', 'git', 'fugitive'], ft)
                            
    2              0.000003   if ft == "GV"
                            
                                call xtabline#tab#lock(tabpagenr(), [n], {'icon': s:Sets.icons.git})
                                let ret = {'name': 'GV', 'icon': s:Sets.icons.git, 'refilter': 1 }
                            
    2              0.000003   elseif git >= 0
                                let nam = ['Commit', 'Magit', 'Git', 'Status']
                                let ret = {'name': nam[git], 'icon': s:Sets.icons.git}
                            
    2              0.000012   elseif bufname(n) =~ '^\Cfugitive'
                                let ret = {'name': 'fugitive', 'icon': s:Sets.icons.git}
                            
    2              0.000006   elseif ft == "help" && getbufvar(n, '&modifiable') == 0
                                let ret = {'name': 'HELP', 'icon': s:Sets.icons.book}
                            
    2              0.000003   elseif ft == "netrw"
                                let ico = ' '.s:Sets.icons.netrw.' '
                                let ret = {'name': ico.'Netrw'.ico}
                            
    2              0.000003   elseif ft == "dirvish"
                                let ico = ' '.s:Sets.icons.netrw.' '
                                let ret = {'name': ico.'Dirvish'.ico}
                            
    2              0.000002   elseif ft == "startify"
                                let ico = ' '.s:Sets.icons.flag2.' '
                                let ret = {'name': ico.'Startify'.ico}
                            
    2              0.000002   elseif ft == "ctrlsf"
                                let ico = ' '.s:Sets.icons.lens.' '
                                let ret = {'name': ico.'CtrlSF'.ico}
    2              0.000001   endif
                            
    2              0.000011   return empty(ret) ? {'special': 0} : extend(ret, {'special': 1})

FUNCTION  <SNR>71_filename()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:219
Called 1 time
Total time:   0.000052
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000052   0.000009   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  airline#parts#paste()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 53 times
Total time:   0.000370
 Self time:   0.000370

count  total (s)   self (s)
   53              0.000335   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  VMInfos()
    Defined: ~/.config/nvim/plugged/vim-visual-multi/plugin/visual-multi.vim:97
Called 56 times
Total time:   0.000745
 Self time:   0.000745

count  total (s)   self (s)
   56              0.000445     if !exists('b:VM_Selection') || empty(b:VM_Selection)
   56              0.000195         return {}
                                endif
                            
                                let infos = {}
                                let VM = b:VM_Selection
                            
                                let m = g:Vm.mappings_enabled ?    'M' : 'm'
                                let s = VM.Vars.single_region ?    'S' : 's'
                                let l = VM.Vars.multiline ?        'V' : 'v'
                            
                                let infos.current = VM.Vars.index + 1
                                let infos.total = len(VM.Regions)
                                let infos.ratio = infos.current . ' / ' . infos.total
                                let infos.patterns = VM.Vars.search
                                let infos.status = m.s.l
                                return infos

FUNCTION  AutoPairsMap()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim:445
Called 13 times
Total time:   0.000441
 Self time:   0.000441

count  total (s)   self (s)
                              " | is special key which separate map command from text
   13              0.000025   let key = a:key
   13              0.000017   if key == '|'
                                let key = '<BAR>'
   13              0.000007   end
   13              0.000062   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   13              0.000298   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  coc#rpc#notify()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/rpc.vim:96
Called 24 times
Total time:   0.005336
 Self time:   0.001041

count  total (s)   self (s)
   24   0.000793   0.000335   if !coc#rpc#ready()
                                return ''
   24              0.000024   endif
   24   0.004383   0.000547   call s:client['notify'](a:method, a:args)
   24              0.000057   return ''

FUNCTION  <SNR>28_vm_persist()
    Defined: ~/.config/nvim/plugged/vim-visual-multi/plugin/visual-multi.vim:76
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000017   if exists('g:VM_PERSIST') && !g:VM_persistent_registers
                                unlet g:VM_PERSIST
    1              0.000007   elseif g:VM_persistent_registers
                                let g:VM_PERSIST = deepcopy(g:Vm.registers)
    1              0.000002   endif

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:494
Called 55 times
Total time:   0.017965
 Self time:   0.017112

count  total (s)   self (s)
   55              0.000165   if a:0 == 0
   53              0.000222     let fileNodeExtension = &filetype
   53              0.000282     let fileNode = expand('%:t')
   53              0.000131     let isDirectory = 0
    2              0.000002   else
    2              0.000016     let fileNodeExtension = fnamemodify(a:1, ':e')
    2              0.000010     let fileNode = fnamemodify(a:1, ':t')
    2              0.000005     if a:0 > 1
                                  let isDirectory = a:2
    2              0.000002     else
    2              0.000006       let isDirectory = 0
    2              0.000002     endif
   55              0.000052   endif
                            
   55              0.000211   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
   55              0.000254     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   55              0.000317     let fileNodeExtension = tolower(fileNodeExtension)
   55              0.000227     let fileNode = tolower(fileNode)
                            
  550              0.002474     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
  495              0.004958       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
  495              0.000339       endif
  550              0.000525     endfor
                            
   55              0.000285     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   55              0.000310       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
   55              0.000606       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
   54              0.000310         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
    1              0.000004       elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   55              0.000051       endif
   55              0.000050     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   55              0.000048   endif
                            
   55   0.002005   0.001151   let artifactFix = s:DevIconsGetArtifactFix()
                            
   55              0.000203   return symbol . artifactFix
                            

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:199
Called 53 times
Total time:   0.000886
 Self time:   0.000886

count  total (s)   self (s)
   53              0.000504   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
   53              0.000049   endif

FUNCTION  CocActionAsync()
    Defined: ~/.config/nvim/plugged/coc.nvim/plugin/coc.vim:82
Called 2 times
Total time:   0.000720
 Self time:   0.000057

count  total (s)   self (s)
    2   0.000718   0.000054   return s:AsyncRequest(a:name, a:000)

FUNCTION  airline#parts#get()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 106 times
Total time:   0.000793
 Self time:   0.000793

count  total (s)   self (s)
  106              0.000723   return get(s:parts, a:key, {})

FUNCTION  coc#util#check_refresh()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:62
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000011   if !bufloaded(a:bufnr)
                                return 0
    1              0.000002   endif
    1              0.000005   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    1              0.000001   endif
    1              0.000004   if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
    1              0.000001   endif
    1              0.000001   return 1

FUNCTION  <SNR>88_SetLastHeartbeatInMemory()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:508
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000008         let s:last_heartbeat = {'last_activity_at': a:last_activity_at, 'last_heartbeat_at': a:last_heartbeat_at, 'file': a:file}

FUNCTION  AutoPairsDefaultPairs()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim:20
Called 1 time
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    1              0.000003   if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
    1              0.000001   end
    1              0.000006   let r = copy(g:AutoPairs)
    1              0.000011   let allPairs = { 'vim': {'\v^\s*\zs"': ''}, 'rust': {'\w\zs<': '>', '&\zs''': ''}, 'php': {'<?': '?>//k]', '<?php': '?>//k]'} }
    4              0.000013   for [filetype, pairs] in items(allPairs)
    3              0.000006     if &filetype == filetype
    2              0.000007       for [open, close] in items(pairs)
    1              0.000004         let r[open] = close
    2              0.000002       endfor
    3              0.000002     end
    4              0.000003   endfor
    1              0.000003   let b:autopairs_defaultpairs = r
    1              0.000001   return r

FUNCTION  airline#update_statusline()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline.vim:144
Called 1 time
Total time:   0.013528
 Self time:   0.000082

count  total (s)   self (s)
    1   0.000056   0.000009   if airline#util#stl_disabled(winnr())
                                return
    1              0.000001   endif
    1              0.000009   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    1   0.000082   0.000010   call airline#update_statusline_inactive(range)
                            
    1              0.000003   unlet! w:airline_render_left w:airline_render_right
    1              0.000017   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    1              0.000002   let w:airline_active = 1
    1              0.000007   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    1   0.013346   0.000019   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>165_fit_tabline()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:192
Called 2 times
Total time:   0.001969
 Self time:   0.000806

count  total (s)   self (s)
                              " Toss away tabs and pieces until all fits {{{1
    2   0.001082   0.000077   let corner_label = s:format_right_corner()
    2   0.000088   0.000037   let corner_width = s:strwidth(corner_label)
    2              0.000008   let Tabs = a:tabs
                            
    2   0.000095   0.000036   let modelabel = s:get_mode_label()
    2              0.000006   if modelabel != ''
                                let corner_width += s:strwidth(modelabel)
    2              0.000003   endif
                            
    2              0.000013   if tabpagenr('$') > 1 && s:Sets.tab_number_in_left_corner
                                let tabsnums = '%#ErrorMsg# ' . tabpagenr() . '/'. tabpagenr('$') . ' %#XTFill# '
                                let corner_width += s:strwidth(tabsnums)
    2              0.000002   else
    2              0.000005     let tabsnums = ''
    2              0.000002   endif
                            
                              " limit is the max bufline length
    2              0.000012   let limit = &columns - corner_width - 1
                            
                              " now keep the current buffer center-screen as much as possible
    2              0.000028   let L = { 'lasttab':  0, 'cut':  '.', 'indicator': '<', 'width': 0, 'half': limit / 2 }
    2              0.000022   let R = { 'lasttab': -1, 'cut': '.$', 'indicator': '>', 'width': 0, 'half': limit - L.half }
                            
                              " sum the string lengths for the left and right halves
    2              0.000007   let currentside = L
    4              0.000013   for tab in Tabs
    2   0.000080   0.000031     let tab.width = s:strwidth(tab.label)
    2              0.000007     if tab.width >= limit
                                  let tab.label = tab.label[:limit-1] . '…'
                                  let tab.width = s:strwidth(tab.label)
    2              0.000003     endif
    2              0.000007     if a:center == tab.nr
    2              0.000008       let halfwidth = tab.width / 2
    2              0.000009       let L.width += halfwidth
    2              0.000008       let R.width += tab.width - halfwidth
    2              0.000010       let currentside = R
    2              0.000005       continue
                                endif
                                let currentside.width += tab.width
    2              0.000005   endfor
                            
    2              0.000008   if currentside is L " centered buffer not seen?
                                let [L.width, R.width] = [0, L.width]
    2              0.000002   endif
                            
    2              0.000008   let left_has_been_cut = 0
    2              0.000007   let right_has_been_cut = 0
                            
    2              0.000009   if ( L.width + R.width ) > limit
                                while limit - ( L.width + R.width ) < 0
                                  " remove a tab from the biggest side
                                  if L.width <= R.width
                                    let right_has_been_cut = 1
                                    let R.width -= remove(Tabs, -1).width
                                  else
                                    let left_has_been_cut = 1
                                    let L.width -= remove(Tabs, 0).width
                                  endif
                                endwhile
                                try
                                  if left_has_been_cut
                                    let lab = substitute(Tabs[0].label, '%#X\w*#', '', 'g')
                                    let Tabs[0].label = printf('%%#DiffDelete# < %%#XT%s#%s', Tabs[0].hilite, strcharpart(lab, 3))
                                  endif
                                  if right_has_been_cut
                                    let Tabs[-1].label = printf('%s%%#DiffDelete# > ', Tabs[-1].label[:-4])
                                  endif
                                catch
                                  return corner_label
                                endtry
    2              0.000002   endif
                            
    2              0.000019   let labels = map(Tabs,'v:val.label')
    2              0.000007   if s:v.tabline_mode == 'tabs'
                                "FIXME: it works like this, but it's adding the %nT part for the second
                                "time, for some reason it doesn't work anymore if I only add it here
    4              0.000022     for n in range(len(labels))
    2              0.000024       let labels[n] = '%' . (n+1) . 'T' . labels[n]
    4              0.000006     endfor
    2              0.000002   endif
    2              0.000020   let labels = tabsnums . modelabel . join(labels, '')
    2              0.000018   let g:xtabline.last_tabline = labels . '%#XTFill#%=' . corner_label . '%999X'
    2              0.000008   return g:xtabline.last_tabline

FUNCTION  <SNR>85_isDarwin()
    Defined: ~/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:126
Called 53 times
Total time:   0.008321
 Self time:   0.000558

count  total (s)   self (s)
   53              0.000256   if exists('s:is_darwin')
   52              0.000130     return s:is_darwin
    1              0.000001   endif
                            
    1              0.000004   if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
    1              0.000001   endif
                            
    1              0.000010   if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
    1              0.000001   endif
                            
    1              0.000003   if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
    1              0.000001   endif
                            
    1   0.007795   0.000033   if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
    1              0.000002   else
    1              0.000007     let s:is_darwin = 0
    1              0.000001   endif
                            
    1              0.000005   return s:is_darwin

FUNCTION  airline#extensions#bookmark#currentbookmark()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/bookmark.vim:11
Called 53 times
Total time:   0.004380
 Self time:   0.003860

count  total (s)   self (s)
   53              0.000344   if get(w:, 'airline_active', 0)
   53              0.001050     let file = expand('%:p')
   53              0.000162     if file ==# ''
                                  return
   53              0.000056     endif
                            
   53              0.000259     let current_line = line('.')
   53   0.001485   0.000965     let has_bm = bm#has_bookmark_at_line(file, current_line)
   53              0.000342     let bm = has_bm ? bm#get_bookmark_by_line(file, current_line) : 0
   53              0.000246     let annotation = has_bm ? bm['annotation'] : ''
                            
   53              0.000118     return annotation
                              endif
                              return ''

FUNCTION  <SNR>71_exists_file()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 1 time
Total time:   0.000080
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000080   0.000017   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>124_is_excluded_window()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    1              0.000003   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    1              0.000001   endfor
                            
    4              0.000006   for matchw in g:airline_exclude_filenames
    3              0.000018     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
    3              0.000001     endif
    4              0.000003   endfor
                            
    1              0.000002   if g:airline_exclude_preview && &previewwindow
                                return 1
    1              0.000001   endif
                            
    1              0.000001   return 0

FUNCTION  airline#parts#readonly()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 3 times
Total time:   0.000345
 Self time:   0.000179

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
    3   0.000260   0.000094   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
    3              0.000004   endif
    3              0.000024   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
    3              0.000004   else
    3              0.000018     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>151__isDebugEnabled_smart()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/log.vim:149
Called 8 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    8              0.000039     return and(g:syntastic_debug, a:level)

FUNCTION  <SNR>158_eq()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow_main.vim:60
Called 2 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    2              0.000011 	return type(a:x) == type(a:y) && a:x == a:y

FUNCTION  syntastic#util#bufIsActive()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim:238
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    1              0.000004     let buf = str2nr(a:buffer)
                            
    1              0.000004     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
    1              0.000001     endif
                            
                                " get rid of hidden buffers
    1              0.000005     for tab in range(1, tabpagenr('$'))
    1              0.000004         if index(tabpagebuflist(tab), buf) >= 0
    1              0.000001             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>75_startup_load_bookmarks()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:453
Called 1 time
Total time:   0.002224
 Self time:   0.000037

count  total (s)   self (s)
    1   0.002185   0.000023   call BookmarkLoad(s:bookmark_save_file(a:file), 1, 1)
    1   0.000039   0.000013   call s:add_missing_signs(a:file)

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 3 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000009   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
    3              0.000012   let ggvars = getbufvar(buffer, 'gitgutter')
    3              0.000010   if type(ggvars) == type('')
    1              0.000002     unlet ggvars
    1              0.000002     let ggvars = {}
    1              0.000005     call setbufvar(buffer, 'gitgutter', ggvars)
    3              0.000002   endif
    3              0.000011   let ggvars[a:varname] = a:val

FUNCTION  <SNR>163_list_contains_pat()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:193
Called 15 times
Total time:   0.000336
 Self time:   0.000336

count  total (s)   self (s)
   15              0.000109   for pat in a:list
                                if a:val =~# '^'.pat.'$'
                                  return 1
                                endif
   15              0.000044   endfor
   15              0.000033   return 0

FUNCTION  <SNR>7_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:14
Called 1 time
Total time:   0.020937
 Self time:   0.019547

count  total (s)   self (s)
    1              0.000027     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000004     endif
                            
    1              0.000018     let s = expand("<amatch>")
    1              0.000008     if s != ""
    1              0.000053       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000004       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000041       for name in split(s, '\.')
    1   0.012807   0.011417         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    1              0.007883         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    2              0.000013       endfor
    1              0.000003     endif

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 53 times
Total time:   0.018390
 Self time:   0.012144

count  total (s)   self (s)
   53              0.000478   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   53              0.000709   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   53              0.000048   endif
   53              0.000930   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   53              0.000304   if !exists('b:airline_whitespace_check')
    1              0.000007     let b:airline_whitespace_check = ''
    1              0.000006     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000002     let trailing = 0
    1              0.000001     let check = 'trailing'
    1              0.000016     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000002       try
    1              0.000004         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000172         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    1              0.000002       endtry
    1              0.000001     endif
                            
    1              0.000002     let mixed = 0
    1              0.000002     let check = 'indent'
    1              0.000011     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.002848   0.000019       let mixed = s:check_mixed_indent()
    1              0.000003     endif
                            
    1              0.000003     let mixed_file = ''
    1              0.000002     let check = 'mixed-indent-file'
    1              0.000019     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000086   0.000020       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000001     let long = 0
    1              0.000003     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    1              0.000001     endif
                            
    1              0.000002     let conflicts = 0
    1              0.000003     if index(checks, 'conflicts') > -1
    1   0.000664   0.000012       let conflicts = s:conflict_marker()
    1              0.000002     endif
                            
    1              0.000006     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
    1              0.000004       let b:airline_whitespace_check = s:symbol
    1              0.000003       if strlen(s:symbol) > 0
    1              0.000004         let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
    1              0.000001       endif
                            
    1              0.000001       if s:show_message
    1              0.000001         if trailing != 0
    1              0.000005           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    1              0.000009           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    1              0.000001         endif
    1              0.000001         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
    1              0.000001         endif
    1              0.000001         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
    1              0.000001         endif
    1              0.000003         if !empty(mixed_file)
    1              0.000005           let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
    1              0.000006           let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
    1              0.000001         endif
    1              0.000001         if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
    1              0.000001         endif
    1              0.000001       endif
    1              0.000000     endif
   53              0.000044   endif
   53   0.003504   0.000806   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>98_Tree()
    Defined: ~/.config/nvim/plugged/vim-fugitive/plugin/fugitive.vim:224
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000003   let dir = a:path
    1              0.000004   if dir =~# '/\.git$'
                                return len(dir) ==# 5 ? '/' : dir[0:-6]
    1              0.000001   elseif dir ==# ''
    1              0.000001     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  let wt_config = filter(copy(config),'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config) == 1
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  else
                                    call filter(config,'v:val =~# "^\\s*bare *= *false *$"')
                                    if len(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  xtabline#render#tabline()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:42
Called 2 times
Total time:   0.005688
 Self time:   0.000272

count  total (s)   self (s)
                              " Entry point {{{1
    2   0.000121   0.000075   if !s:ready() | return g:xtabline.last_tabline | endif
    2   0.000137   0.000034   call xtabline#tab#check_all()
    2   0.000185   0.000034   call xtabline#tab#check_index()
                            
                              " no room for a full tabline
    2              0.000021   if &columns < 40 | return s:format_right_corner() | endif
                            
                              " reuse last tabline because there's no need to update it
    2   0.000814   0.000037   if s:reuse_last_tabline()
                                return g:xtabline.last_tabline
    2              0.000002   endif
                            
    2              0.000008   if s:v.tabline_mode == 'tabs'
    2   0.004375   0.000034     return s:render_tabs()
                              else
                                return s:render_buffers()
                              endif

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 6 times
Total time:   0.002820
 Self time:   0.000207

count  total (s)   self (s)
    6              0.000014   if a:group1 == a:group2
                                return 0
    6              0.000004   endif
    6   0.001429   0.000071   let color1 = airline#highlighter#get_highlight(a:group1)
    6   0.001321   0.000067   let color2 = airline#highlighter#get_highlight(a:group2)
    6              0.000039   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 1 time
Total time:   0.000027
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000021   0.000011   call <sid>check_defined_section(a:name)
    1              0.000005   let w:airline_section_{a:name} .= a:value

FUNCTION  <SNR>165_format_right_corner()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:511
Called 2 times
Total time:   0.001004
 Self time:   0.000300

count  total (s)   self (s)
                              " Label for the upper right corner. {{{1
    2              0.000013   let N = tabpagenr()
                            
                              " tab-local/window-local working directory indicator
    2              0.000008   if s:Sets.wd_type_indicator
                                let lcd   = haslocaldir(winnr(), tabpagenr()) == 1    ? '%#XTSpecial# W '   : exists(':tcd') == 2 && haslocaldir(-1, 0) ? '%#XTSpecial# T ' : ''
    2              0.000003   else
    2              0.000005     let lcd = ''
    2              0.000002   endif
                            
    2   0.000041   0.000031   if has_key(s:T(), 'corner')
                                " special right corner with its own label
                                return s:T()['corner']
                            
    2              0.000007   elseif !s:Sets.show_right_corner
                                " no label, just the tab number in form n/N
                                return s:v.tabline_mode == 'tabs' || s:hide_tab_number() ? lcd : s:tab_num(N) . lcd
                            
    2              0.000014   elseif s:v.tabline_mode == 'tabs' || s:hide_tab_number()
                                " no number, just the name or the cwd
    2              0.000008     let hi    = "%#XTCorner#"
    2   0.000195   0.000037     let icon  = "%#XTNumSel# " . s:get_tab_icon(N, 1)
    2   0.000154   0.000037     let mod   = s:tab_mod_flag(N, 1)
    2   0.000453   0.000035     let label = s:right_corner_label()
    2              0.000024     return printf("%s%s %s %s", icon, hi, label, mod) . lcd
                            
                              else
                                " tab number in form n/N, plus tab name or cwd
                                let hi    = "%#XTCorner#"
                                let nr    = s:tab_num(N)
                                let icon  = s:get_tab_icon(N, 1)
                                let mod   = s:tab_mod_flag(N, 1)
                                let label = s:right_corner_label()
                                return printf("%s%s %s%s %s", nr, hi, icon, label, mod) . lcd
                              endif

FUNCTION  airline#check_mode()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline.vim:216
Called 56 times
Total time:   0.184929
 Self time:   0.013631

count  total (s)   self (s)
   56              0.000354   if !has_key(s:contexts, a:winnr)
                                return ''
   56              0.000103   endif
   56              0.000383   let context = s:contexts[a:winnr]
                            
   56              0.000306   if get(w:, 'airline_active', 1)
   56              0.000281     let m = mode(1)
   56              0.000192     if m ==# "i"
                                  let mode = ['insert']
   56              0.000229     elseif m[0] ==# "i"
                                  let mode = ['insert']
   56              0.000104     elseif m ==# "Rv"
                                  let mode =['replace']
   56              0.000113     elseif m[0] ==# "R"
                                  let mode = ['replace']
   56              0.000857     elseif m[0] =~# '\v(v|V||s|S|)'
                                  let mode = ['visual']
   56              0.000099     elseif m ==# "t"
                                  let mode = ['terminal']
   56              0.000105     elseif m[0] ==# "c"
    2              0.000012       let mode = ['commandline']
   54              0.000126     elseif m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let mode = ['normal']
   54              0.000160     elseif m[0:1] ==# 'ni'
                                  let mode = ['insert']
                                  let m = 'ni'
   54              0.000059     else
   54              0.000213       let mode = ['normal']
   56              0.000058     endif
   56   0.001790   0.001045     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
   56              0.000060     endif
   56              0.000589     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], m) == -1
   56              0.000187       let m = m[0]
   56              0.000056     endif
   56              0.000452     let w:airline_current_mode = get(g:airline_mode_map, m, m)
                              else
                                let mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   56              0.000060   endif
                            
   56              0.000351   if g:airline_detect_modified && &modified
                                call add(mode, 'modified')
   56              0.000049   endif
                            
   56              0.000173   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
   56              0.000042   endif
                            
   56              0.000957   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
   56              0.000046   endif
                            
   56              0.000182   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
   56              0.000040   endif
                            
   56              0.000172   if &readonly || ! &modifiable
    3              0.000027     call add(mode, 'readonly')
   56              0.000041   endif
                            
   56              0.000382   let mode_string = join(mode)
   56              0.000372   if get(w:, 'airline_lastmode', '') != mode_string
    4   0.003841   0.000142     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    4   0.166261   0.000207     call airline#highlighter#highlight(mode, string(context.bufnr))
    4   0.000949   0.000149     call airline#util#doautocmd('AirlineModeChanged')
    4              0.000030     let w:airline_lastmode = mode_string
   56              0.000045   endif
                            
   56              0.000113   return ''

FUNCTION  <SNR>129_hl_group_exists()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:99
Called 110 times
Total time:   0.004055
 Self time:   0.004055

count  total (s)   self (s)
  110              0.001260     if !hlexists(a:group)
                                  return 0
  110              0.001709     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
  110              0.000161     endif
  110              0.000205     return 1

FUNCTION  xtabline#tab#check_index()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/tab.vim:76
Called 2 times
Total time:   0.000151
 Self time:   0.000136

count  total (s)   self (s)
                              " Ensure g:xtabline.Tabs[tabpagenr()-1] matches t:xtab.
    2              0.000025   if !has_key(t:, 'xtab') | return | endif
                            
                              " t:xtab is generally the same dictionary as g:xtabline.Tabs[tabpagenr()-1]
                              " but if a tab is moved with :tabmove, they will be mismatched
                              " this is checked at every tabline refresh, to ensure the correct order
                            
    2              0.000013   let XT = g:xtabline.Tabs
    2   0.000059   0.000044   if t:xtab isnot s:T() && index(XT, t:xtab) >= 0
                                let old_position = index(XT, t:xtab)
                                let new_position = tabpagenr()-1
                                call insert(XT, remove(XT, old_position), new_position)
                                let s:v.time_to_update = 1
    2              0.000002   endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 1 time
Total time:   0.000030
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000026   0.000010   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
    1              0.000003   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>88_InitAndHandleActivity()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:565
Called 1 time
Total time:   0.000504
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000023   0.000010         call s:SetupDebugMode()
    1   0.000032   0.000008         call s:SetupConfigFile()
    1   0.000449   0.000012         call s:HandleActivity(a:is_write)

FUNCTION  bm#compare_lines()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:202
Called 2 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    2              0.000015   let line1 = str2nr(a:line_str1)
    2              0.000010   let line2 = str2nr(a:line_str2)
    2              0.000039   return line1 ==# line2 ? 0 : line1 > line2 ? 1 : -1

FUNCTION  <SNR>88_GetCommandPrefix()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:316
Called 1 time
Total time:   0.000728
 Self time:   0.000112

count  total (s)   self (s)
    1              0.000021         if exists("g:wakatime_OverrideCommandPrefix") && g:wakatime_OverrideCommandPrefix != ''
                                        let prefix = [g:wakatime_OverrideCommandPrefix]
    1              0.000003         else
    1   0.000662   0.000046             let python_bin = s:GetPythonBinary()
    1              0.000019             let prefix = [python_bin, '-W', 'ignore', s:cli_location]
    1              0.000004         endif
    1              0.000006         return prefix

FUNCTION  <SNR>71_dir()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 2 times
Total time:   0.000146
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000145   0.000036   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 1 time
Total time:   0.000043
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000042   0.000016   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>75_auto_save()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:511
Called 1 time
Total time:   0.003953
 Self time:   0.000730

count  total (s)   self (s)
    1              0.000018   if g:bm_current_file !=# ''
    1   0.003290   0.000067     call BookmarkSave(s:bookmark_save_file(g:bm_current_file), 1)
    1              0.000003   endif
    1              0.000014   augroup bm_auto_save
    1              0.000614     autocmd!
    1              0.000008   augroup END

FUNCTION  <SNR>95_has()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:172
Called 40 times
Total time:   0.001119
 Self time:   0.001119

count  total (s)   self (s)
                              " We do not want a:dir to be treated as a glob so escape any wildcards.
                              " If this approach is problematic (e.g. on Windows), an alternative
                              " might be to change directory to a:dir, call globpath() with just
                              " a:identifier, then restore the working directory.
   40              0.001048   return !empty(globpath(escape(a:dir, '?*[]'), a:identifier, 1))

FUNCTION  <SNR>176_parse_screen()
    Defined: ~/.config/nvim/plugged/vim-css-color/autoload/css_color.vim:262
Called 15 times
Total time:   0.012943
 Self time:   0.012699

count  total (s)   self (s)
   15              0.000179 	let leftcol = winsaveview().leftcol
   15              0.000125 	let left = max([ leftcol - 15, 0 ])
   15              0.000071 	let width = &columns * 4
   15              0.011942 	call filter( range( line('w0'), line('w$') ), 'substitute( strpart( getline(v:val), col([v:val, left]), width ), b:css_color_pat, ''\=s:create_syn_match()'', ''g'' )' )
   15   0.000583   0.000339 	call s:flush_exe()

FUNCTION  <SNR>75_set_up_auto_save()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:520
Called 1 time
Total time:   0.002567
 Self time:   0.000343

count  total (s)   self (s)
    1              0.000004   if g:bookmark_auto_save ==# 1 || g:bookmark_manage_per_buffer ==# 1
    1   0.002238   0.000014     call s:startup_load_bookmarks(a:file)
    1              0.000006     let g:bm_current_file = a:file
    1              0.000005     augroup bm_auto_save
    1              0.000289       autocmd!
    1              0.000011       autocmd BufWinEnter * call s:add_missing_signs(expand('<afile>:p'))
    1              0.000011       autocmd BufLeave,VimLeave,BufReadPre * call s:auto_save()
    1              0.000001     augroup END
    1              0.000001   endif

FUNCTION  <SNR>88_GetCurrentFile()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:224
Called 15 times
Total time:   0.000570
 Self time:   0.000570

count  total (s)   self (s)
   15              0.000552         return expand("%:p")

FUNCTION  <SNR>176_flush_exe()
    Defined: ~/.config/nvim/plugged/vim-css-color/autoload/css_color.vim:84
Called 15 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
   15              0.000220 	if len(s:exe) | exe join( remove( s:exe, 0, -1 ), ' | ' ) | endif

FUNCTION  CocHelperCallFn_0_10_1()
Called 2 times
Total time:   0.000929
 Self time:   0.000142

count  total (s)   self (s)
    2              0.000007           try
    2   0.000861   0.000074             return call(g:coc_helper_module_p48565_0_10_1[a:module_key][a:method_name], a:args)
                                      catch
                                        let ex = v:exception
                                        let msg = 'error when call ' . a:module_key . '.' . a:method_name
                                        echom msg
                                        echom ex
                                        throw msg . ex
    2              0.000006           endtry

FUNCTION  <SNR>108_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:197
Called 14 times
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
   14              0.000120   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   14              0.000018   endif

FUNCTION  <SNR>163_should_illuminate_word()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:165
Called 9 times
Total time:   0.000639
 Self time:   0.000639

count  total (s)   self (s)
    9              0.000125   let ft_hl_groups = get(g:, 'Illuminate_ftHighlightGroups', {})
    9              0.000111   let hl_groups_whitelist = get(ft_hl_groups, &filetype, [])
    9              0.000097   call extend(hl_groups_whitelist, get(ft_hl_groups, '*', []))
    9              0.000040   if empty(hl_groups_whitelist)
    9              0.000093     let hl_groups_blacklist = get(ft_hl_groups, &filetype.':blacklist', [])
    9              0.000078     call extend(hl_groups_blacklist, get(ft_hl_groups, '*:blacklist', []))
    9              0.000035     if empty(hl_groups_blacklist)
    9              0.000023       return 1
                                else
                                  return index(hl_groups_blacklist, synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')) < 0 && index(hl_groups_blacklist, synIDattr(synID(line('.'), col('.'), 1), 'name')) < 0
                                endif
                              endif
                            
                              return index(ft_hl_groups[&filetype], synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')) >= 0 || index(ft_hl_groups[&filetype], synIDattr(synID(line('.'), col('.'), 1), 'name')) >= 0

FUNCTION  <SNR>38_on_cursor_moved()
    Defined: ~/.config/nvim/plugged/vim-airline/plugin/airline.vim:83
Called 14 times
Total time:   0.001244
 Self time:   0.000944

count  total (s)   self (s)
   14              0.000358   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   14              0.000041   endif
   14   0.000678   0.000377   call airline#update_tabline()

FUNCTION  <SNR>135_update_branch()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:180
Called 53 times
Total time:   0.024064
 Self time:   0.005539

count  total (s)   self (s)
  159              0.000679   for vcs in keys(s:vcs_config)
  106   0.020699   0.002174     call {s:vcs_config[vcs].update_branch}()
  106              0.000744     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  106              0.000100     endif
  159              0.000256   endfor

FUNCTION  airline#parts#crypt()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 53 times
Total time:   0.001108
 Self time:   0.001108

count  total (s)   self (s)
   53              0.001065   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>165_right_corner_label()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:551
Called 2 times
Total time:   0.000419
 Self time:   0.000097

count  total (s)   self (s)
                              " Build the label for the right corner. {{{1
                              "
                              " The label can be either:
                              " 1. the shortened cwd ('tabs' and 'buffers' mode)
                              " 2. a custom tab name ('buffers' mode)
                              " 3. the name of the active buffer for this tab ('buffers' mode)
                              " 4. the number/total files in the arglist ('arglist' mode)
                              "
                              " Returns: the formatted label
    2              0.000008   let N = tabpagenr()
                            
    2              0.000009   if s:v.tabline_mode == 'tabs'
    2   0.000388   0.000066     return s:v.user_labels && !empty(s:T().name)   ? s:T().name : s:F.short_cwd(N, 1)
                            
                              elseif s:v.tabline_mode == 'buffers' || s:v.tabline_mode == 'arglist'
                                return s:v.user_labels && !empty(s:T().name) ? s:T().name : s:F.short_cwd(N, 1)
                              endif

FUNCTION  <SNR>88_SanitizeArg()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:228
Called 12 times
Total time:   0.000338
 Self time:   0.000338

count  total (s)   self (s)
   12              0.000136         let sanitized = shellescape(a:arg)
   12              0.000145         let sanitized = substitute(sanitized, '!', '\\!', 'g')
   12              0.000042         return sanitized

FUNCTION  <SNR>88_SetupConfigFile()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:125
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000002         if !s:config_file_already_setup
                            
                                        " Create config file if does not exist
                                        if !filereadable(s:config_file)
                                            call writefile(s:default_configs, s:config_file)
                                        endif
                            
                                        " Make sure config file has api_key
                                        let found_api_key = s:false
                                        if s:GetIniSetting('settings', 'api_key') != '' || s:GetIniSetting('settings', 'apikey') != ''
                                            let found_api_key = s:true
                                        endif
                                        if !found_api_key
                                            call s:PromptForApiKey()
                                            echo "[WakaTime] Setup complete! Visit https://wakatime.com to view your coding activity."
                                        endif
                            
                                        let s:config_file_already_setup = s:true
    1              0.000001         endif

FUNCTION  <SNR>75_refresh_line_numbers()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:397
Called 1 time
Total time:   0.000919
 Self time:   0.000149

count  total (s)   self (s)
    1   0.000782   0.000035   call s:lazy_init()
    1              0.000060   let file = expand("%:p")
    1   0.000070   0.000047   if file ==# "" || !bm#has_bookmarks_in_file(file)
    1              0.000002     return
                              endif
                              let bufnr = bufnr(file)
                              let sign_line_map = bm_sign#lines_for_signs(file)
                              for sign_idx in keys(sign_line_map)
                                let line_nr = sign_line_map[sign_idx]
                                let line_content = getbufline(bufnr, line_nr)
                                let content = len(line_content) > 0 ? line_content[0] : ' '
                                call bm#update_bookmark_for_sign(file, sign_idx, line_nr, content)
                              endfor

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:246
Called 53 times
Total time:   0.053819
 Self time:   0.013405

count  total (s)   self (s)
   53              0.000298   if !exists('b:buffer_vcs_config')
    1   0.000048   0.000012     call s:init_buffer()
   53              0.000045   endif
                            
   53   0.024822   0.000758   call s:update_branch()
   53   0.016034   0.000995   call s:update_untracked()
                            
   53              0.000385   if exists('b:airline_head') && !empty(b:airline_head)
                                return b:airline_head
   53              0.000045   endif
                            
   53              0.000166   let b:airline_head = ''
   53              0.000463   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
   53              0.000135   let heads = []
  159              0.000381   for vcs in vcs_priority
  106              0.000506     if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
  106              0.000091     endif
  159              0.000209   endfor
                            
   53              0.000142   for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
   53              0.000088   endfor
                            
   53              0.000155   if empty(heads)
   53   0.001616   0.000746     if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
   53              0.000052     endif
   53              0.000047   endif
                            
   53              0.000135   if empty(heads)
   53   0.001054   0.000650     if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
   53              0.000056     endif
   53              0.000041   endif
                            
   53              0.000303   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
   53              0.000042   endif
                            
   53              0.000140   return b:airline_head

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 4 times
Total time:   0.003699
 Self time:   0.000378

count  total (s)   self (s)
    4              0.000042     if getbufvar(a:bufnr, '&modified')
                                  let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000007     else
    4              0.000106       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    4              0.000006     endif
                            
    4              0.000019     if !empty(colors)
    4   0.003451   0.000131       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    4              0.000006     endif

FUNCTION  <SNR>102_notify()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/client.vim:189
Called 24 times
Total time:   0.003837
 Self time:   0.003529

count  total (s)   self (s)
   24   0.000774   0.000467   let channel = coc#client#get_channel(self)
   24              0.000094   if empty(channel)
                                return ''
   24              0.000025   endif
   24              0.000046   try
   24              0.000053     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
   24              0.000037     else
   24              0.001125       call call('rpcnotify', [channel, a:method] + a:args)
   24              0.000049     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   24              0.000052   endtry

FUNCTION  <SNR>135_update_untracked()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:199
Called 53 times
Total time:   0.015039
 Self time:   0.009254

count  total (s)   self (s)
   53              0.001568   let file = expand("%:p")
   53              0.000733   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
   53              0.000049   endif
                            
   53              0.000167   let needs_update = 1
   53              0.000513   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  159              0.000586   for vcs in keys(s:vcs_config)
  106              0.000910     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  106              0.000098     endif
  106              0.000546     if has_key(s:vcs_config[vcs].untracked, file)
   51              0.000140       let needs_update = 0
   51   0.002439   0.001104       call airline#extensions#branch#update_untracked_config(file, vcs)
  106              0.000105     endif
  159              0.000209   endfor
                            
   53              0.000141   if !needs_update
   51              0.000103     return
    2              0.000001   endif
                            
    6              0.000025   for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
    4   0.000057   0.000039     if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
    4   0.000071   0.000041     elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
    2              0.000003       continue
    2              0.000001     endif
    2              0.000005     let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
    2              0.000007     if index(vcs_checks, 'untracked') > -1
    2   0.002722   0.000191       call airline#async#vcs_untracked(config, file, vcs)
    2              0.000002     endif
                                " Check clean state of repo
    2              0.000010     if index(vcs_checks, 'dirty') > -1
    2   0.001931   0.000060       call airline#async#vcs_clean(config.dirty, file, vcs)
    2              0.000005     endif
    4              0.000026   endfor

FUNCTION  bm#has_bookmarks_in_file()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:8
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000012   if !has_key(g:line_map, a:file)
    1              0.000007     return 0
                              endif
                              return len(keys(g:line_map[a:file])) > 0

FUNCTION  <SNR>179_on_exit_nvim()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003   if !a:exit_code
                                call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    1              0.000001   endif

FUNCTION  airline#parts#mode()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 53 times
Total time:   0.004129
 Self time:   0.001043

count  total (s)   self (s)
   53   0.004070   0.000983   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  xtabline#update()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:157
Called 3 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
                              " Set the variable that triggers tabline update. {{{1
    3              0.000050   if !s:Sets.enabled
                                return
    3              0.000035   elseif empty(s:Sets.tabline_modes)
                                set tabline=
    3              0.000033   elseif exists('b:xtabline_override')
                                let &tabline = b:xtabline_override
    3              0.000006   else
    3              0.000013     if a:0
                                  call xtabline#filter_buffers()
    3              0.000005     endif
    3              0.000029     let s:v.time_to_update = 1
    3              0.000076     set tabline=%!xtabline#render#tabline()
    3              0.000007   endif

FUNCTION  bm_sign#init()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm_sign.vim:14
Called 1 time
Total time:   0.000194
 Self time:   0.000058

count  total (s)   self (s)
    1   0.000147   0.000011   call bm_sign#define_highlights()
    1              0.000007   sign define Bookmark texthl=BookmarkSign
    1              0.000002   sign define BookmarkAnnotation texthl=BookmarkAnnotationSign
    1              0.000008   execute "sign define Bookmark text=". g:bookmark_sign
    1              0.000005   execute "sign define BookmarkAnnotation text=". g:bookmark_annotation_sign
    1              0.000002   if g:bookmark_highlight_lines
                                sign define Bookmark linehl=BookmarkLine
                                sign define BookmarkAnnotation linehl=BookmarkAnnotationLine
    1              0.000001   else
    1              0.000009     sign define Bookmark linehl=
    1              0.000008     sign define BookmarkAnnotation linehl=
    1              0.000001   endif

FUNCTION  <SNR>95_rootless()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:234
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000004   let dir = ''
    2              0.000006   if g:rooter_change_directory_for_non_project_files ==? 'current'
                                let dir = s:current()
    2              0.000005   elseif g:rooter_change_directory_for_non_project_files ==? 'home'
                                let dir = $HOME
    2              0.000001   endif
    2              0.000010   if !empty(dir) | call s:cd(dir) | endif

FUNCTION  <SNR>165_format_tab_label()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:373
Called 2 times
Total time:   0.002182
 Self time:   0.000277

count  total (s)   self (s)
                              " Format the tab label in 'tabs' mode {{{1
                              "
                              " @param tnr: the tab's number
                              " Returns: a tab 'object' with label and highlight groups
                            
    2   0.000109   0.000044   let nr    = '%' . a:tnr . 'T' . s:tab_num(a:tnr)
    2   0.000076   0.000035   let hi    = s:tab_hi(a:tnr)
    2   0.001240   0.000040   let icon  = s:get_tab_icon(a:tnr, 0)
    2   0.000505   0.000044   let label = s:tab_label(a:tnr)
    2   0.000188   0.000049   let mod   = s:tab_mod_flag(a:tnr, 0)
                            
    2              0.000030   let label = printf("%s%%#XT%s# %s%s %s", nr, hi, icon, label, mod)
                            
    2              0.000021   return {'label': label, 'nr': a:tnr, 'hilite': hi}

FUNCTION  <SNR>129_GetHiCmd()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:140
Called 37 times
Total time:   0.009029
 Self time:   0.009029

count  total (s)   self (s)
                                " a:list needs to have 5 items!
   37              0.000127     let res = ''
   37              0.000118     let i = -1
  222              0.000539     while i < 4
  185              0.000496       let i += 1
  185              0.000992       let item = get(a:list, i, '')
  185              0.000492       if item is ''
   29              0.000051         continue
  156              0.000177       endif
  156              0.000314       if i == 0
   37              0.000249         let res .= ' guifg='.item
  119              0.000240       elseif i == 1
   37              0.000173         let res .= ' guibg='.item
   82              0.000131       elseif i == 2
   37              0.000169         let res .= ' ctermfg='.item
   45              0.000069       elseif i == 3
   37              0.000147         let res .= ' ctermbg='.item
    8              0.000013       elseif i == 4
    8              0.000081         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  156              0.000162       endif
  193              0.000351     endwhile
   37              0.000111     return res

FUNCTION  <SNR>99_Autocmd()
    Defined: ~/.config/nvim/plugged/coc.nvim/plugin/coc.vim:245
Called 22 times
Total time:   0.005420
 Self time:   0.000599

count  total (s)   self (s)
   22              0.000108   if !g:coc_service_initialized
                                return
   22              0.000024   endif
   22   0.005205   0.000384   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/util.vim:204
Called 1 time
Total time:   0.000645
 Self time:   0.000231

count  total (s)   self (s)
    1              0.000007   if !bufloaded(a:bufnr) | return v:null | endif
    1              0.000003   let bufname = bufname(a:bufnr)
    1              0.000005   let buftype = getbufvar(a:bufnr, '&buftype')
    1              0.000002   let previewwindow = 0
    1              0.000003   let winid = bufwinid(a:bufnr)
    1              0.000002   if winid != -1
    1              0.000005     let previewwindow = getwinvar(winid, '&previewwindow', 0)
    1              0.000001   endif
    1              0.000001   let size = -1
    1              0.000003   if bufnr('%') == a:bufnr
    1              0.000007     let size = line2byte(line("$") + 1)
                              elseif !empty(bufname)
                                let size = getfsize(bufname)
    1              0.000001   endif
    1              0.000002   let lines = []
    1              0.000007   if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite') && size < a:maxFileSize
    1              0.000112     let lines = getbufline(a:bufnr, 1, '$')
    1              0.000001   endif
    1   0.000476   0.000062   return { 'bufname': bufname, 'size': size, 'buftype': buftype, 'winid': winid, 'previewwindow': previewwindow == 0 ? v:false : v:true, 'variables': s:variables(a:bufnr), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), 'eol': getbufvar(a:bufnr, '&eol'), 'filetype': getbufvar(a:bufnr, '&filetype'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'), 'lines': lines,}

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    1              0.000001   endif

FUNCTION  <SNR>179_on_stderr_nvim()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 2 times
Total time:   0.000061
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000006   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
    1   0.000050   0.000012     call self.handler.err(self.buffer)
    2              0.000001   endif

FUNCTION  <SNR>179_build_command()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000003   if has('unix')
    1              0.000003     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  <SNR>95_match()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:145
Called 50 times
Total time:   0.002037
 Self time:   0.000805

count  total (s)   self (s)
   50              0.000087   if a:pattern[0] == '='
   10   0.000181   0.000067     return s:is(a:dir, a:pattern[1:])
   40              0.000058   elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
   40              0.000050   elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
   40              0.000022   else
   40   0.001363   0.000245     return s:has(a:dir, a:pattern)
                              endif

FUNCTION  airline#mode_changed()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline.vim:296
Called 4 times
Total time:   0.000270
 Self time:   0.000208

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    4              0.000118   let g:airline#visual_active = (mode() =~? '[vs]')
    4   0.000136   0.000073   call airline#update_tabline()

FUNCTION  <SNR>150_add_section()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 8 times
Total time:   0.000896
 Self time:   0.000293

count  total (s)   self (s)
    8              0.000049     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
    8   0.000168   0.000053     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
    8              0.000004     endif
    8              0.000008     if condition
                                  call a:builder.add_raw('%(')
    8              0.000004     endif
    8   0.000601   0.000113     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
    8              0.000009     if condition
                                  call a:builder.add_raw('%)')
    8              0.000004     endif

FUNCTION  gitgutter#async#execute()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 1 time
Total time:   0.002081
 Self time:   0.001889

count  total (s)   self (s)
    1   0.000391   0.000206   call gitgutter#debug#log('[async] '.a:cmd)
                            
    1              0.000007   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    1   0.000017   0.000010   let command = s:build_command(a:cmd)
                            
    1              0.000004   if has('nvim')
    1              0.001637     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    1              0.000001   endif

FUNCTION  <SNR>9_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:33
Called 1 time
Total time:   0.091668
 Self time:   0.005014

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000010   syn clear
    1              0.000012   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000002   endif
                            
    1              0.000012   let s = expand("<amatch>")
    1              0.000006   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000004   elseif s == "OFF"
                                let s = ""
    1              0.000001   endif
                            
    1              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000024     for name in split(s, '\.')
    1              0.000006       if !empty(name)
    1   0.089965   0.003311         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.001567         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    1              0.000002       endif
    2              0.000003     endfor
    1              0.000001   endif

FUNCTION  syntastic#util#fname2buf()
    Defined: ~/.config/nvim/plugged/syntastic/autoload/syntastic/util.vim:306
Called 4 times
Total time:   0.000462
 Self time:   0.000462

count  total (s)   self (s)
    4              0.000026     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
    4              0.000005     endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    4              0.000014     let buf = -1
    4              0.000029     for md in [':~:.', ':~', ':p']
    4              0.000010         try
                                        " Older versions of Vim can throw E94 here
    4              0.000168             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
                                    catch
                                        " catch everything
    4              0.000008         endtry
    4              0.000013         if buf != -1
    4              0.000007             break
                                    endif
    4              0.000019     endfor
    4              0.000011     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
    4              0.000004     endif
                            
    4              0.000019     if exists('+shellslash')
                                    let &shellslash = old_shellslash
    4              0.000003     endif
                            
    4              0.000012     return buf

FUNCTION  <SNR>38_on_window_changed()
    Defined: ~/.config/nvim/plugged/vim-airline/plugin/airline.vim:51
Called 4 times
Total time:   0.014022
 Self time:   0.000490

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
    4              0.000030   if &buftype is# 'popup'
                                return
    4              0.000006   endif
                            
    4              0.000031   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
    4              0.000004   endif
    4              0.000040   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    4              0.000099   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    4              0.000172   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    3              0.000008     return
    1              0.000001   endif
    1              0.000006   let g:airline_last_window_changed = l:key
    1   0.000013   0.000009   call s:init()
    1   0.013540   0.000013   call airline#update_statusline()

FUNCTION  <SNR>149_get_accented_line()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 8 times
Total time:   0.000509
 Self time:   0.000509

count  total (s)   self (s)
    8              0.000017   if a:self._context.active
                                " active window
    8              0.000016     let contents = []
    8              0.000066     let content_parts = split(a:contents, '__accent')
   21              0.000038     for cpart in content_parts
   13              0.000102       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   13              0.000040       call add(contents, cpart)
   21              0.000019     endfor
    8              0.000035     let line = join(contents, a:group)
    8              0.000063     let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
    8              0.000005   endif
    8              0.000012   return line

FUNCTION  <SNR>163_remove_illumination()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:134
Called 19 times
Total time:   0.001692
 Self time:   0.001692

count  total (s)   self (s)
   19              0.000288   if has('timers') && exists('s:timer_id') && s:timer_id > -1
                                call timer_stop(s:timer_id)
                                let s:timer_id = -1
   19              0.000023   endif
                            
   19              0.000093   if exists('w:match_id')
   19              0.000039     try
   19              0.000267       call matchdelete(w:match_id)
   13              0.000234     catch /\v(E803|E802)/
   19              0.000056     endtry
   19              0.000023   endif
                            
   19              0.000105   if exists('w:match_curword_id')
                                try
                                  call matchdelete(w:match_curword_id)
                                catch /\v(E803|E802)/
                                endtry
   19              0.000019   endif
                            
   19              0.000078   let s:previous_match = ''

FUNCTION  <SNR>95_parent()
    Defined: ~/.config/nvim/plugged/vim-rooter/plugin/rooter.vim:218
Called 10 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
   10              0.000031   return fnamemodify(a:dir, ':h')

FUNCTION  <SNR>85_getDistro()
    Defined: ~/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:96
Called 53 times
Total time:   0.015240
 Self time:   0.000493

count  total (s)   self (s)
   53              0.000195   if exists('s:distro')
   52              0.000113     return s:distro
    1              0.000001   endif
                            
    1              0.000043   if g:DevIconsEnableDistro && executable('lsb_release')
    1   0.014782   0.000034     let s:lsb = system('lsb_release -i')
    1              0.000025     if s:lsb =~# 'Arch'
    1              0.000005       let s:distro = ''
                                elseif s:lsb =~# 'Gentoo'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Ubuntu'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Cent'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Debian'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Dock'
                                  let s:distro = ''
                                else
                                  let s:distro = ''
    1              0.000001     endif
    1              0.000005     return s:distro
                              endif
                            
                              let s:distro = ''
                              return s:distro

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter.vim:107
Called 1 time
Total time:   0.000681
 Self time:   0.000638

count  total (s)   self (s)
    1              0.000002   if !g:gitgutter_map_keys
                                return
    1              0.000001   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    1              0.000003   let bufnr = bufnr('')
                            
    1   0.000027   0.000011   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
                                return
    1              0.000000   endif
                            
    1              0.000063   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
    1              0.000022     nmap <buffer> [c <Plug>(GitGutterPrevHunk)
    1              0.000001   endif
    1              0.000043   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
    1              0.000018     nmap <buffer> ]c <Plug>(GitGutterNextHunk)
    1              0.000001   endif
                            
    1              0.000039   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
    1              0.000020     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    1              0.000001   endif
    1              0.000043   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
    1              0.000019     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    1              0.000001   endif
    1              0.000040   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
    1              0.000017     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
    1              0.000001   endif
    1              0.000037   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
    1              0.000017     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
    1              0.000001   endif
                            
    1              0.000036   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
    1              0.000018     omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
    1              0.000001   endif
    1              0.000034   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
    1              0.000016     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
    1              0.000001   endif
    1              0.000034   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
    1              0.000018     xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
    1              0.000001   endif
    1              0.000033   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
    1              0.000016     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
    1              0.000001   endif
                            
    1   0.000046   0.000019   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  bm#deserialize()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:178
Called 1 time
Total time:   0.000345
 Self time:   0.000216

count  total (s)   self (s)
    1              0.000039     exec join(a:data, " | ")
    1              0.000003     let ses = l:bm_sessions["default"]
    1              0.000002     let result = []
    4              0.000008     for file in keys(ses)
    7              0.000012       for bm in ses[file]
    4              0.000016         let annotation = has_key(bm, 'annotation') ? bm['annotation'] : ''
    4   0.000210   0.000081          call add(result,  extend( copy( bm#add_bookmark(file, bm['sign_idx'], bm['line_nr'], bm['content'], annotation) ), {'file': file} ))
    7              0.000006       endfor
    4              0.000003     endfor
    1              0.000001     return result

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 53 times
Total time:   0.005103
 Self time:   0.000861

count  total (s)   self (s)
   53   0.005063   0.000822   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000011   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    1              0.000005   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    1              0.000002   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
    1              0.000007     let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
    1              0.000019     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
    1              0.000003     elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    1              0.000001     endif
    1              0.000001   endif
                            
    1              0.000002   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    1              0.000001   endif

FUNCTION  <lambda>1()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:15
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return s:X.Tabs[tabpagenr()-1] 

FUNCTION  <lambda>8()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:23
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return !exists('g:SessionLoad') 

FUNCTION  <lambda>9()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:13
Called 4 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            return tabpagebuflist(tabpagenr()) 

FUNCTION  <SNR>88_SendHeartbeats()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:326
Called 1 time
Total time:   0.007369
 Self time:   0.005749

count  total (s)   self (s)
    1              0.000018         let start_time = localtime()
    1              0.000007         let stdout = ''
                            
    1              0.000013         if len(s:heartbeats_buffer) == 0
                                        let s:last_sent = start_time
                                        return
    1              0.000002         endif
                            
    1              0.000013         let heartbeat = s:heartbeats_buffer[0]
    1              0.000016         let s:heartbeats_buffer = s:heartbeats_buffer[1:-1]
    1              0.000009         if len(s:heartbeats_buffer) > 0
                                        let extra_heartbeats = s:GetHeartbeatsJson()
    1              0.000003         else
    1              0.000007             let extra_heartbeats = ''
    1              0.000003         endif
                            
    1   0.000799   0.000071         let cmd = s:GetCommandPrefix() + ['--entity', heartbeat.entity]
    1              0.000023         let cmd = cmd + ['--time', heartbeat.time]
    1   0.000113   0.000070         let cmd = cmd + ['--plugin', printf('vim/%s vim-wakatime/%s', s:n2s(v:version), s:VERSION)]
    1              0.000008         if heartbeat.is_write
                                        let cmd = cmd + ['--write']
    1              0.000003         endif
    1              0.000012         if has_key(heartbeat, 'language')
    1              0.000025             let cmd = cmd + ['--language', heartbeat.language]
    1              0.000003         endif
    1              0.000011         if extra_heartbeats != ''
                                        let cmd = cmd + ['--extra-heartbeats']
    1              0.000002         endif
                            
                                    " overwrite shell
    1              0.000027         let [sh, shellcmdflag, shrd] = [&shell, &shellcmdflag, &shellredir]
    1   0.000084   0.000038         if !s:IsWindows()
    1              0.000039             set shell=sh shellredir=>%s\ 2>&1
    1              0.000002         endif
                            
    1              0.000004         if s:has_async
                                        if s:IsWindows()
                                            let job_cmd = [&shell, &shellcmdflag] + cmd
                                        else
                                            let job_cmd = [&shell, &shellcmdflag, s:JoinArgs(cmd)]
                                        endif
                                        let job = job_start(job_cmd, { 'stoponexit': '', 'callback': {channel, output -> s:AsyncHandler(output, cmd)}})
                                        if extra_heartbeats != ''
                                            let channel = job_getchannel(job)
                                            call ch_sendraw(channel, extra_heartbeats . "\n")
                                        endif
    1              0.000004         elseif s:nvim_async
    1   0.000045   0.000020             if s:IsWindows()
                                            let job_cmd = cmd
    1              0.000002             else
    1   0.000810   0.000033                 let job_cmd = [&shell, &shellcmdflag, s:JoinArgs(cmd)]
    1              0.000002             endif
    1              0.000007             let s:nvim_async_output = ['']
    1              0.004661             let job = jobstart(job_cmd, { 'detach': 1, 'on_stdout': function('s:NeovimAsyncOutputHandler'), 'on_stderr': function('s:NeovimAsyncOutputHandler'), 'on_exit': function('s:NeovimAsyncExitHandler')})
    1              0.000032             if extra_heartbeats != ''
                                            call jobsend(job, extra_heartbeats . "\n")
    1              0.000006             endif
                                    elseif s:IsWindows()
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')', extra_heartbeats)
                                            else
                                                let stdout = system('(' . s:JoinArgs(cmd) . ')')
                                            endif
                                        else
                                            exec 'silent !start /b cmd /c "' . s:JoinArgs(cmd) . ' > nul 2> nul"'
                                        endif
                                    else
                                        if s:is_debug_on
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd), extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd))
                                            endif
                                        else
                                            if extra_heartbeats != ''
                                                let stdout = system(s:JoinArgs(cmd) . ' &', extra_heartbeats)
                                            else
                                                let stdout = system(s:JoinArgs(cmd) . ' &')
                                            endif
                                        endif
    1              0.000002         endif
                            
                                    " restore shell
    1              0.000083         let [&shell, &shellcmdflag, &shellredir] = [sh, shellcmdflag, shrd]
                            
    1              0.000023         let s:last_sent = localtime()
                            
                                    " need to repaint in case a key was pressed while sending
    1              0.000014         if !s:has_async && !s:nvim_async && s:redraw_setting != 'disabled'
                                        if s:redraw_setting == 'auto'
                                            if s:last_sent - start_time > 0
                                                redraw!
                                            endif
                                        else
                                            redraw!
                                        endif
    1              0.000002         endif
                            
    1              0.000008         if s:is_debug_on && stdout != ''
                                        echoerr '[WakaTime] Heartbeat Command: ' . s:JoinArgs(cmd) . "\n[WakaTime] Error: " . stdout
    1              0.000003         endif

FUNCTION  WebDevIconsGetFileFormatSymbol()
    Defined: ~/.config/nvim/plugged/vim-devicons/plugin/webdevicons.vim:556
Called 53 times
Total time:   0.028207
 Self time:   0.003956

count  total (s)   self (s)
   53              0.000232   let fileformat = ''
   53              0.000133   let bomb = ''
                            
   53              0.000285   if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
   53              0.000054   endif
                            
   53              0.000177   if &fileformat ==? 'dos'
                                let fileformat = ''
   53              0.000151   elseif &fileformat ==? 'unix'
   53   0.024793   0.001232     let fileformat = s:isDarwin() ? '' : s:getDistro()
                              elseif &fileformat ==? 'mac'
                                let fileformat = ''
   53              0.000049   endif
                            
   53   0.001409   0.000719   let artifactFix = s:DevIconsGetArtifactFix()
                            
   53              0.000238   return bomb . fileformat . artifactFix

FUNCTION  <SNR>71_is_file_buffer()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  airline#statusline()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline.vim:207
Called 56 times
Total time:   0.001710
 Self time:   0.001710

count  total (s)   self (s)
   56              0.000774   if has_key(s:contexts, a:winnr)
   56              0.000775     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>165_render_tabs()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:63
Called 2 times
Total time:   0.004341
 Self time:   0.000189

count  total (s)   self (s)
                              " Tabline rendering in 'tabs' mode {{{1
    2              0.000010   let center = tabpagenr()
    2              0.000007   let tabs = []
    2              0.000014   let labels = range(1, tabpagenr('$'))
                            
    4              0.000016   for tnr in labels
    2   0.002231   0.000048     call add(tabs, s:format_tab_label(tnr))
    4              0.000006   endfor
                            
    2   0.002033   0.000064   return s:fit_tabline(center, tabs)

FUNCTION  <lambda>10()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:14
Called 4 times
Total time:   0.000036
 Self time:   0.000026

count  total (s)   self (s)
                            return index(s:Funcs.wins(), b) >= 0 

FUNCTION  <lambda>11()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:5
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
                            return s:X.Tabs[tabpagenr()-1] 

FUNCTION  <lambda>13()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/funcs.vim:7
Called 1 time
Total time:   0.000009
 Self time:   0.000006

count  total (s)   self (s)
                            return s:T().buffers.order     

FUNCTION  <lambda>15()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/tab.vim:8
Called 3 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            return g:xtabline.Tabs[tabpagenr()-1] 

FUNCTION  coc#highlight#clear_highlight()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/highlight.vim:230
Called 15 times
Total time:   0.001796
 Self time:   0.001599

count  total (s)   self (s)
   15              0.000381   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
   15              0.000119   if !bufloaded(bufnr)
    1              0.000001     return
   14              0.000031   endif
   14   0.000638   0.000441   let src_id = coc#highlight#create_namespace(a:key)
   14              0.000144   if has('nvim')
   14              0.000205     call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
   14              0.000017   endif

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 1 time
Total time:   0.000236
 Self time:   0.000039

count  total (s)   self (s)
    1   0.000236   0.000038   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  airline#extensions#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 1 time
Total time:   0.000127
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000007   let filetype_overrides = get(s:, 'filetype_overrides', {})
    1              0.000008   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    1   0.000059   0.000009   if s:is_excluded_window()
                                return -1
    1              0.000000   endif
                            
    1              0.000002   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    1              0.000000   endif
                            
    1              0.000003   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    1              0.000000   endif
                            
    1              0.000011   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    1              0.000000   endif
                            
    1              0.000002   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    1              0.000000   endif
                            
    1              0.000004   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    1              0.000001   endfor

FUNCTION  <lambda>20()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:9
Called 5 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
                            return s:X.Tabs[tabpagenr()-1] 

FUNCTION  <lambda>21()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:10
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
                            return s:X.Tabs[n-1]         

FUNCTION  <lambda>25()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:16
Called 2 times
Total time:   0.000118
 Self time:   0.000022

count  total (s)   self (s)
                            return s:buf(nr).special 

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:158
Called 55 times
Total time:   0.000667
 Self time:   0.000667

count  total (s)   self (s)
   55              0.000265   if !exists("s:has_lawrencium")
    1              0.000005     let s:has_lawrencium  = exists('*lawrencium#statusline')
   55              0.000050   endif
   55              0.000122   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:68
Called 229 times
Total time:   0.092263
 Self time:   0.040508

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
  229              0.004350     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  229              0.002288     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  229              0.000341     else
  229   0.017681   0.004184       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  229   0.015864   0.003848       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  229   0.015070   0.003622       let guifg = s:get_syn(a:group, 'fg', 'gui')
  229   0.014436   0.003434       let guibg = s:get_syn(a:group, 'bg', 'gui')
  229              0.003190       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  229              0.000565       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  229              0.000326       else
  229   0.008979   0.005186         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  229              0.000297       endif
  229              0.000219     endif
  229              0.001980     let s:hl_groups[a:group] = res
  229              0.000543     return res

FUNCTION  <SNR>88_IsWindows()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:246
Called 4 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    4              0.000109         if has('win32') || has('win64')
                                        return s:true
    4              0.000009         endif
    4              0.000020         return s:false

FUNCTION  airline#util#shorten()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:28
Called 212 times
Total time:   0.011256
 Self time:   0.007376

count  total (s)   self (s)
  212   0.007319   0.003439   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  212              0.000166   else
  212              0.000448     return a:text
                              endif

FUNCTION  <SNR>88_HandleActivity()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:571
Called 15 times
Total time:   0.004631
 Self time:   0.002603

count  total (s)   self (s)
   15   0.001004   0.000433         let file = s:GetCurrentFile()
   15              0.000540         if !empty(file) && file !~ "-MiniBufExplorer-" && file !~ "--NO NAME--" && file !~ "^term:"
   15   0.001222   0.000333             let last = s:GetLastHeartbeat()
   15              0.000080             let now = localtime()
                            
                                        " Create a heartbeat when saving a file, when the current file
                                        " changes, and when still editing the same file but enough time
                                        " has passed since the last heartbeat.
   15   0.000724   0.000400             if a:is_write || s:EnoughTimePassed(now, last) || file != last.file
    1   0.000258   0.000013                 call s:AppendHeartbeat(file, now, a:is_write, last)
   14              0.000025             else
   14              0.000091                 if now - s:last_heartbeat.last_activity_at > s:local_cache_expire
                                                call s:SetLastHeartbeatInMemory(now, last.last_heartbeat_at, last.file)
   14              0.000023                 endif
   15              0.000019             endif
                            
                                        " When buffering heartbeats disabled, no need to re-check the
                                        " heartbeats buffer.
   15              0.000048             if s:buffering_heartbeats_enabled
                            
                                            " Only send buffered heartbeats every s:send_buffer_seconds
   15              0.000073                 if now - s:last_sent > s:send_buffer_seconds
                                                call s:SendHeartbeats()
   15              0.000018                 endif
   15              0.000016             endif
   15              0.000017         endif

FUNCTION  bm#serialize()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm.vim:160
Called 1 time
Total time:   0.000882
 Self time:   0.000763

count  total (s)   self (s)
    1              0.000007   let file_version = "let l:bm_file_version = 1"
    1              0.000006   let sessions  = "let l:bm_sessions = {'default': {"
    4   0.000037   0.000027   for file in bm#all_files()
    3              0.000025     let sessions .= "'". file ."': ["
    7   0.000211   0.000102     for bm in values(bm#all_bookmarks_by_line(file))
    4              0.000090       let escaped_content = substitute(bm['content'], "'", "''", "g")
    4              0.000059       let escaped_annotation = substitute(bm['annotation'], "'", "''", "g")
    4              0.000047       let annotation = bm['annotation'] !=# "" ? ", 'annotation': '". escaped_annotation ."'" : ""
    4              0.000134       let sessions .= "{'sign_idx': ". bm['sign_idx'] .", 'line_nr': ". bm['line_nr'] .", 'content': '". escaped_content ."'". annotation ."},"
    7              0.000017     endfor
    3              0.000052     let sessions .= "],"
    4              0.000010   endfor
    1              0.000007   let sessions .= "}}"
    1              0.000007   let current_session = "let l:bm_current_session = 'default'"
    1              0.000011   return [file_version, sessions, current_session]

FUNCTION  airline#extensions#coc#get_current_function()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/coc.vim:51
Called 53 times
Total time:   0.000418
 Self time:   0.000418

count  total (s)   self (s)
   53              0.000369   return get(b:, 'coc_current_function', '')

FUNCTION  BookmarkLoad()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/plugin/bookmark.vim:216
Called 1 time
Total time:   0.002142
 Self time:   0.000111

count  total (s)   self (s)
    1              0.000005   let supports_confirm = has("dialog_con") || has("dialog_gui")
    1   0.000282   0.000009   let has_bookmarks = bm#total_count() ># 0
    1              0.000002   let confirmed = 1
    1              0.000003   if (supports_confirm && has_bookmarks && !a:silent)
                                let confirmed = confirm("Do you want to override your ". bm#total_count() ." bookmarks?", "&Yes\n&No")
    1              0.000001   endif
    1              0.000002   if (confirmed ==# 1)
    1   0.001428   0.000014     call s:remove_all_bookmarks()
    1              0.000001     try
    1              0.000030       let data = readfile(a:target_file)
    1   0.000361   0.000016       let new_entries = bm#deserialize(data)
    1              0.000001       if !a:startup
                                    for entry in new_entries
                                      call bm_sign#add_at(entry['file'], entry['sign_idx'], entry['line_nr'], entry['annotation'] !=# "")
                                    endfor
                                    if (!a:silent)
                                      echo "Bookmarks loaded"
                                    endif
                                    return 1
    1              0.000001       endif
                                catch
                                  if (!a:startup && !a:silent)
                                    echo "Failed to load/parse file"
                                  endif
                                  return 0
    1              0.000001     endtry
    1              0.000001   endif

FUNCTION  <lambda>32()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:24
Called 4 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
                            return strwidth(substitute(label, '%#\w*#\|%\d\+T', '', 'g'))   

FUNCTION  <lambda>33()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:25
Called 4 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
                            return tabpagebuflist(t)[tabpagewinnr(t)-1]                         

FUNCTION  <SNR>179_on_stdout_nvim()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000005   if empty(self.stdoutbuffer)
    1              0.000003     let self.stdoutbuffer = a:data
                              else
                                let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    1              0.000001   endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:315
Called 53 times
Total time:   0.060917
 Self time:   0.004035

count  total (s)   self (s)
   53   0.054662   0.000843   let head = airline#extensions#branch#head()
   53   0.001272   0.000879   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   53              0.000387   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   53   0.003401   0.000731   let head = airline#util#shorten(head, winwidth, minwidth)
   53              0.000400   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   53              0.000688   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 53 times
Total time:   0.003665
 Self time:   0.003665

count  total (s)   self (s)
   53              0.000700   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   53              0.000372     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   53              0.000401     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   53              0.000285     let default = get(g:, 'airline#extensions#keymap#default', '')
   53              0.000147     if (label !=# '')
   53              0.000218       let label .= ' '
   53              0.000054     endif
   53              0.000162     let keymap = &keymap
   53              0.000233     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   53              0.000048     endif
   53              0.000682     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  coc#highlight#create_namespace()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/highlight.vim:510
Called 14 times
Total time:   0.000196
 Self time:   0.000196

count  total (s)   self (s)
   14              0.000086   if type(a:key) == 0
   13              0.000042     return a:key
    1              0.000000   endif
    1              0.000003   if has_key(s:namespace_map, a:key)
                                return s:namespace_map[a:key]
    1              0.000001   endif
    1              0.000004   if has('nvim')
    1              0.000013     let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
                              else
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
    1              0.000001   endif
    1              0.000002   return s:namespace_map[a:key]

FUNCTION  xtabline#buffer#get()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/buffer.vim:45
Called 10 times
Total time:   0.000597
 Self time:   0.000204

count  total (s)   self (s)
                              " Get buffer properties while filtering.
   10   0.000581   0.000188   return get(s:X.Buffers, a:nr, get(s:X._buffers, a:nr, xtabline#buffer#add(a:nr)))

FUNCTION  <SNR>50_BufEnterHook()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim:319
Called 1 time
Total time:   0.001599
 Self time:   0.000112

count  total (s)   self (s)
    1   0.000072   0.000011     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000036   0.000019     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    1              0.000005     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000008         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000001         if idx >= 0
                                        if !has('vim_starting')
                                            call remove(s:_check_stack, -idx - 1)
                                            call s:UpdateErrors(buf, 1, [])
                                        endif
    1              0.000002         elseif &buftype ==# ''
    1   0.001440   0.000031             call s:notifiers.refresh(g:SyntasticLoclist.current())
    1              0.000001         endif
                                elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
    1              0.000001     endif

FUNCTION  rainbow_main#load()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow_main.vim:108
Called 1 time
Total time:   0.008923
 Self time:   0.000057

count  total (s)   self (s)
    1   0.000247   0.000019 	let b:rainbow_confs = rainbow_main#gen_configs(&filetype)
    2              0.000005 	for conf in b:rainbow_confs
    1   0.007101   0.000015 		call rainbow#syn(conf)
    1   0.001561   0.000011 		call rainbow#hi(conf)
    2              0.000002 	endfor

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 53 times
Total time:   0.015658
 Self time:   0.008593

count  total (s)   self (s)
   53              0.000338   if !get(w:, 'airline_active', 0)
                                return ''
   53              0.000049   endif
                              " Cache values, so that it isn't called too often
   53   0.003114   0.002188   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   53              0.000044   endif
   53   0.005513   0.000827   let hunks = airline#extensions#hunks#get_raw_hunks()
   53              0.000123   let string = ''
   53   0.001164   0.000765   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   53              0.000169   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
                                for i in [0, 1, 2]
                                  if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
   53              0.000049   endif
   53   0.001302   0.001094   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
   53              0.000043   endif
                            
   53              0.000195   let b:airline_hunks = string
   53              0.000199   let b:airline_changenr = b:changedtick
   53   0.001440   0.000594   let s:airline_winwidth = airline#util#winwidth()
   53              0.000108   return string

FUNCTION  <SNR>108_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:40
Called 14 times
Total time:   0.002629
 Self time:   0.002353

count  total (s)   self (s)
                              " Remove any previous match.
   14   0.000504   0.000228   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   14              0.000127   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   14              0.000014   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   14              0.000079   let c_lnum = line('.')
   14              0.000063   let c_col = col('.')
   14              0.000038   let before = 0
                            
   14              0.000079   let text = getline(c_lnum)
   14              0.000385   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   14              0.000064   if empty(matches)
                                let [c_before, c] = ['', '']
   14              0.000019   else
   14              0.000139     let [c_before, c] = matches[1:2]
   14              0.000017   endif
   14              0.000378   let plist = split(&matchpairs, '.\zs[:,]')
   14              0.000107   let i = index(plist, c)
   14              0.000037   if i < 0
                                " not found, in Insert mode try character before the cursor
   14              0.000094     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   14              0.000017     endif
   14              0.000029     if i < 0
                                  " not found, nothing to do
   14              0.000028       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  xtabline#queue_update()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline.vim:174
Called 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                              " Queue buffers refiltering, but only if not queued already. {{{1
                              " A timer is used to prevent that buffers deletion in batch retriggers buffer
                              " filtering every time. s:v.queued_update is set to 1 in the render script.
    1              0.000008   if !s:v.queued_update
    1              0.000008     let s:v.queued_update = 2
    1              0.000004     let s:v.time_to_update = 1
    1              0.000023     call timer_start(100, { -> execute('let s:v.queued_update = 0') })
    1              0.000002   endif

FUNCTION  bm_sign#lazy_init()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm_sign.vim:7
Called 4 times
Total time:   0.000231
 Self time:   0.000037

count  total (s)   self (s)
    4              0.000009   if g:bm_sign_init ==# 0
    1   0.000202   0.000009     call bm_sign#init()
    1              0.000005     let g:bm_sign_init = 1
    4              0.000002   endif

FUNCTION  <SNR>70_on_bufenter()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/plugin/gitgutter.vim:221
Called 1 time
Total time:   0.003880
 Self time:   0.000057

count  total (s)   self (s)
    1   0.000690   0.000009   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    1              0.000005   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
    1              0.000001   endif
                            
    1              0.000004   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    1              0.000001   else
    1   0.003163   0.000021     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    1              0.000001   endif

FUNCTION  <SNR>165_ready()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/render.vim:612
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
                              " Do not update during completion or when a session is still loading. {{{1
    2              0.000041   return mode(1) !~ '.c' && !exists('g:SessionLoad')

FUNCTION  <SNR>86_invoke_funcrefs()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline.vim:194
Called 1 time
Total time:   0.013327
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000046   0.000010   let builder = airline#builder#new(a:context)
    1   0.001844   0.000021   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    1              0.000001   if err == 1
    1   0.011408   0.000012     let a:context.line = builder.build()
    1              0.000006     let s:contexts[a:context.winnr] = a:context
    1              0.000005     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    1              0.000013     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    1              0.000001   endif

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    1              0.000001   endif

FUNCTION  <SNR>140_conflict_marker()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 1 time
Total time:   0.000652
 Self time:   0.000652

count  total (s)   self (s)
                              " Checks for git conflict markers
    1              0.000002   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    1              0.000013   if match(['rst', 'markdown'], &ft) >= 0
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
    1              0.000001   else
    1              0.000005     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    1              0.000001   endif
    1              0.000625   return search(pattern, 'nw')

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 3 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    3              0.000012   let ggvars = getbufvar(a:buffer, 'gitgutter')
    3              0.000017   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
                                return ggvars[a:varname]
    3              0.000002   endif
    3              0.000003   if a:0
    3              0.000004     return a:1
                              endif

FUNCTION  <SNR>152_InitializeVars()
    Defined: ~/.config/nvim/plugged/vim-signature/autoload/signature/sign.vim:343
Called 1 time
Total time:   0.000222
 Self time:   0.000097

count  total (s)   self (s)
                              " Description: Initialize variables
                              " Arguments:   Specify an argument to re-init
                            
    1              0.000003   if !exists('b:sig_marks')
                                " b:sig_marks = { lnum => signs_str }
    1              0.000003     let b:sig_marks = {}
                              else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_marks, 'v:key <= l:line_tot' )
    1              0.000001   endif
                            
    1              0.000002   if !exists('b:sig_markers')
                                " b:sig_markers = { lnum => marker }
    1              0.000002     let b:sig_markers = {}
                              else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_markers, 'v:key <= l:line_tot' )
    1              0.000001   endif
                            
    1   0.000033   0.000012   call signature#utils#Set('b:sig_DummyExists'         , 0                          , a:0 && a:1)
    1   0.000025   0.000009   call signature#utils#Set('b:sig_enabled'             , g:SignatureEnabledAtStartup, a:0 && a:1)
    1   0.000029   0.000010   call signature#utils#Set('b:SignatureIncludeMarks'   , g:SignatureIncludeMarks    , a:0 && a:1)
    1   0.000024   0.000008   call signature#utils#Set('b:SignatureIncludeMarkers' , g:SignatureIncludeMarkers  , a:0 && a:1)
    1   0.000022   0.000008   call signature#utils#Set('b:SignatureMarkOrder'      , g:SignatureMarkOrder       , a:0 && a:1)
    1   0.000022   0.000008   call signature#utils#Set('b:SignaturePrioritizeMarks', g:SignaturePrioritizeMarks , a:0 && a:1)
    1   0.000021   0.000007   call signature#utils#Set('b:SignatureDeferPlacement' , g:SignatureDeferPlacement  , a:0 && a:1)
    1   0.000020   0.000007   call signature#utils#Set('b:SignatureWrapJumps'      , g:SignatureWrapJumps       , a:0 && a:1)

FUNCTION  AutoPairsTryInit()
    Defined: ~/.config/nvim/plugged/auto-pairs/plugin/auto-pairs.vim:603
Called 1 time
Total time:   0.002146
 Self time:   0.000228

count  total (s)   self (s)
    1              0.000004   if exists('b:autopairs_loaded')
                                return
    1              0.000001   end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    1              0.000001   if g:AutoPairsMapCR
    1              0.000004     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    1              0.000062       let info = maparg('<CR>', 'i', 0, 1)
    1              0.000003       if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
    1              0.000001       else
    1              0.000003         let old_cr = info['rhs']
    1   0.000053   0.000013         let old_cr = s:ExpandMap(old_cr)
    1              0.000009         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
    1              0.000003         let is_expr = info['expr']
    1              0.000002         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    1              0.000001       endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
    1              0.000001     end
                            
    1              0.000004     if old_cr !~ 'AutoPairsReturn'
    1              0.000001       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
    1              0.000044         execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
    1              0.000002         let old_cr = wrapper_name
    1              0.000001       end
                                  " Always silent mapping
    1              0.000023       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    1              0.000001     end
    1              0.000001   endif
    1   0.001889   0.000012   call AutoPairsInit()

FUNCTION  <SNR>71_not_git_dir()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 1 time
Total time:   0.000096
 Self time:   0.000015

count  total (s)   self (s)
    1   0.000096   0.000014   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  xtabline#buffer#add()
    Defined: ~/.config/nvim/plugged/vim-xtabline/autoload/xtabline/buffer.vim:34
Called 10 times
Total time:   0.000393
 Self time:   0.000249

count  total (s)   self (s)
                              " Index buffer in xtabline dictionary.
   10              0.000052   if !has_key(s:X._buffers, a:nr)
                                " clean up any lingering customization, if present
    1              0.000006     if has_key(s:X.Buffers, a:nr) | unlet s:X.Buffers[a:nr] | endif
    1   0.000155   0.000011     let s:X._buffers[a:nr] = s:template(a:nr)
   10              0.000010   endif
   10              0.000039   return s:X._buffers[a:nr]

FUNCTION  <SNR>176_rgb2din99()
    Defined: ~/.config/nvim/plugged/vim-css-color/autoload/css_color.vim:46
Called 256 times
Total time:   0.035659
 Self time:   0.035659

count  total (s)   self (s)
  256              0.008163 	let [r,g,b] = map( copy(a:rgb), 'v:val > 0.04045 ? pow((v:val + 0.055) / 1.055, 2.4) : v:val / 12.92' )
                            
  256              0.001371 	let x = r * 0.4124 + g * 0.3576 + b * 0.1805
  256              0.001275 	let y = r * 0.2126 + g * 0.7152 + b * 0.0722
  256              0.001281 	let z = r * 0.0193 + g * 0.1192 + b * 0.9505
                            
                            	" Observer 2°, Illuminant D65
  256              0.000967 	let x = ( x * 100 ) /  95.0489
  256              0.000877 	let z = ( z * 100 ) / 108.8840
                            
  256              0.006325 	let [x,y,z] = map( [x,y,z], 'v:val > 0.008856 ? pow(v:val, s:_1_3) : 7.787 * v:val + s:_16_116' )
                            
  256              0.001890 	let [L,a,b] = [ (116 * y) - 16, 500 * (x - y), 200 * (y - z) ]
                            
  256              0.001547 	let L99 = 105.51 * log(1 + 0.0158 * L)
                            
  256              0.000975 	let e =        a * s:cos16 + b * s:sin16
  256              0.001215 	let f = 0.7 * (b * s:cos16 - a * s:sin16)
                            
  256              0.001437 	let g = 0.045 * sqrt(e*e + f*f)
  256              0.000580 	if g == 0
    2              0.000017 		let [a99, b99] = [0.0, 0.0]
  254              0.000309 	else
  254              0.001110 		let k = log(1 + g) / g
  254              0.000744 		let a99 = k * e
  254              0.000716 		let b99 = k * f
  256              0.000309 	endif
                            
  256              0.001072 	return [L99, a99, b99]

FUNCTION  <SNR>135_config_fugitive_branch()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/branch.vim:99
Called 53 times
Total time:   0.007614
 Self time:   0.001839

count  total (s)   self (s)
   53   0.006946   0.001171   let s:vcs_config['git'].branch = exists('*FugitiveHead') ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   53              0.000365   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
   53              0.000049   endif

FUNCTION  <SNR>159_synGroupID()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:47
Called 72 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
   72              0.000212 	return a:prefix.a:group.'_lv'.a:lv

FUNCTION  <SNR>124_check_defined_section()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:47
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000006   if !exists('w:airline_section_{a:name}')
                                let w:airline_section_{a:name} = g:airline_section_{a:name}
    1              0.000001   endif

FUNCTION  SyntasticStatuslineFlag()
    Defined: ~/.config/nvim/plugged/syntastic/plugin/syntastic.vim:697
Called 106 times
Total time:   0.031441
 Self time:   0.002948

count  total (s)   self (s)
  106   0.031371   0.002878     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  airline#extensions#syntastic#get_warning()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions/syntastic.vim:14
Called 53 times
Total time:   0.020418
 Self time:   0.000922

count  total (s)   self (s)
   53   0.020368   0.000872   return airline#extensions#syntastic#get('warning')

FUNCTION  airline#util#prepend()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:63
Called 371 times
Total time:   0.004572
 Self time:   0.004572

count  total (s)   self (s)
  371              0.001534   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  371              0.000320   endif
  371              0.001886   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>129_group_not_done()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/highlighter.vim:32
Called 108 times
Total time:   0.002289
 Self time:   0.002289

count  total (s)   self (s)
  108              0.001009     if index(a:list, a:name) == -1
  108              0.000833       call add(a:list, a:name)
  108              0.000270       return 1
                                else
                                  if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
                                  endif
                                  return 0
                                endif

FUNCTION  rainbow_main#gen_configs()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow_main.vim:104
Called 1 time
Total time:   0.000228
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000227   0.000035 	return filter(map(split(a:ft, '\v\.'), 'rainbow_main#gen_config(v:val)'), 'type(v:val) == type({})')

FUNCTION  coc#highlight#update_highlights()
    Defined: ~/.config/nvim/plugged/coc.nvim/autoload/coc/highlight.vim:76
Called 1 time
Total time:   0.000101
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000004   if !bufloaded(a:bufnr)
                                return
    1              0.000001   endif
    1              0.000004   let start = get(a:, 1, 0)
    1              0.000003   let end = get(a:, 2, -1)
    1              0.000002   if empty(a:highlights)
    1   0.000085   0.000013     call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
    1              0.000001     return
                              endif
                              let total = len(a:highlights)
                              " index list that exists with current highlights
                              let exists = []
                              let ns = coc#highlight#create_namespace(a:key)
                              let currIndex = 0
                              if has('nvim-0.5.0') || exists('*prop_list')
                                let current = coc#highlight#get(a:bufnr, a:key, start, end)
                                for lnum in sort(map(keys(current), 'str2nr(v:val)'), {a, b -> a - b})
                                  let items = current[lnum]
                                  let indexes = []
                                  let nextIndex = currIndex
                                  if currIndex != total
                                    for item in items
                                      for i in range(currIndex, total - 1)
                                        let hi = a:highlights[i]
                                        if hi['lnum'] > item['lnum']
                                          let nextIndex = i
                                          break
                                        endif
                                        if coc#helper#obj_equal(item, hi)
                                          call add(indexes, i)
                                          let nextIndex = max([nextIndex, i + 1])
                                        endif
                                      endfor
                                    endfor
                                  endif
                                  let currIndex = nextIndex
                                  " all highlights of current line exists, not clear.
                                  if len(indexes) == len(items)
                                    let exists = exists + indexes
                                  else
                                    if has('nvim')
                                      call nvim_buf_clear_namespace(a:bufnr, ns, lnum, lnum + 1)
                                    else
                                      call coc#api#call('buf_clear_namespace', [a:bufnr, ns, lnum, lnum + 1])
                                    endif
                                  endif
                                endfor
                              else
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
                              endif
                              for i in range(0, total - 1)
                                if index(exists, i) == -1
                                  let hi = a:highlights[i]
                                  call coc#highlight#add_highlight(a:bufnr, ns, hi['hlGroup'], hi['lnum'], hi['colStart'], hi['colEnd'])
                                endif
                              endfor

FUNCTION  illuminate#on_leaving_autocmds()
    Defined: ~/.config/nvim/plugged/vim-illuminate/autoload/illuminate.vim:40
Called 1 time
Total time:   0.000263
 Self time:   0.000057

count  total (s)   self (s)
    1   0.000147   0.000029   if s:should_illuminate_file()
    1   0.000111   0.000024     call s:remove_illumination()
    1              0.000002   endif

FUNCTION  <SNR>88_GetPythonBinary()
    Defined: ~/.config/nvim/plugged/vim-wakatime/plugin/wakatime.vim:286
Called 1 time
Total time:   0.000615
 Self time:   0.000517

count  total (s)   self (s)
    1              0.000011         let python_bin = g:wakatime_PythonBinary
    1              0.000049         if !filereadable(python_bin)
    1              0.000010             let paths = ['python3']
    1   0.000095   0.000043             if s:IsWindows()
                                            let pyver = 39
                                            while pyver >= 27
                                                let paths = paths + [printf('/Python%d/pythonw', pyver), printf('/python%d/pythonw', pyver), printf('/Python%d/python', pyver), printf('/python%d/python', pyver)]
                                                let pyver = pyver - 1
                                            endwhile
    1              0.000003             else
    1              0.000047                 let paths = paths + ['/usr/bin/python3', '/usr/local/bin/python3', '/usr/bin/python3.6', '/usr/local/bin/python3.6', '/usr/bin/python', '/usr/local/bin/python', '/usr/bin/python2', '/usr/local/bin/python2']
    1              0.000003             endif
    1              0.000018             let paths = paths + ['python']
    1              0.000007             let index = 0
    1              0.000012             let limit = len(paths)
    3              0.000019             while index < limit
    2              0.000075                 if filereadable(paths[index])
    1              0.000011                     let python_bin = paths[index]
    1              0.000005                     let index = limit
    2              0.000005                 endif
    2              0.000014                 let index = index + 1
    3              0.000011             endwhile
    1              0.000003         endif
    1   0.000092   0.000046         if s:IsWindows() && filereadable(printf('%sw', python_bin))
                                        let python_bin = printf('%sw', python_bin)
    1              0.000003         endif
    1              0.000006         return python_bin

FUNCTION  airline#util#has_vcscommand()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:165
Called 53 times
Total time:   0.000870
 Self time:   0.000870

count  total (s)   self (s)
   53              0.000251   if !exists("s:has_vcscommand")
    1              0.000010     let s:has_vcscommand = exists('*VCSCommandGetStatusLine')
   53              0.000047   endif
   53              0.000334   return get(g:, 'airline#extensions#branch#use_vcscommand', 0) && s:has_vcscommand

FUNCTION  <SNR>149_get_seperator()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 6 times
Total time:   0.008614
 Self time:   0.000155

count  total (s)   self (s)
    6   0.002886   0.000066   if airline#builder#should_change_group(a:prev_group, a:group)
    6   0.005724   0.000085     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>158_gcd()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow_main.vim:64
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000007 	let [a, b, t] = [a:a, a:b, 0]
    2              0.000004 	while b != 0
    1              0.000002 		let t = b
    1              0.000002 		let b = a % b
    1              0.000001 		let a = t
    2              0.000003 	endwhile
    1              0.000002 	return a

FUNCTION  rainbow#syn()
    Defined: ~/.config/nvim/plugged/rainbow/autoload/rainbow.vim:51
Called 1 time
Total time:   0.007087
 Self time:   0.004795

count  total (s)   self (s)
    1              0.000003 	let conf = a:config
    1              0.000003 	let prefix = conf.syn_name_prefix
    1              0.000002 	let cycle = conf.cycle
                            
    1   0.000271   0.000015 	let glob_paran_opts = s:resolve_parenthesis_from_config(conf)
    1              0.000003 	let b:rainbow_loaded = cycle
    4              0.000011 	for id in range(len(conf.parentheses))
    3   0.000792   0.000071 		let [paren, contained, containedin, contains_prefix, contains, op] = s:resolve_parenthesis_with(glob_paran_opts, conf.parentheses[id])
   27              0.000050 		for lv in range(cycle)
   24              0.000093 			let lv2 = ((lv + cycle - 1) % cycle)
   24   0.001004   0.000673 			let [rid, pid, gid2] = [s:synID(prefix, 'r', lv, id), s:synID(prefix, 'p', lv, id), s:synGroupID(prefix, 'Regions', lv2)]
                            
   24              0.000068 			if len(op) > 2
   24   0.001299   0.001093 				exe 'syn match '.s:synID(prefix, 'o', lv, id).' '.op.' containedin='.s:synID(prefix, 'r', lv, id).' contained'
   24              0.000023 			endif
                            
   24              0.000122 			let real_contained = (lv == 0)? (contained? 'contained ' : '') : 'contained '
   24   0.000231   0.000179 			let real_containedin = (lv == 0)? s:concat([containedin, '@'.gid2]) : '@'.gid2
   24   0.000579   0.000242 			let real_contains = s:concat([contains_prefix, contains])
   24              0.000818 			exe 'syn region '.rid.' matchgroup='.pid.' '.real_contained.'containedin='.real_containedin.' contains='.real_contains.' '.paren
   27              0.000029 		endfor
    4              0.000004 	endfor
    9              0.000013 	for lv in range(cycle)
    8   0.000395   0.000287 		exe 'syn cluster '.s:synGroupID(prefix, 'Regions', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "r", lv, v:val)'), ',')
    8   0.000389   0.000284 		exe 'syn cluster '.s:synGroupID(prefix, 'Parentheses', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "p", lv, v:val)'), ',')
    8   0.000391   0.000283 		exe 'syn cluster '.s:synGroupID(prefix, 'Operators', lv).' contains='.join(map(range(len(conf.parentheses)), 's:synID(prefix, "o", lv, v:val)'), ',')
    9              0.000008 	endfor
    1   0.000090   0.000069 	exe 'syn cluster '.prefix.'Regions contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Regions", v:val)'), ',')
    1   0.000095   0.000072 	exe 'syn cluster '.prefix.'Parentheses contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Parentheses", v:val)'), ',')
    1   0.000091   0.000068 	exe 'syn cluster '.prefix.'Operators contains='.join(map(range(cycle), '"@".s:synGroupID(prefix, "Operators", v:val)'), ',')
    1              0.000010 	if has_key(conf, 'after') | for cmd in conf.after | exe cmd | endfor | endif

FUNCTION  <SNR>71_abs_path()
    Defined: ~/.config/nvim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 5 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
    5              0.000111   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
    5              0.000082   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
    5              0.000016   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>38_init()
    Defined: ~/.config/nvim/plugged/vim-airline/plugin/airline.vim:15
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  airline#util#getbufvar()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/util.vim:71
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000006     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  149()
Called 2 times
Total time:   0.000787
 Self time:   0.000067

count  total (s)   self (s)
    2   0.000785   0.000065         return call('CocActionAsync', extend(['runCommand', a:name], a:000))

FUNCTION  dracula#should_abort()
    Defined: ~/.config/nvim/plugged/vim/autoload/dracula.vim:48
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000009     if ! exists('g:colors_name') || g:colors_name !=# 'dracula'
    1              0.000003         return 1
                                elseif a:0 > 0 && (! exists('b:current_syntax') || index(a:000, b:current_syntax) == -1)
                                    return 1
                                endif
                                return 0

FUNCTION  bm_sign#del()
    Defined: ~/.config/nvim/plugged/vim-bookmarks/autoload/bm_sign.vim:62
Called 4 times
Total time:   0.000456
 Self time:   0.000225

count  total (s)   self (s)
    4   0.000257   0.000026   call bm_sign#lazy_init()
    4              0.000003   try
    4              0.000115     execute "sign unplace ". a:sign_idx ." file=". a:file
    4              0.000072   catch
    4              0.000006   endtry

FUNCTION  <SNR>118_Filter()
    Defined: ~/.config/nvim/plugged/indentLine/after/plugin/indentLine.vim:286
Called 3 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    3              0.000017     if index(g:indentLine_fileTypeExclude, &filetype) != -1
                                    return 0
    3              0.000002     endif
                            
    3              0.000010     if index(g:indentLine_bufTypeExclude, &buftype) != -1
                                    return 0
    3              0.000001     endif
                            
    3              0.000013     if len(g:indentLine_fileType) != 0 && index(g:indentLine_fileType, &filetype) == -1
                                    return 0
    3              0.000001     endif
                            
    3              0.000009     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) == bufname('')
                                        return 0
                                    endif
    3              0.000003     endfor
                            
    3              0.000003     return 1

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/extensions.vim:505
Called 53 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
   53              0.000168   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/.config/nvim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000011   let builder = copy(s:prototype)
    1              0.000003   let builder._context = a:context
    1              0.000002   let builder._sections = []
                            
    1              0.000018   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    1              0.000001   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   56   0.184929   0.013631  airline#check_mode()
    4   0.166054   0.023197  airline#highlighter#highlight()
  147   0.118059   0.035931  airline#highlighter#exec()
  229   0.092263   0.040508  airline#highlighter#get_highlight()
    1   0.091668   0.005014  <SNR>9_SynSet()
   53   0.060917   0.004035  airline#extensions#branch#get_head()
   35   0.057580   0.003991  <SNR>129_exec_separator()
   53   0.053819   0.013405  airline#extensions#branch#head()
  916   0.047962             <SNR>129_get_syn()
  106   0.037696   0.006255  airline#extensions#syntastic#get()
  256   0.035659             <SNR>176_rgb2din99()
  106   0.031441   0.002948  SyntasticStatuslineFlag()
   53   0.028207   0.003956  WebDevIconsGetFileFormatSymbol()
   70   0.027944   0.001795  airline#themes#get_highlight()
   53   0.024064   0.005539  <SNR>135_update_branch()
    1   0.020937   0.019547  <SNR>7_LoadFTPlugin()
   53   0.020418   0.000922  airline#extensions#syntastic#get_warning()
   53   0.019097   0.000898  airline#extensions#syntastic#get_error()
   53   0.018390   0.012144  airline#extensions#whitespace#check()
   55   0.017965   0.017112  WebDevIconsGetFileTypeSymbol()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  916              0.047962  <SNR>129_get_syn()
  229   0.092263   0.040508  airline#highlighter#get_highlight()
  147   0.118059   0.035931  airline#highlighter#exec()
  256              0.035659  <SNR>176_rgb2din99()
    4   0.166054   0.023197  airline#highlighter#highlight()
    1   0.020937   0.019547  <SNR>7_LoadFTPlugin()
   55   0.017965   0.017112  WebDevIconsGetFileTypeSymbol()
  106              0.013872  55()
   56   0.184929   0.013631  airline#check_mode()
   53   0.053819   0.013405  airline#extensions#branch#head()
   15   0.012943   0.012699  <SNR>176_parse_screen()
   53   0.018390   0.012144  airline#extensions#whitespace#check()
   53   0.015039   0.009254  <SNR>135_update_untracked()
   37              0.009029  <SNR>129_GetHiCmd()
   53   0.015658   0.008593  airline#extensions#hunks#get_hunks()
  484              0.008204  airline#util#winwidth()
  107              0.007706  45()
  212   0.011256   0.007376  airline#util#shorten()
  106              0.007243  airline#extensions#nvimlsp#get()
  586   0.008634   0.007023  airline#util#wrap()

